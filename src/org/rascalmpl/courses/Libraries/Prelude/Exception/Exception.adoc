
[[Prelude-Exception]]


[[Prelude-Exception]]
# Exception
:concept: Prelude/Exception
.Usage
`import Exception;`



.Synopsis
Exceptions thrown by the Rascal run-time.


* <<Exception-RuntimeException,RuntimeException>>: The `Exception` datatype used in all Rascal exceptions.
      

[[Exception-RuntimeException]]
## RuntimeException
.Types
[source,rascal]
----


data RuntimeException = 
       Ambiguity(loc location, str nonterminal, str sentence)
     | ArithmeticException(str message)
     | AssertionFailed() 
     | AssertionFailed(str label)
     | EmptyList()
     | EmptyMap() 
     | EmptySet()
     | IllegalArgument()
     | IllegalArgument(value v)
     | IllegalArgument(value v, str message)
     | IndexOutOfBounds(int index)
     | IO(str message)
     | Java(str class, str message)
     | Java(str class, str message, RuntimeException cause)
     | ModuleNotFound(str name)
     | NoSuchAnnotation(str label)
     | NoMainFunction()
     | NoSuchKey(value key)
     | MultipleKey(value key)
     | ParseError(loc location)
     | PathNotFound(loc l)
     | PathNotFound(set[loc] locs)
     | StackOverflow()
     
// Status to be determined:     
     
//   | AccessDenied(loc l)
//   | FileNotFound(str file)
//   | IllegalIdentifier(str name)
//   | SchemeNotSupported(loc l)
//   | HostNotFound(loc l)
     | ImplodeError(str message)
//   | MissingCase(value x)
     | NoSuchElement(value v)
     | PermissionDenied()
     | PermissionDenied(str message)
//   | Subversion(str message)
     | Timeout()

   
	 ;
----

.Synopsis
The `Exception` datatype used in all Rascal exceptions.

.Description
Since declarations for ADTs are extensible, the user can add new exceptions when needed.

Exceptions are either generated by the Rascal run-time (e.g., `IndexOutOfBounds`) or they
are generated by a link:{RascalLang}#Statements-Throw[throw].
Exceptions can be caught with a link:{RascalLang}#Statements-TryCatch[try catch].

.Examples

Import relevant libraries:
[source,rascal-shell-error]
----
rascal>import Exception;
ok
rascal>import IO;
ok
----
Define the map `weekend` and do a subscription with a non-existing key:
[source,rascal-shell-error]
----
rascal>weekend = ("saturday": 1, "sunday": 2);
map[str, int]: ("sunday":2,"saturday":1)
rascal>weekend["monday"];
NoSuchKey("monday") at |test-modules:///ConsoleInput.rsc|(114,17,<8,15>,<8,32>)
Call stack (most recent first):
	main([]) at |test-modules:///ConsoleInput.rsc|(114,17,<8,15>,<8,32>)

ok
----
Repeat this, but catch the exception. We use variable `N` to track what happened:
[source,rascal-shell-error]
----
rascal>N = 1;
int: 1
rascal>try {
>>>>>>>   N = weekend["monday"];
>>>>>>>} catch NoSuchKey(v):
>>>>>>>  N = 100;
int: 100
rascal>println(N);
1
ok
----



:leveloffset: +1

:leveloffset: -1
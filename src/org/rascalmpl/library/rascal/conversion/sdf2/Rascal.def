definition
module languages/rascal/syntax/RascalForAbstractSyntax

imports languages/rascal/syntax/RascalForImportExtraction
imports languages/rascal/syntax/Rascal

exports
context-free start-symbols
  Module Command
module languages/rascal/syntax/Expressions

imports 
        languages/rascal/syntax/Statements
        languages/rascal/syntax/Constructors
exports
sorts Expression EOS

exports

sorts
 Formals Formal Parameters
context-free syntax
  type:Type name:Name                                                  -> Formal {cons("TypeName")}
  formals:{Formal ","}*                                                -> Formals {cons("Default")}
  "(" formals:Formals ")"                                              -> Parameters {cons("Default")}

  "(" formals:Formals "..." ")"                                        -> Parameters {cons("VarArgs")}

context-free syntax
  type:Type parameters:Parameters "{" statements:Statement+ "}"        -> Expression {cons("Closure")} 
  parameters:Parameters "{" statements:Statement+ "}"                  -> Expression {cons("VoidClosure")} 
  "{" statements:Statement+ "}"                                        -> Expression {cons("NonEmptyBlock")}

context-free syntax
  "(" expression:Expression ")"                                        -> Expression {cons("Bracket"),bracket} 

context-free syntax
  "[" first:Expression ".."  last:Expression "]"                       -> Expression {cons("Range")}     
  "[" first:Expression "," second:Expression ".." last:Expression "]"  -> Expression {cons("StepRange")} 

context-free syntax
  "#" type:Type -> Expression {cons("ReifyType")}

context-free syntax
    mid:MidProtocolChars expression:Expression tail:ProtocolTail -> ProtocolTail {cons("Mid")}
    post:PostProtocolChars                        -> ProtocolTail {cons("Post")}
    pre:PreProtocolChars expression:Expression tail:ProtocolTail -> ProtocolPart {cons("Interpolated")}
  
context-free syntax
    mid:MidPathChars expression:Expression tail:PathTail         -> PathTail {cons("Mid")}
    post:PostPathChars                            -> PathTail {cons("Post")}
    pre:PrePathChars expression:Expression tail:PathTail         -> PathPart {cons("Interpolated")}

sorts
    Field
    
context-free syntax
  	fieldName:Name                                                  -> Field {cons("Name")}
  	fieldIndex:IntegerLiteral                                       -> Field {cons("Index")}            

context-free priorities
  {
  basicType:BasicType "(" arguments:{Expression ","}* ")"                 -> Expression {cons("ReifiedType")}
  expression:Expression "(" arguments:{Expression ","}* ")"          -> Expression {cons("CallOrTree")}
  expression:Expression "[" key:Name "=" replacement:Expression "]"  -> Expression {cons("FieldUpdate")}
  expression:Expression "." field:Name                               -> Expression {cons("FieldAccess")}
  expression:Expression "<" fields:{Field ","}+ ">"                  -> Expression {cons("FieldProject")}
  expression:Expression "[" subscripts: {Expression ","}+"]"         -> Expression {cons("Subscript")}
  }
  <0>
  >
  {
  argument:Expression "?"               -> Expression {cons("IsDefined")}
  }
  >
  {
  "!" argument:Expression               -> Expression {cons("Negation")}
  "-" argument:Expression               -> Expression {cons("Negative")}
  }
  >
  {
    argument:Expression "*"             -> Expression {cons("TransitiveReflexiveClosure")}
    argument:Expression "+"             -> Expression {cons("TransitiveClosure")}                             
  }
  >
  {
  expression:Expression "@" name:Name   -> Expression {cons("GetAnnotation")} 
  expression:Expression "[" "@" name:Name "=" value: Expression "]"
                                        -> Expression {cons("SetAnnotation")}
  }
  >
  lhs:Expression "o" rhs:Expression     -> Expression {cons("Composition"), left}
  >
  {left:
  lhs:Expression "*" rhs:Expression     -> Expression {cons("Product"), left}
  lhs:Expression "join" rhs:Expression-> Expression {cons("Join"), left}
  }
  >
  {left:
  lhs:Expression "/" rhs:Expression     -> Expression {cons("Division"), left} 
  lhs:Expression "%" rhs:Expression     -> Expression {cons("Modulo"), left} 
  }
  >
  lhs:Expression "&" rhs:Expression   -> Expression {cons("Intersection"), left} 
  >
  {left:
    lhs:Expression "+" rhs:Expression   -> Expression {cons("Addition"), left}                                   
    lhs:Expression "-" rhs:Expression   -> Expression {cons("Subtraction"), left}
  } 
  
  >
  {non-assoc:
  lhs:Expression "notin" rhs:Expression -> Expression {non-assoc,cons("NotIn")}
  lhs:Expression "in" rhs:Expression    -> Expression {non-assoc,cons("In")}
  }
  >
  {non-assoc:
    lhs:Expression "<" rhs:Expression   -> Expression {non-assoc,cons("LessThan")}
    lhs:Expression "<=" rhs:Expression  -> Expression {non-assoc,cons("LessThanOrEq")}
    lhs:Expression ">" rhs:Expression   -> Expression {non-assoc,cons("GreaterThan")}
    lhs:Expression ">=" rhs:Expression  -> Expression {non-assoc,cons("GreaterThanOrEq")}
  }
  >
  {left:
    lhs:Expression "==" rhs:Expression  -> Expression {left,cons("Equals")}
    lhs:Expression "!=" rhs:Expression  -> Expression {left,cons("NonEquals")}
    condition:Expression "?" thenExp:Expression ":" elseExp:Expression -> Expression {right,cons("IfThenElse")}
  }
  >
  lhs:Expression "?" rhs:Expression     -> Expression {non-assoc,cons("IfDefinedOtherwise")}
  >
  {non-assoc:
  lhs:Expression "==>" rhs:Expression   -> Expression {right, cons("Implication")}
  lhs:Expression "<==>" rhs:Expression  -> Expression {right, cons("Equivalence")}
  }
  >
  lhs:Expression "&&" rhs:Expression    -> Expression {left, cons("And")} 
  >
  lhs:Expression "||" rhs:Expression    -> Expression {left, cons("Or")}

context-free priorities
  %% removes non-sensical a + - b (equal to a - b), which fixes ambiguity with transitive closure
  { Expression "+" Expression -> Expression
    Expression "*" Expression -> Expression 
  }.<2>> "-" Expression -> Expression

context-free restrictions
  "&" -/- [\&]
  "<" -/- [\=]
  ">" -/- [\=]
  "!" -/- [\~]
  "!" -/- [\=]
  "notin" -/- [a-zA-Z\-\_0-9]
  "in" -/- [a-zA-Z\-\_0-9]
  "join" -/- [a-zA-Z\-\_0-9]
  "o" -/- [a-zA-Z\-\_0-9]
  "==" -/- [\>]
  "<=" -/- [\=].[\>]
module languages/rascal/syntax/RascalForImportExtraction

imports languages/rascal/syntax/Modules[Body]
imports basic/Whitespace

hiddens
context-free start-symbols Module

exports
sorts Body Marker Rest

lexical syntax
	                   -> Marker 
      {~[\n]* [\n]}*        -> Rest   
                            -> Rest {prefer}

context-free syntax
	marker:Marker rest:Rest -> Body {cons("Anything"),avoid}

lexical restrictions
	Marker -/- [i].[m].[p].[o].[r].[t]
	Marker -/- [\[]
        ~[\n]*   -/- ~[\n]
        {~[\n]* [\n]}* -/- [\n]
module basic/Whitespace

exports
  lexical syntax
    [\ \t\n\r]	-> LAYOUT {cons("whitespace")}

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
module languages/rascal/syntax/Lexical

imports basic/Whitespace

exports 

  sorts StringLiteral
        CharacterLiteral BooleanLiteral IntegerLiteral
        OctalIntegerLiteral HexIntegerLiteral DecimalIntegerLiteral
        StringCharacter EscapeSequence UnicodeEscape SingleCharacter
	DecimalLongLiteral HexLongLiteral OctalLongLiteral LongLiteral
	RealLiteral

  lexical syntax
    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape

    "0" 			                                   -> DecimalIntegerLiteral
    [1-9] [0-9]* 		                                   -> DecimalIntegerLiteral
    [0] [xX] [0-9a-fA-F]+	                                   -> HexIntegerLiteral
    [0] [0-7]+	 		                          -> OctalIntegerLiteral

    "0" [lL] 			                          -> DecimalLongLiteral
    [1-9] [0-9]* [lL] 		                          -> DecimalLongLiteral
    [0] [xX] [0-9a-fA-F]+ [lL] 	                          -> HexLongLiteral
    [0] [0-7]+ [lL] 		                          -> OctalLongLiteral

    [0-9]+ "." [0-9]* ( [eE] [\+\-]? [0-9]+ )? [dD]?          -> RealLiteral
    "." [0-9]+ ( [eE] [\+\-]? [0-9]+ )? [dD]?                 -> RealLiteral
    [0-9]+ [eE] [\+\-]? [0-9]+ [dD]?                          -> RealLiteral
    [0-9]+ ( [eE] [\+\-]? [0-9]+ )? [dD]                      -> RealLiteral

    "true"                                                    -> BooleanLiteral
    "false"                                                   -> BooleanLiteral
    UnicodeEscape                                             -> SingleCharacter
    ~[\'\\]                                                   -> SingleCharacter
    "'" SingleCharacter "'"                                   -> CharacterLiteral
    "\\" [0-7]                                                -> EscapeSequence
    "\\" [0-7] [0-7]                                          -> EscapeSequence
    "\\" [0-3] [0-7] [0-7]                                    -> EscapeSequence
    "'" EscapeSequence "'"                                    -> CharacterLiteral
    UnicodeEscape                                             -> StringCharacter

    %% Slight deviation from Java strings: <and >  must be escaped.
    "\\" [btnfr\"\'\\\<\>]                                    -> EscapeSequence
    ~[\"\\\<\>]                                               -> StringCharacter
    EscapeSequence                                            -> StringCharacter
    "\"" StringCharacter* "\""                                -> StringLiteral

  sorts LocationLiteral ProtocolChars PreProtocolChars MidProtocolChars PostProtocolChars PrePathChars MidPathChars PostPathChars PathChars ProtocolTail
        PathTail PathPart ProtocolPart 
  lexical syntax
    [\|] URLChars "://"   -> ProtocolChars
    "|" URLChars "<"    -> PreProtocolChars
    ">" URLChars "<"    -> MidProtocolChars
    ">" URLChars "://"  -> PostProtocolChars

    URLChars "<"        -> PrePathChars
    ">" URLChars "<"    -> MidPathChars
    ">" URLChars "|"    -> PostPathChars
    URLChars [\|]       -> PathChars


  context-free syntax
    protocolChars:ProtocolChars                            -> ProtocolPart {cons("NonInterpolated")}
    pathChars:PathChars                                    -> PathPart {cons("NonInterpolated")}
    protocolPart:ProtocolPart pathPart:PathPart            -> LocationLiteral {cons("Default")}
    pathPart:PathPart                                      -> LocationLiteral {cons("File")}
 
 

  sorts URLChars
  lexical syntax
    ~[\ \t\n\r\|\<]* -> URLChars

  lexical restrictions
    "://" -/- [\ \t\n\r]
 
  lexical restrictions
    DecimalIntegerLiteral -/- [a-zA-Z0-9\_]
    HexIntegerLiteral -/- [a-zA-Z0-9\_]
    OctalIntegerLiteral -/- [a-zA-Z0-9\_]    
    DecimalLongLiteral -/- [a-zA-Z0-9\_]
    HexLongLiteral -/- [a-zA-Z0-9\_]
    OctalLongLiteral -/- [a-zA-Z0-9\_]
    RealLiteral -/- [a-zA-Z0-9\_]

  context-free syntax
    decimal:DecimalIntegerLiteral 	-> IntegerLiteral {prefer,cons("DecimalIntegerLiteral")}
    hex:HexIntegerLiteral 	        -> IntegerLiteral {prefer,cons("HexIntegerLiteral")}
    octal:OctalIntegerLiteral 	    -> IntegerLiteral {prefer,cons("OctalIntegerLiteral")}

    decimalLong:DecimalLongLiteral 	-> LongLiteral {prefer,cons("DecimalLongLiteral")}
    hexLong:HexLongLiteral 	        -> LongLiteral {prefer,cons("HexLongLiteral")}
    octalLong:OctalLongLiteral 	    -> LongLiteral {prefer,cons("OctalLongLiteral")}
module languages/rascal/syntax/Interpolation

imports languages/rascal/syntax/Expressions

exports

syntax
  [\<] <LAYOUT? -CF> <Expression -CF> <LAYOUT? -CF> [\>]  -> <RegExp -LEX> {category("MetaVariable")}
  [\<] <LAYOUT? -CF> <Expression -CF> <LAYOUT? -CF> [\>]  -> <StringCharacter -LEX> {category("MetaVariable")}
module languages/rascal/syntax/Types

imports languages/rascal/syntax/Tags
        languages/rascal/syntax/Symbols
        languages/rascal/syntax/Names

exports
sorts Type

sorts BasicType

context-free syntax
  "bool"   -> BasicType {cons("Bool")}   
  "int"    -> BasicType {cons("Int")}    
  "real"   -> BasicType {cons("Real")} 
  "str"    -> BasicType {cons("String")} 
  "value"  -> BasicType {cons("Value")}  
  "node"   -> BasicType {cons("Node")}   
  "void"   -> BasicType {cons("Void")}   
  "loc"    -> BasicType {cons("Loc")}   
  "list"   -> BasicType {cons("List")}     
  "set"    -> BasicType {cons("Set")}  
  "bag"    -> BasicType {cons("Bag")}    
  "map"    -> BasicType {cons("Map")}      
  "rel"    -> BasicType {cons("Relation")} 
  "tuple"  -> BasicType {cons("Tuple")}   
  "lex"    -> BasicType {cons("Lex")}
  "type"   -> BasicType {cons("ReifiedType")}
  "adt"    -> BasicType {cons("ReifiedAdt")}
  "constructor"  -> BasicType {cons("ReifiedConstructor")}
  "fun"   -> BasicType       {cons("ReifiedFunction")}
  "non-terminal" -> BasicType {cons("ReifiedNonTerminal")}
  "reified"      -> BasicType {cons("ReifiedReifiedType")}

sorts TypeArg

context-free syntax
  type:Type                                             -> TypeArg {cons("Default")} 
  type:Type name:Name                                   -> TypeArg {cons("Named")}   

sorts StructuredType

context-free syntax
  basicType:BasicType "[" arguments:{TypeArg ","}+ "]"      -> StructuredType {cons("Default")} 

sorts FunctionType

context-free syntax
  type:Type "(" arguments:{TypeArg ","}* ")"            -> FunctionType {cons("TypeArguments")} 

sorts TypeVar

context-free syntax
  "&" name:Name                                         -> TypeVar {cons("Free")}    
  "&" name:Name "<:" bound:Type                         -> TypeVar {cons("Bounded")} 

sorts UserType

context-free syntax
  name:Name                                             -> UserType {cons("Name")} 
  name:Name "[" parameters:{Type ","}+ "]"              -> UserType {cons("Parametric")}   

sorts DataTypeSelector

context-free syntax
  sort:Name "." production:Name                         -> DataTypeSelector {cons("Selector")} 

context-free syntax
  basic:BasicType                                       -> Type {cons("Basic")}      
  structured:StructuredType                             -> Type {cons("Structured")} 
  function:FunctionType                                 -> Type {cons("Function")}   
  typeVar:TypeVar                                       -> Type {cons("Variable")}   
  user:UserType                                         -> Type {cons("User")}       
  selector:DataTypeSelector                             -> Type {cons("Selector")}   
  "(" type:Type ")"                                     -> Type {bracket, cons("Bracket")}
module languages/rascal/syntax/Statements

imports languages/rascal/syntax/Generators
        languages/rascal/syntax/Declarations

exports
sorts Statement Bound EOS
context-free start-symbols Statement

context-free syntax
                                                                               -> Bound     {cons("Empty")}   
  ";" expression:Expression                                                    -> Bound     {cons("Default")} 
  "solve" "(" variables:{QualifiedName ","}+ bound:Bound ")" body:Statement    -> Statement {cons("Solve")}   

context-free syntax
  label:Label "for" "(" generators:{Expression ","}+ ")" body:Statement                                         -> EOS {cons("For")}          
  label:Label "while" "(" condition:Expression ")" body:Statement                                               -> EOS {cons("While")}      
  label:Label "do" body:Statement "while" "(" condition:Expression ")" ";"                                      -> EOS {cons("DoWhile")}    
  label:Label "if" "(" conditions:{Expression ","}+ ")" thenStatement:Statement "else" elseStatement:Statement  -> Statement {cons("IfThenElse")} 
  label:Label "if" "(" conditions:{Expression ","}+ ")" thenStatement:Statement noElseMayFollow:NoElseMayFollow -> Statement {cons("IfThen")}     
  label:Label "switch" "(" expression:Expression ")" "{" cases:Case+ "}"                                        -> Statement {cons("Switch")}     

sorts NoElseMayFollow

context-free syntax
   -> NoElseMayFollow  {cons("Default")}

context-free restrictions
  NoElseMayFollow -/- [e].[l].[s].[e]

sorts Assignable

context-free syntax
  qualifiedName:QualifiedName                          -> Assignable {cons("Variable")}

context-free priorities
{
  receiver:Assignable "[" subscript:Expression "]"     -> Assignable {cons("Subscript")}   
  receiver:Assignable "." field:Name                   -> Assignable {cons("FieldAccess")} 
  receiver:Assignable "?" defaultExpression:Expression -> Assignable {cons("IfDefinedOrDefault")}    
}
<0> >
{non-assoc:    
  receiver:Assignable "@" annotation:Name              -> Assignable {non-assoc, cons("Annotation")}
  "<" elements:{Assignable ","}+ ">" 		 -> Assignable {cons("Tuple")}       
  name:Name "(" arguments:{Assignable ","}+ ")"        -> Assignable {non-assoc, cons("Constructor")} 
}

sorts Assignment

context-free syntax
  "="  -> Assignment {cons("Default")}       
  "+=" -> Assignment {cons("Addition")}      
  "-=" -> Assignment {cons("Subtraction")}  
  "*=" -> Assignment {cons("Product")}       
  "/=" -> Assignment {cons("Division")}      
  "&=" -> Assignment {cons("Intersection")} 
  "?=" -> Assignment {cons("IfDefined")}

context-free restrictions
  "*" -/- [\=]
  "/" -/- [\=]
  "+" -/- [\=]
  "&" -/- [\=]
  "-" -/- [\=]
  "*" -/- [\=]
  "=" -/- [\=]
  "?" -/- [\=]

sorts Label

context-free syntax
  ";"                       -> Statement {cons("EmptyStatement")}
  expression:Expression ";" -> Statement {cons("Expression")} 

  eos:EOS                   -> Statement {cons("EOS")}
  eos:EOS                   -> Expression {cons("EOS")}

  visit:Visit               -> EOS       {cons("Visit")} 
     
                            -> Label     {cons("Empty")}      
  name:Name ":"             -> Label     {cons("Default")}    

context-free priorities 
  expression:Expression ";" -> Statement {prefer, cons("Expression")}
  <0> . >
{
  eos:EOS                       -> Statement {cons("EOS")}
  "{" statements:Statement+ "}" -> Expression {cons("NonEmptyBlock")}
%%   visit:Visit                  -> Expression {cons("Visit")} 
}

context-free syntax
  assignable:Assignable operator:Assignment expression:Expression ";" -> Statement {cons("Assignment")} 

sorts Break Fail Return

context-free syntax
  "break" label:Name ";"             -> Break     {cons("WithLabel")}      
  "break" ";"                        -> Break     {cons("NoLabel")}        
  brk:Break                          -> Statement {cons("Break")}          
  "fail" label:Name ";"              -> Fail      {cons("WithLabel")}      
  "fail" ";"                         -> Fail      {cons("NoLabel")}        
  fail:Fail                          -> Statement {cons("Fail")}           
  "return" expression:Expression ";" -> Return    {cons("WithExpression")} 
  "return" ";"                       -> Return    {cons("NoExpression")}   
  ret:Return                         -> Statement {cons("Return")}         

context-free syntax
  "continue" ";"                                               -> Statement {cons("Continue")} 
  "assert" expression:Expression ";"                           -> Statement {cons("Assert")} 
  "assert" expression:Expression ":" message:StringLiteral ";" -> Statement {cons("AssertWithMessage")}   
  "insert" expression:Expression ";"                           -> Statement {cons("Insert")}   
  "throw" expression:Expression ";"                            -> Statement {cons("Throw")}    

sorts Catch

context-free syntax
  "catch" ":" body:Statement                                           -> Catch     {cons("Default")}        
  "catch" pattern:Pattern ":" body:Statement                           -> Catch     {cons("Binding")}         
  "try" body:Statement handlers:Catch+                                 -> Statement {non-assoc, cons("Try")} 
  "try" body:Statement handlers:Catch+ "finally" finallyBody:Statement -> Statement {cons("TryFinally")}     

context-free syntax
  label:Label "{" statements:Statement+ "}" -> Statement {cons("Block")}               
  functionDeclaration:FunctionDeclaration   -> Statement {cons("FunctionDeclaration")} 

sorts LocalVariableDeclaration Declarator

context-free syntax
  declaration:LocalVariableDeclaration ";" -> Statement                {cons("VariableDeclaration")} 
  type:Type variables:{Variable ","}+      -> Declarator               {cons("Default")}             
  declarator:Declarator                    -> LocalVariableDeclaration {cons("Default")}             
  "dynamic" declarator:Declarator          -> LocalVariableDeclaration {cons("Dynamic")}             

context-free syntax
  "global" type:Type names:{QualifiedName ","}+ ";" -> Statement {cons("GlobalDirective")}
module languages/rascal/syntax/Generators

imports languages/rascal/syntax/Patterns
        languages/rascal/syntax/Expressions
        languages/rascal/syntax/Interpolation

exports


context-free priorities
  
  condition:Expression "?" thenExp:Expression ":" 
                           elseExp:Expression     -> Expression {right,cons("IfThenElse")}
  >
  {
   from:Expression ":" to:Expression               ->  Mapping[[Expression]] {cons("Default")} 
   lhs:Expression "?" rhs:Expression               -> Expression {non-assoc,cons("IfDefinedOtherwise")}
  }
  >
  {non-assoc:
  pattern:Pattern ":=" expression:Expression      -> Expression {non-assoc, cons("Match")}   
  pattern:Pattern "!:=" expression:Expression     -> Expression {non-assoc, cons("NoMatch")}
  } 
  >
  {
   pattern:Pattern "<-" expression:Expression     -> Expression {prefer,cons("Enumerator")} 
%%   strategy:Strategy pattern:Pattern "<-" 
%%                     expression:Expression        -> Expression {prefer,cons("EnumeratorWithStrategy")} 
  }
  >
  lhs:Expression "==" rhs:Expression              -> Expression {left,cons("Equals")}  
  

sorts Strategy

context-free syntax
  "top-down"        -> Strategy {cons("TopDown")}       
  "top-down-break"  -> Strategy {cons("TopDownBreak")}  
  "bottom-up"       -> Strategy {cons("BottomUp")}      
  "bottom-up-break" -> Strategy {cons("BottomUpBreak")} 
  "outermost"       -> Strategy {cons("Outermost")}     
  "innermost"       -> Strategy {cons("Innermost")}     

sorts Comprehension

context-free syntax
  comprehension:Comprehension                                                 -> Expression    {cons("Comprehension")} 
  "{" results:{Expression ","}+ "|" generators:{Expression ","}+ "}"          -> Comprehension {cons("Set")}           
  "[" results:{Expression ","}+ "|" generators:{Expression ","}+ "]"          -> Comprehension {cons("List")}          
  "(" from:Expression ":" to:Expression "|" generators:{Expression ","}+ ")"  -> Comprehension {cons("Map")}          
  "all" "(" generators:{Expression ","}+ ")"                                  -> Expression    {cons("All")}        
  "any" "(" generators:{Expression ","}+ ")"                                  -> Expression    {cons("Any")}       

context-free restrictions
  "|" -/- [\|]
  ":" -/- [\=]
  "!" -/- [\:]
  "=" -/- [\=]

sorts PatternWithAction Case Replacement

context-free syntax
  replacementExpression:Expression                                          -> Replacement {cons("Unconditional")}
  replacementExpression:Expression "when" conditions:{Expression ","}+      -> Replacement {cons("Conditional")}

  pattern:Pattern "=>" replacement:Replacement                              -> PatternWithAction {cons("Replacing")} 
  pattern:Pattern ":" statement:Statement                                   -> PatternWithAction {cons("Arbitrary")} 
    
  "case" patternWithAction:PatternWithAction                                -> Case  {cons("PatternWithAction")}      
  "default" ":" statement:Statement                                         -> Case  {cons("Default")}   

sorts Visit

lexical restrictions
  "=" -/- [\>]
  "<" -/- [\-]

context-free syntax
  "visit" "(" subject:Expression ")" "{" cases:Case+ "}"                   -> Visit      {cons("DefaultStrategy")} 
  strategy:Strategy "visit" "(" subject:Expression ")" "{" cases:Case+ "}" -> Visit      {cons("GivenStrategy")}
module languages/rascal/syntax/Modules[Body]

imports languages/rascal/syntax/Names
        languages/rascal/syntax/Types
        languages/rascal/syntax/Comments

exports
sorts Import ModuleParameters ModuleActuals
      ImportedModule Renaming Renamings Module

context-free syntax
  header:Header body:Body -> Module {cons("Default")} 

context-free syntax
  "[" types:{Type ","}+ "]"                                 -> ModuleActuals  {cons("Default")}         
  name:QualifiedName actuals:ModuleActuals renamings:Renamings -> ImportedModule {cons("ActualsRenaming")} 
  name:QualifiedName actuals:ModuleActuals                     -> ImportedModule {cons("Actuals")}         
  name:QualifiedName renamings:Renamings                       -> ImportedModule {cons("Renamings")}       
  name:QualifiedName                                           -> ImportedModule {cons("Default")}         
  from:Name "=>" to:Name                                    -> Renaming       {cons("Default")}         
  "renaming" renamings:{Renaming ","}+                      -> Renamings      {cons("Default")}         

context-free syntax
  "import" module:ImportedModule ";" -> Import {cons("Default")} 
  "extend" module:ImportedModule ";" -> Import {cons("Extend")}  

sorts Header

context-free syntax
  "[" parameters:{TypeVar ","}+ "]"                                              -> ModuleParameters {cons("Default")}    
  tags:Tags "module" name:QualifiedName imports:Import*                          -> Header           {cons("Default")}    
  tags:Tags "module" name:QualifiedName params:ModuleParameters  imports:Import* -> Header           {cons("Parameters")}
module languages/rascal/syntax/Reserved

exports
%% TODO: review this list

sorts Reserved

context-free syntax
  "alias"    -> Reserved
  "all"      -> Reserved 
  "anno"     -> Reserved
  "any"      -> Reserved
  "assert"   -> Reserved 
  "bag"      -> Reserved
  "bool"     -> Reserved
  "case"     -> Reserved  
  "catch"    -> Reserved
  "data"     -> Reserved 
  "default"  -> Reserved  
  "dynamic"  -> Reserved 
  "else"     -> Reserved
  "extend"   -> Reserved
  "fail"     -> Reserved
  "false"    -> Reserved
  "for"      -> Reserved
  "finally"  -> Reserved 
  "global"   -> Reserved
  "if"       -> Reserved
  "import"   -> Reserved
  "in"       -> Reserved  
  "insert"   -> Reserved  
  "int"      -> Reserved
  "join"     -> Reserved
  "list"     -> Reserved
  "loc"      -> Reserved
  "map"      -> Reserved
  "module"   -> Reserved
  "node"     -> Reserved
  "notin"    -> Reserved 
  "on"       -> Reserved 
  "one"      -> Reserved  
  "private"  -> Reserved  
  "public"   -> Reserved
  "real"     -> Reserved
  "rel"      -> Reserved
  "repeat"   -> Reserved 
  "return"   -> Reserved 
  "rule"     -> Reserved
  "set"      -> Reserved
  "solve"    -> Reserved 
  "str"      -> Reserved
  "switch"   -> Reserved  
  "tag"      -> Reserved 
  "throw"    -> Reserved
  "throws"   -> Reserved 
  "true"     -> Reserved
  "try"      -> Reserved  
  "tuple"    -> Reserved
  "type"     -> Reserved
  "value"    -> Reserved
  "view"     -> Reserved  
  "visit"    -> Reserved 
  "void"     -> Reserved
  "while"    -> Reserved
  "adt"          -> Reserved
  "constructor"  -> Reserved
  "reified"      -> Reserved
  "non-terminal" -> Reserved
  "fun"          -> Reserved

context-free restrictions
  "all"      -/- [a-zA-Z0-9\-\_] 
  "anno"     -/- [a-zA-Z0-9\-\_]
  "any"      -/- [a-zA-Z0-9\-\_]
  "assert"   -/- [a-zA-Z0-9\-\_] 
  "bool"     -/- [a-zA-Z0-9\-\_]
  "case"     -/- [a-zA-Z0-9\-\_]  
  "catch"    -/- [a-zA-Z0-9\-\_]
  "data"     -/- [a-zA-Z0-9\-\_] 
  "default"  -/- [a-zA-Z0-9\-\_]  
  "dynamic"  -/- [a-zA-Z0-9\-\_] 
  "else"     -/- [a-zA-Z0-9\-\_]
  "extend"   -/- [a-zA-Z0-9\-\_]
  "fail"     -/- [a-zA-Z0-9\-\_]
  "false"    -/- [a-zA-Z0-9\-\_]
  "for"      -/- [a-zA-Z0-9\-\_]
  "finally"  -/- [a-zA-Z0-9\-\_] 
  "global"   -/- [a-zA-Z0-9\-\_]
  "if"       -/- [a-zA-Z0-9\-\_]
  "import"   -/- [a-zA-Z0-9\-\_]
  "in"       -/- [a-zA-Z0-9\-\_]  
  "insert"   -/- [a-zA-Z0-9\-\_]  
  "int"      -/- [a-zA-Z0-9\-\_]
  "join"     -/- [a-zA-Z0-9\-\_]
  "list"     -/- [a-zA-Z0-9\-\_]
  "loc"      -/- [a-zA-Z0-9\-\_]
  "map"      -/- [a-zA-Z0-9\-\_]
  "module"   -/- [a-zA-Z0-9\-\_] 
  "node"     -/- [a-zA-Z0-9\-\_]
  "notin"    -/- [a-zA-Z0-9\-\_]  
  "on "      -/- [a-zA-Z0-9\-\_]  
  "one"      -/- [a-zA-Z0-9\-\_]  
  "private"  -/- [a-zA-Z0-9\-\_]  
  "public"   -/- [a-zA-Z0-9\-\_]
  "real"     -/- [a-zA-Z0-9\-\_]
  "rel"      -/- [a-zA-Z0-9\-\_]
  "repeat"   -/- [a-zA-Z0-9\-\_] 
  "return"   -/- [a-zA-Z0-9\-\_] 
  "rule"     -/- [a-zA-Z0-9\-\_]
  "set"      -/- [a-zA-Z0-9\-\_]
  "solve"    -/- [a-zA-Z0-9\-\_] 
  "str"      -/- [a-zA-Z0-9\-\_]
  "switch"   -/- [a-zA-Z0-9\-\_]  
  "tag"      -/- [a-zA-Z0-9\-\_] 
  "throw"    -/- [a-zA-Z0-9\-\_]
  "throws"   -/- [a-zA-Z0-9\-\_] 
  "true"     -/- [a-zA-Z0-9\-\_]
  "try"      -/- [a-zA-Z0-9\-\_]  
  "tuple"    -/- [a-zA-Z0-9\-\_]
  "type"     -/- [a-zA-Z0-9\-\_]  
  "value"    -/- [a-zA-Z0-9\-\_]
  "view"     -/- [a-zA-Z0-9\-\_]  
  "visit"    -/- [a-zA-Z0-9\-\_] 
  "void"     -/- [a-zA-Z0-9\-\_]
  "while"    -/- [a-zA-Z0-9\-\_]
  "adt"    -/- [a-zA-Z0-9\-\_]
  "constructor"  -/- [a-zA-Z0-9\-\_]
  "non-terminal" -/- [a-zA-Z0-9\-\_]
  "reified"  -/- [a-zA-Z0-9\-\_]
  "fun" -/- [a-zA-Z0-9\-\_]
module languages/rascal/syntax/Rascal

imports languages/rascal/syntax/Modules[Body]
imports languages/rascal/syntax/Declarations
imports languages/rascal/syntax/Commands
 


exports sorts Body
context-free syntax
	toplevels:Toplevel* -> Body {cons("Toplevels")}
module languages/rascal/syntax/Symbols

imports languages/rascal/syntax/Names
%% This is a modified clone of languages/sdf2/syntax/Regular, Character, Character-Class, and Sorts, and StrCon


exports
sorts StrCon StrChar

lexical syntax
  "\\n"                        -> StrChar {cons("newline")} 
  "\\t"                        -> StrChar                   
  "\\\""                       -> StrChar                   
  "\\\\"                       -> StrChar                   
  "\\" a:[0-9] b:[0-9] c:[0-9] -> StrChar                   
  ~[\0-\31\n\t\"\\]            -> StrChar                   
  [\"] chars:StrChar* [\"]     -> StrCon                    

sorts Symbol

sorts SingleQuotedStrCon SingleQuotedStrChar

lexical syntax
  "\\n"                                -> SingleQuotedStrChar  
  "\\t"                                -> SingleQuotedStrChar  
  "\\'"                                -> SingleQuotedStrChar  
  "\\\\"                               -> SingleQuotedStrChar  
  "\\" a:[0-9] b:[0-9] c:[0-9]         -> SingleQuotedStrChar  
  ~[\0-\31\n\t\'\\]                    -> SingleQuotedStrChar  
  [\'] chars:SingleQuotedStrChar* [\'] -> SingleQuotedStrCon   

context-free syntax
  "(" ")"                               -> Symbol {cons("Empty")}                  
  "(" head:Symbol tail:Symbol+ ")"      -> Symbol {cons("Sequence")}               
  symbol:Symbol "?"                     -> Symbol {cons("Optional")}               
  symbol:Symbol "+"                     -> Symbol {cons("Iter")}                   
  symbol:Symbol "*"                     -> Symbol {cons("IterStar")}               
  "{" symbol:Symbol sep:StrCon "}" "+"  -> Symbol {cons("IterSep")}                
  "{" symbol:Symbol sep:StrCon "}" "*"  -> Symbol {cons("IterStarSep")}            
  lhs:Symbol "|" rhs:Symbol             -> Symbol {right, cons("Alternative")}     
  charClass:CharClass                   -> Symbol {cons("CharacterClass")}         
  string:StrCon                         -> Symbol {cons("Literal")}                
  singelQuotedString:SingleQuotedStrCon -> Symbol {cons("CaseInsensitiveLiteral")}

context-free priorities
  {
    symbol:Symbol "?" -> Symbol {cons("Optional")}            
    symbol:Symbol "*" -> Symbol {cons("IterStar")}
    symbol:Symbol "+" -> Symbol {cons("Iter")}             
  } >
  lhs:Symbol "|" rhs:Symbol -> Symbol {right, cons("Alternative")}  

sorts Type

context-free priorities
   symbol:Symbol -> Type    {cons("Symbol")} >
   {
      name:Name                      -> Symbol  {cons("Sort")} 
      lhs:Symbol "|" rhs:Symbol -> Symbol {right, cons("Alternative")}
   } 


sorts CharClass CharRange CharRanges OptCharRanges

context-free syntax
  character:Character                      -> CharRange     {cons("Character")}                
  start:Character "-" end:Character        -> CharRange     {cons("Range")}                    
  range:CharRange                          -> CharRanges    {cons("Range")}                    
  lhs:CharRanges rhs:CharRanges            -> CharRanges    {cons("Concatenate"), right, memo} 
  "(" ranges:CharRanges ")"                -> CharRanges    {bracket, cons("Bracket")}                          
                                           -> OptCharRanges {cons("Absent")}                   
  ranges:CharRanges                        -> OptCharRanges {cons("Present")}                  
  "[" optionalCharRanges:OptCharRanges "]" -> CharClass     {cons("SimpleCharclass")}          
  "(" charClass:CharClass ")"                        -> CharClass     {bracket, cons("Bracket"), avoid}                   

context-free priorities
  "~" charClass:CharClass -> CharClass {cons("Complement")} >
  lhs:CharClass "/" rhs:CharClass -> CharClass {cons("Difference"), left, memo} >
  lhs:CharClass "/\\" rhs:CharClass -> CharClass {cons("Intersection"), left, memo} >
  lhs:CharClass "\\/" rhs:CharClass -> CharClass {cons("Union"), left}

exports
sorts Character NumChar ShortChar

lexical syntax
  [\\] number:[0-9]+                    -> NumChar    
  character:[a-zA-Z0-9]                 -> ShortChar  
  [\\] escape:~[\0-\31A-Za-mo-qsu-z0-9] -> ShortChar  

context-free syntax
  numChar:NumChar     -> Character {cons("Numeric")}    
  shortChar:ShortChar -> Character {cons("Short")}      
  "\\TOP"             -> Character {cons("Top")}        
  "\\EOF"             -> Character {cons("EOF")}        
  "\\BOT"             -> Character {cons("Bottom")}
module languages/rascal/syntax/Names

imports languages/rascal/syntax/Reserved

exports
  sorts Name QualifiedName EscapedName
  lexical syntax
    [A-Za-z\_] [A-Za-z0-9\_]*        -> Name
    [\\] [A-Za-z\_] [A-Za-z0-9\_\-]* -> EscapedName
    EscapedName                      -> Name

  lexical restrictions
    Name -/- [a-zA-Z0-9\_]
    EscapedName -/- [a-zA-Z0-9\_\-]
    Reserved -/- [a-zA-Z0-9\_\-]
 
  context-free syntax
    Reserved      -> Name {reject}
    names:{Name "::"}+  -> QualifiedName {cons("Default")}

  context-free restrictions
    ":" -/- [\:]
    QualifiedName -/- [\:].[\:]
module languages/rascal/syntax/Commands

imports languages/rascal/syntax/Declarations
imports languages/rascal/syntax/Statements
imports languages/rascal/syntax/Modules


exports

sorts Command
context-free syntax

":" command:ShellCommand   -> Command {cons("Shell")}
statement:Statement        -> Command {cons("Statement")}
expression:Expression      -> Command {prefer, cons("Expression")}
declaration:Declaration    -> Command {avoid, cons("Declaration")}
imported:Import            -> Command {cons("Import")}

context-free priorities 
  %% forbid direct nesting of closures as commands, since they don't compute anything and don't have an effect.
  expression:Expression -> Command {prefer, cons("Expression")} >
  {
    "{" statements:Statement+ "}"    -> Expression {cons("NonEmptyBlock")}
    eos:EOS                           -> Expression {cons("EOS")}
   }


sorts ShellCommand
context-free syntax

"help"                                -> ShellCommand {cons("Help")}
"quit"                                -> ShellCommand {cons("Quit")}
"edit" name:QualifiedName             -> ShellCommand {cons("Edit")}
"modules"                             -> ShellCommand {cons("ListModules")}
"declarations"                        -> ShellCommand {cons("ListDeclarations")} 
"test"                                -> ShellCommand {cons("Test")} 
"unimport" name:QualifiedName         -> ShellCommand {cons("Unimport")} 
"undeclare" name:QualifiedName        -> ShellCommand {cons("Undeclare")} 
"history"                             -> ShellCommand {cons("History")}
"set" name:QualifiedName expression:Expression -> ShellCommand {cons("SetOption")}
module languages/rascal/syntax/Constructors

imports 
	languages/rascal/syntax/Literals

exports
sorts Expression Literal Name QualifiedName

context-free syntax
  literal:Literal                                  -> Expression {cons("Literal")}  

context-free syntax
  qualifiedName:QualifiedName                      -> Expression {cons("QualifiedName")} 

context-free syntax
    basicType:BasicType "(" arguments:{Expression ","}* ")"        -> Expression {cons("ReifiedType")}
    expression:Expression "(" arguments:{Expression ","}* ")" -> Expression {cons("CallOrTree")} 

context-free syntax
  "[" elements:{Expression ","}* "]"               -> Expression {cons("List")}      
  "{" elements:{Expression ","}* "}"               -> Expression {cons("Set")}       
  "<" elements:{Expression ","}+ ">"               -> Expression {cons("Tuple")}     


sorts Mapping
context-free syntax
  from:Expression ":" to:Expression                 ->  Mapping[[Expression]] {cons("Default")}  
  "(" mappings:{Mapping[[Expression]] ","}* ")"     -> Expression {cons("Map")}




context-free restrictions
  "." -/- [\.]
  "," -/- [\.].[\.]
module languages/rascal/syntax/Tags

imports languages/rascal/syntax/Expressions

exports
sorts TagChar Tag Tags TagString

lexical syntax
   "{" TagChar* "}"                -> TagString      
  ~[\}]                            -> TagChar  
  [\\] [\\\}]                      -> TagChar  

context-free syntax
  "@" name:Name contents:TagString        -> Tag {cons("Default"), category("Comment")}
  "@" name:Name "=" expression:Expression -> Tag {cons("Expression"), category("Comment")}
  "@" name:Name                           -> Tag {cons("Empty"), category("Comment")}
  tags:Tag*                               -> Tags {cons("Default")}
module languages/rascal/syntax/RegExp

imports 
languages/rascal/syntax/Names

exports
sorts RegExp RegExpLiteral RegExpModifier NamedRegExp Backslash NamedBackslash

lexical syntax
   "/" RegExp* "/" RegExpModifier  -> RegExpLiteral
   [imsd]*                         -> RegExpModifier

   [\\]                            -> Backslash
   Backslash                       -> RegExp

   [\\][\/\<\>\\]                  -> RegExp
   ~[\/\<\>\\]                     -> RegExp
    
   ~[\/\<\>\\]                     -> NamedRegExp
   [\\][\<\>\\]                    -> NamedRegExp
   [\\]                            -> NamedBackslash
   NamedBackslash                  -> NamedRegExp
   "<" Name ">"                    -> NamedRegExp
   
   "<" Name ":" NamedRegExp* ">"   -> RegExp
   "<" Name ">"                    -> RegExp

lexical restrictions
    Backslash -/- [\/\<\>\\]
    NamedBackslash -/- [\<\>\\]
module languages/rascal/syntax/Patterns

imports 
	languages/rascal/syntax/Constructors[Expression => Pattern]
	languages/rascal/syntax/Types
	languages/rascal/syntax/Names

exports

context-free syntax

       type:Type name:Name                      -> Pattern {cons("TypedVariable")} 
       qualifiedName:QualifiedName "*"          -> Pattern {cons("MultiVariable")} 

context-free priorities
      expression:Pattern "(" arguments:{Pattern ","}* ")" -> Pattern {cons("CallOrTree")} >
{
       "/" pattern:Pattern                      -> Pattern {cons("Descendant")}
       name:Name ":" pattern:Pattern	        -> Pattern {cons("VariableBecomes")}
       type:Type name:Name ":" pattern:Pattern  -> Pattern {cons("TypedVariableBecomes")}
       "[" type:Type "]" pattern:Pattern        -> Pattern {cons("Guarded")}
       "!" pattern:Pattern                      -> Pattern {cons("Anti")}
}
module languages/rascal/syntax/Declarations

imports languages/rascal/syntax/Tags
        languages/rascal/syntax/Types
        languages/rascal/syntax/Statements

exports
sorts Toplevel Visibility Declaration Signature

context-free syntax
  "public"                                                                       -> Visibility {cons("Public")}            
  "private"                                                                      -> Visibility {cons("Private")} 
                                                                                 -> Visibility {cons("Default")}          

context-free syntax
  declaration:Declaration                                                        -> Toplevel   {cons("GivenVisibility")}   

sorts Alternative

context-free syntax
  tags:Tags visibility:Visibility "view" view:Name "<:" superType:Name "=" alts:{Alternative "|"}+ ";" -> Declaration {cons("View")}      
  name:Name type:Type                                                            -> Alternative {cons("NamedType")} 

context-free syntax
  tags:Tags visibility:Visibility "alias" user:UserType "=" base:Type ";"                              -> Declaration {cons("Alias")} 

sorts Variant

context-free syntax
  tags:Tags visibility:Visibility "data" user:UserType "=" variants:{Variant "|"}+ ";"                 -> Declaration {cons("Data")}                 
  name:Name "(" arguments:{TypeArg ","}* ")"                                     -> Variant     {cons("NAryConstructor")}      

sorts Test
context-free syntax
  test:Test ";" -> Declaration {cons("Test")}

  tags:Tags "test" expression:Expression                            -> Test {cons("Unlabeled")} 
  tags:Tags "test" expression:Expression ":" labeled:StringLiteral  -> Test {cons("Labeled")}  

sorts FunctionModifier FunctionModifiers

context-free syntax
  "java"                      -> FunctionModifier  {cons("Java")} 
  modifiers:FunctionModifier* -> FunctionModifiers {cons("List")} 

sorts FunctionDeclaration FunctionBody

context-free syntax
  type:Type modifiers:FunctionModifiers name:Name parameters:Parameters          -> Signature           {cons("NoThrows")}   
  type:Type modifiers:FunctionModifiers name:Name parameters:Parameters 
            "throws" exceptions:{Type ","}+                                      -> Signature           {cons("WithThrows")} 
  tags:Tags visibility:Visibility signature:Signature body:FunctionBody                                -> FunctionDeclaration {cons("Default")}    
  tags:Tags visibility:Visibility signature:Signature ";"                                              -> FunctionDeclaration {cons("Abstract")}   
  functionDeclaration:FunctionDeclaration                                        -> Declaration         {cons("Function")}   
  "{" statements:Statement* "}"                                                  -> FunctionBody        {cons("Default")}    

sorts Variable

context-free syntax
  name:Name                                                            -> Variable    {cons("UnInitialized")} 
  name:Name "=" initial:Expression                                     -> Variable    {cons("Initialized")}   
  tags:Tags visibility:Visibility type:Type variables:{Variable ","}+ ";"                                        -> Declaration {cons("Variable")}      

context-free syntax
  tags:Tags "rule" name:Name patternAction:PatternWithAction ";"                 -> Declaration {cons("Rule")} 

context-free syntax
  tags:Tags visibility:Visibility  "anno" annoType:Type onType:Type "@" name:Name ";"                   -> Declaration {cons("Annotation")} 
  tags:Tags visibility:Visibility  "tag"  kind:Kind name:Name "on" types:{Type ","}+ ";"                -> Declaration {cons("Tag")}        

sorts Kind

context-free syntax
  "module"   -> Kind {cons("Module")}   
  "function" -> Kind {cons("Function")} 
  "rule"     -> Kind {cons("Rule")}
  "variable" -> Kind {cons("Variable")} 
  "data"     -> Kind {cons("Data")}     
  "view"     -> Kind {cons("View")}     
  "alias"    -> Kind {cons("Alias")}     
  "anno"     -> Kind {cons("Anno")}     
  "tag"      -> Kind {cons("Tag")}      
  "all"      -> Kind {cons("All")}
module languages/rascal/syntax/Comments

exports

sorts Comment CommentChar Asterisk

lexical syntax
	"//" ~[\n]* [\n]       -> Comment {category("Comment")}
	"/*" CommentChar* "*/" -> Comment {category("Comment")}
	~[\*] -> CommentChar
	[\*] -> Asterisk
	Asterisk -> CommentChar
	Comment -> LAYOUT
	

lexical restrictions
	Asterisk -/- [\/]

context-free restrictions
	LAYOUT? -/- [\/].[\*]
	LAYOUT? -/- [\/].[\/]
module languages/rascal/syntax/Literals

imports languages/rascal/syntax/Lexical 
	languages/rascal/syntax/RegExp
exports
sorts Literal 

context-free syntax
  regExpLiteral:RegExpLiteral        -> Literal {cons("RegExp")}
  booleanLiteral:BooleanLiteral      -> Literal {cons("Boolean")}   
  integerLiteral:IntegerLiteral      -> Literal {cons("Integer")}    
  realLiteral:RealLiteral            -> Literal {cons("Real")} 
  stringLiteral:StringLiteral        -> Literal {cons("String")}
  locationLiteral:LocationLiteral    -> Literal {cons("Location")}
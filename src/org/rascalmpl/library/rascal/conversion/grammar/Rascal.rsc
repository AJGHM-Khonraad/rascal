syntax OctalLongLiteral = ... # [a-zA-Z0-9_] ;
syntax Reserved = "str" ;
syntax EscapeSequence = lex "\\" [0-7] [0-7] ;
syntax Reserved = "solve" ;
syntax Reserved = "dynamic" ;
syntax Pattern = TypedVariable: Type type Name name ;
syntax Expression = Literal: Literal literal ;
syntax Reserved = "reified" ;
syntax StrCon = lex [\"] StrChar* chars [\"] ;
syntax UserType = Parametric: Name name "[" {Type ","}+ parameters "]" ;
syntax Expression = Bracket: "(" Expression expression ")" ;
syntax HexLongLiteral = ... # [a-zA-Z0-9_] ;
syntax RegExp = lex ~[/\<\>\\] ;
syntax OptCharRanges = Absent: ;
syntax "set" = ... # [a-zA-Z0-9-_] ;
syntax EscapeSequence = lex "\\" [btnfr\"'\\\<\>] ;
syntax PatternWithAction = Replacing: Pattern pattern "=\>" Replacement replacement ;
syntax ShellCommand = Unimport: "unimport" QualifiedName name ;
syntax TypeVar = Free: "&" Name name ;
syntax Statement = Expression: Expression expression ";" 
	> EOS: EOS eos 
	| NonEmptyBlock: "{" Statement+ statements "}" ;
syntax IntegerLiteral = DecimalIntegerLiteral: DecimalIntegerLiteral decimal ;
syntax Kind = Tag: "tag" ;
syntax Statement = Expression: Expression expression ";" ;
syntax BasicType = Loc: "loc" ;
syntax Tag = Comment: Default: "@" Name name TagString contents ;
syntax LongLiteral = HexLongLiteral: HexLongLiteral hexLong ;
syntax "try" = ... # [a-zA-Z0-9-_] ;
syntax Comprehension = Set: "{" {Expression ","}+ results "|" {Expression ","}+ generators "}" ;
syntax "on" = ... # [a-zA-Z0-9-_] ;
syntax BasicType = Relation: "rel" ;
syntax RegExp = lex [\\] [/\<\>\\] ;
syntax SingleQuotedStrChar = lex "\\" [0-9] a [0-9] b [0-9] c ;
syntax Statement = Continue: "continue" ";" ;
syntax Backslash = lex [\\] ;
syntax Literal = String: StringLiteral stringLiteral ;
syntax Parameters = Default: "(" Formals formals ")" ;
syntax ModuleParameters = Default: "[" {TypeVar ","}+ parameters "]" ;
syntax BasicType = Bool: "bool" ;
syntax "global" = ... # [a-zA-Z0-9-_] ;
syntax Kind = Alias: "alias" ;
syntax Statement = TryFinally: "try" Statement body Catch+ handlers "finally" Statement finallyBody ;
syntax DecimalIntegerLiteral = lex [1-9] [0-9]* ;
syntax LocationLiteral = Default: ProtocolPart protocolPart PathPart pathPart ;
syntax BasicType = Value: "value" ;
syntax "fail" = ... # [a-zA-Z0-9-_] ;
syntax Kind = All: "all" ;
syntax Reserved = "node" ;
syntax Visit = GivenStrategy: Strategy strategy "visit" "(" Expression subject ")" "{" Case+ cases "}" ;
syntax Catch = Binding: "catch" Pattern pattern ":" Statement body ;
syntax Expression = All: "all" "(" {Expression ","}+ generators ")" ;
syntax "reified" = ... # [a-zA-Z0-9-_] ;
syntax BasicType = Map: "map" ;
syntax Reserved = "bag" ;
syntax QualifiedName = ... # [:] [:] ;
syntax NoElseMayFollow = Default: ;
syntax Statement = Insert: "insert" Expression expression ";" ;
syntax Statement = IfThenElse: Label label "if" "(" {Expression ","}+ conditions ")" Statement thenStatement "else" Statement elseStatement ;
syntax NamedBackslash = lex [\\] ;
syntax Field = Index: IntegerLiteral fieldIndex ;
syntax "throw" = ... # [a-zA-Z0-9-_] ;
syntax PathTail = Post: PostPathChars post ;
syntax IntegerLiteral = HexIntegerLiteral: HexIntegerLiteral hex ;
syntax TypeArg = Default: Type type ;
syntax Variable = Initialized: Name name "=" Expression initial ;
syntax Catch = Default: "catch" ":" Statement body ;
syntax RealLiteral = lex "." [0-9]+ (  [eE]  [+-]?  [0-9]+  )? [dD]? ;
syntax Signature = WithThrows: Type type FunctionModifiers modifiers Name name Parameters parameters "throws" {Type ","}+ exceptions ;
syntax Expression = Any: "any" "(" {Expression ","}+ generators ")" ;
syntax Reserved = "one" ;
syntax CharClass = SimpleCharclass: "[" OptCharRanges optionalCharRanges "]" ;
syntax Type = User: UserType user ;
syntax Name = ... # [a-zA-Z0-9_] ;
syntax Break = NoLabel: "break" ";" ;
syntax Tag = Comment: Empty: "@" Name name ;
syntax Declaration = Tag: Tags tags Visibility visibility "tag" Kind kind Name name "on" {Type ","}+ types ";" ;
syntax Reserved = "set" ;
syntax Tags = Default: Tag* tags ;
syntax Statement = EmptyStatement: ";" ;
syntax StringCharacter = lex ~[\"\\\<\>] ;
syntax "str" = ... # [a-zA-Z0-9-_] ;
syntax RegExpModifier = lex [imsd]* ;
syntax "join" = ... # [a-zA-Z0-9-_] ;
syntax RealLiteral = ... # [a-zA-Z0-9_] ;
syntax "join" = ... # [a-zA-Z-_0-9] ;
syntax Command = Declaration: Declaration declaration ;
syntax BooleanLiteral = lex "true" ;
syntax Reserved = "module" ;
syntax "finally" = ... # [a-zA-Z0-9-_] ;
syntax "catch" = ... # [a-zA-Z0-9-_] ;
syntax LongLiteral = DecimalLongLiteral: DecimalLongLiteral decimalLong ;
syntax Fail = WithLabel: "fail" Name label ";" ;
syntax Reserved = "public" ;
syntax BasicType = Node: "node" ;
syntax Expression = EOS: EOS eos ;
syntax "tuple" = ... # [a-zA-Z0-9-_] ;
syntax Kind = Variable: "variable" ;
syntax Reserved = "alias" ;
syntax Kind = Data: "data" ;
syntax Symbol = Iter: Symbol symbol "+" ;
syntax "throws" = ... # [a-zA-Z0-9-_] ;
syntax HexLongLiteral = lex [0] [xX] [0-9a-fA-F]+ [lL] ;
syntax StrChar = lex "\\\\" ;
syntax "value" = ... # [a-zA-Z0-9-_] ;
syntax "public" = ... # [a-zA-Z0-9-_] ;
syntax Expression = Expression "+" Expression 
	| Expression "*" Expression 
	> "-" Expression ;
syntax Statement = Solve: "solve" "(" {QualifiedName ","}+ variables Bound bound ")" Statement body ;
syntax ShellCommand = Edit: "edit" QualifiedName name ;
syntax StrChar = lex "\\t" ;
syntax Type = Basic: BasicType basic ;
syntax Reserved = "default" ;
syntax Pattern = CallOrTree: Pattern expression "(" {Pattern ","}* arguments ")" 
	> Anti: "!" Pattern pattern 
	| Guarded: "[" Type type "]" Pattern pattern 
	| Descendant: "/" Pattern pattern 
	| VariableBecomes: Name name ":" Pattern pattern 
	| TypedVariableBecomes: Type type Name name ":" Pattern pattern ;
syntax Kind = Function: "function" ;
syntax ProtocolTail = Post: PostProtocolChars post ;
syntax Statement = Throw: "throw" Expression expression ";" ;
syntax FunctionModifier = Java: "java" ;
syntax "://" = ... # [ \t\n\r] ;
syntax Label = Default: Name name ":" ;
syntax Reserved = "throws" ;
syntax PathTail = Mid: MidPathChars mid Expression expression PathTail tail ;
syntax RegExp = lex "" Name "" ;
syntax BasicType = ReifiedAdt: "adt" ;
syntax EOS = DoWhile: Label label "do" Statement body "while" "(" Expression condition ")" ";" ;
syntax "false" = ... # [a-zA-Z0-9-_] ;
syntax SingleQuotedStrCon = lex ['] SingleQuotedStrChar* chars ['] ;
syntax "one" = ... # [a-zA-Z0-9-_] ;
syntax Strategy = TopDown: "top-down" ;
syntax "fun" = ... # [a-zA-Z0-9-_] ;
syntax Type = Symbol: Symbol symbol 
	> Alternative: Symbol lhs "|" Symbol rhs 
	| Sort: Name name ;
syntax BasicType = Int: "int" ;
syntax Return = WithExpression: "return" Expression expression ";" ;
syntax Declaration = Alias: Tags tags Visibility visibility "alias" UserType user "=" Type base ";" ;
syntax Reserved = "adt" ;
syntax DataTypeSelector = Selector: Name sort "." Name production ;
syntax StringLiteral = lex "\"" StringCharacter* "\"" ;
syntax Reserved = "catch" ;
syntax "void" = ... # [a-zA-Z0-9-_] ;
syntax ShortChar = lex [\\] ~[\000-\031A-Za-mo-qsu-z0-9\000-\0031A-Za-mo-qsu-z0-9] escape ;
syntax ShellCommand = ListModules: "modules" ;
syntax BasicType = Void: "void" ;
syntax Fail = NoLabel: "fail" ";" ;
syntax Test = Unlabeled: Tags tags "test" Expression expression ;
syntax Character = Numeric: NumChar numChar ;
syntax "list" = ... # [a-zA-Z0-9-_] ;
syntax Expression = ReifyType: "#" Type type ;
syntax Reserved = "insert" ;
syntax Import = Extend: "extend" ImportedModule module ";" ;
syntax HexIntegerLiteral = lex [0] [xX] [0-9a-fA-F]+ ;
syntax Reserved = "view" ;
syntax IntegerLiteral = OctalIntegerLiteral: OctalIntegerLiteral octal ;
syntax Strategy = BottomUpBreak: "bottom-up-break" ;
syntax Label = Empty: ;
layout LAYOUT = lex Comment ;
syntax Reserved = "anno" ;
syntax Expression = IfThenElse: Expression condition "?" Expression thenExp ":" Expression elseExp 
	> Default: Expression from ":" Expression to 
	| IfDefinedOtherwise: Expression lhs "?" Expression rhs 
	> Enumerator: Pattern pattern "\<-" Expression expression 
	> Equals: Expression lhs "==" Expression rhs ;
syntax Assignment = Default: "=" ;
syntax ShellCommand = History: "history" ;
syntax StringCharacter = lex MetaVariable: [\<] LAYOUT? Expression LAYOUT? [\>] ;
syntax Replacement = Unconditional: Expression replacementExpression ;
syntax Import = Default: "import" ImportedModule module ";" ;
syntax Comprehension = Map: "(" Expression from ":" Expression to "|" {Expression ","}+ generators ")" ;
syntax CharRanges = memo Concatenate: CharRanges lhs CharRanges rhs ;
syntax EOS = For: Label label "for" "(" {Expression ","}+ generators ")" Statement body ;
syntax Statement = AssertWithMessage: "assert" Expression expression ":" StringLiteral message ";" ;
syntax OctalIntegerLiteral = lex [0] [0-7]+ ;
syntax Statement = Try: "try" Statement body Catch+ handlers ;
syntax Reserved = "list" ;
syntax "bool" = ... # [a-zA-Z0-9-_] ;
syntax HexIntegerLiteral = ... # [a-zA-Z0-9_] ;
syntax ProtocolChars = lex [|] URLChars "://" ;
syntax Marker = lex ;
syntax Bound = Empty: ;
syntax CharRange = Range: Character start "-" Character end ;
syntax StrChar = lex "\\\"" ;
syntax "dynamic" = ... # [a-zA-Z0-9-_] ;
syntax EOS = Visit: Visit visit ;
syntax FunctionType = TypeArguments: Type type "(" {TypeArg ","}* arguments ")" ;
syntax Assignable = Variable: QualifiedName qualifiedName ;
syntax LocationLiteral = File: PathPart pathPart ;
syntax "," = ... # [.] [.] ;
syntax Reserved = "rel" ;
syntax PrePathChars = lex URLChars "" ;
syntax SingleCharacter = lex UnicodeEscape ;
syntax DecimalIntegerLiteral = ... # [a-zA-Z0-9_] ;
syntax "visit" = ... # [a-zA-Z0-9-_] ;
syntax Symbol = CaseInsensitiveLiteral: SingleQuotedStrCon singelQuotedString ;
syntax Body = Toplevels: Toplevel* toplevels ;
syntax Asterisk = ... # [/] ;
syntax Kind = Anno: "anno" ;
syntax DecimalLongLiteral = ... # [a-zA-Z0-9_] ;
syntax StrChar = lex "\\" [0-9] a [0-9] b [0-9] c ;
syntax StructuredType = Default: BasicType basicType "[" {TypeArg ","}+ arguments "]" ;
syntax Renaming = Default: Name from "=\>" Name to ;
syntax BasicType = List: "list" ;
syntax BasicType = ReifiedConstructor: "constructor" ;
syntax Expression = List: "[" {Expression ","}* elements "]" ;
syntax Visibility = Private: "private" ;
syntax EscapeSequence = lex "\\" [0-7] ;
syntax Assignment = IfDefined: "?=" ;
syntax Statement = IfThen: Label label "if" "(" {Expression ","}+ conditions ")" Statement thenStatement NoElseMayFollow noElseMayFollow ;
syntax URLChars = lex ~[ \t\n\r|\<]* ;
syntax LocalVariableDeclaration = Default: Declarator declarator ;
syntax Variant = NAryConstructor: Name name "(" {TypeArg ","}* arguments ")" ;
syntax Break = WithLabel: "break" Name label ";" ;
syntax "else" = ... # [a-zA-Z0-9-_] ;
syntax "int" = ... # [a-zA-Z0-9-_] ;
syntax BasicType = ReifiedFunction: "fun" ;
syntax LAYOUT? = ... # [/] [/] ;
syntax LAYOUT? = ... # [/] [*] ;
syntax "real" = ... # [a-zA-Z0-9-_] ;
syntax "rel" = ... # [a-zA-Z0-9-_] ;
syntax Type = Variable: TypeVar typeVar ;
syntax Reserved = "rule" ;
syntax "module" = ... # [a-zA-Z0-9-_] ;
syntax OctalIntegerLiteral = ... # [a-zA-Z0-9_] ;
syntax "constructor" = ... # [a-zA-Z0-9-_] ;
syntax Reserved = "throw" ;
syntax "notin" = ... # [a-zA-Z-_0-9] ;
syntax Case = PatternWithAction: "case" PatternWithAction patternWithAction ;
syntax "notin" = ... # [a-zA-Z0-9-_] ;
syntax NumChar = lex [\\] [0-9]+ number ;
syntax Strategy = TopDownBreak: "top-down-break" ;
syntax "type" = ... # [a-zA-Z0-9-_] ;
syntax Rest = lex ;
syntax Type = Selector: DataTypeSelector selector ;
syntax "in" = ... # [a-zA-Z-_0-9] ;
syntax "in" = ... # [a-zA-Z0-9-_] ;
syntax Expression = Tuple: "" {Expression ","}+ elements "" ;
syntax Reserved = "bool" ;
syntax Declarator = Default: Type type {Variable ","}+ variables ;
syntax Symbol = IterStar: Symbol symbol "*" ;
syntax CharClass = Bracket: "(" CharClass charClass ")" ;
syntax "if" = ... # [a-zA-Z0-9-_] ;
syntax Comment = lex Comment: "/*" CommentChar* "*/" ;
syntax "adt" = ... # [a-zA-Z0-9-_] ;
syntax "non-terminal" = ... # [a-zA-Z0-9-_] ;
syntax FunctionDeclaration = Default: Tags tags Visibility visibility Signature signature FunctionBody body ;
syntax Statement = FunctionDeclaration: FunctionDeclaration functionDeclaration ;
syntax Statement = Switch: Label label "switch" "(" Expression expression ")" "{" Case+ cases "}" ;
syntax SingleQuotedStrChar = lex "\\t" ;
syntax "view" = ... # [a-zA-Z0-9-_] ;
syntax Type = Bracket: "(" Type type ")" ;
syntax Symbol = Literal: StrCon string ;
syntax "node" = ... # [a-zA-Z0-9-_] ;
syntax "solve" = ... # [a-zA-Z0-9-_] ;
syntax Kind = Rule: "rule" ;
syntax CharClass = Complement: "~" CharClass charClass 
	> memo Difference: CharClass lhs "/" CharClass rhs 
	> memo Intersection: CharClass lhs "/\\" CharClass rhs 
	> Union: CharClass lhs "\\/" CharClass rhs ;
syntax StrChar = lex ~[\000-\0031\n\t\"\\\000-\031\n\t\"\\] ;
syntax SingleQuotedStrChar = lex "\\n" ;
syntax Expression = NonEmptyBlock: "{" Statement+ statements "}" ;
syntax Module = Default: Header header Body body ;
syntax CommentChar = lex Asterisk ;
syntax Statement = Break: Break brk ;
syntax Mapping[[Expression]] = Default: Expression from ":" Expression to ;
syntax "==" = ... # [\>] ;
syntax PathPart = NonInterpolated: PathChars pathChars ;
syntax Command = Statement: Statement statement ;
syntax Declaration = Function: FunctionDeclaration functionDeclaration ;
syntax BooleanLiteral = lex "false" ;
syntax "while" = ... # [a-zA-Z0-9-_] ;
syntax SingleQuotedStrChar = lex "\\\\" ;
syntax Renamings = Default: "renaming" {Renaming ","}+ renamings ;
syntax Reserved = "for" ;
syntax Backslash = ... # [/\<\>\\] ;
syntax OptCharRanges = Present: CharRanges ranges ;
syntax Reserved = "switch" ;
syntax CharRanges = Range: CharRange range ;
syntax Body = Anything: Marker marker Rest rest ;
syntax Reserved = "return" ;
syntax BasicType = Real: "real" ;
syntax Reserved = "case" ;
syntax Reserved = "while" ;
syntax ProtocolTail = Mid: MidProtocolChars mid Expression expression ProtocolTail tail ;
syntax UnicodeEscape = lex "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] ;
syntax MidProtocolChars = lex "" URLChars "" ;
syntax SingleQuotedStrChar = lex "\\'\\" ;
syntax Reserved = "type" ;
syntax Reserved = "notin" ;
syntax BasicType = ReifiedNonTerminal: "non-terminal" ;
syntax Reserved = "else" ;
syntax Statement = Assignment: Assignable assignable Assignment operator Expression expression ";" ;
syntax Variable = UnInitialized: Name name ;
syntax ProtocolPart = Interpolated: PreProtocolChars pre Expression expression ProtocolTail tail ;
syntax Reserved = "in" ;
syntax ShellCommand = SetOption: "set" QualifiedName name Expression expression ;
syntax Reserved = "false" ;
syntax ImportedModule = Default: QualifiedName name ;
syntax "|" = ... # [|] ;
syntax "switch" = ... # [a-zA-Z0-9-_] ;
syntax BasicType = Set: "set" ;
syntax Comment = lex Comment: "//" ~[\n]* [\n] ;
syntax Character = Bottom: "\\BOT" ;
syntax Expression = QualifiedName: QualifiedName qualifiedName ;
syntax Reserved = "join" ;
syntax ImportedModule = Actuals: QualifiedName name ModuleActuals actuals ;
syntax Literal = Location: LocationLiteral locationLiteral ;
syntax ModuleActuals = Default: "[" {Type ","}+ types "]" ;
syntax ShellCommand = Undeclare: "undeclare" QualifiedName name ;
syntax PathPart = Interpolated: PrePathChars pre Expression expression PathTail tail ;
syntax DecimalLongLiteral = lex "0" [lL] ;
syntax StrChar = lex newline: "\\n" ;
syntax Asterisk = lex [*] ;
syntax DecimalLongLiteral = lex [1-9] [0-9]* [lL] ;
syntax Reserved = "fail" ;
syntax ImportedModule = ActualsRenaming: QualifiedName name ModuleActuals actuals Renamings renamings ;
syntax Reserved = "if" ;
syntax Reserved = "extend" ;
syntax DecimalIntegerLiteral = lex "0" ;
syntax RealLiteral = lex [0-9]+ (  [eE]  [+-]?  [0-9]+  )? [dD] ;
syntax Strategy = Innermost: "innermost" ;
syntax "anno" = ... # [a-zA-Z0-9-_] ;
syntax Signature = NoThrows: Type type FunctionModifiers modifiers Name name Parameters parameters ;
syntax SingleQuotedStrChar = lex ~[\000-\0031\n\t'\\\000-\031\n\t'\\] ;
syntax Formal = TypeName: Type type Name name ;
syntax Expression = CallOrTree: Expression expression "(" {Expression ","}* arguments ")" ;
syntax Character = EOF: "\\EOF" ;
syntax CommentChar = lex ~[*] ;
syntax Expression = Closure: Type type Parameters parameters "{" Statement+ statements "}" ;
syntax Reserved = ... # [a-zA-Z0-9_-] ;
syntax Command = Expression: Expression expression ;
syntax Assignment = Intersection: "&=" ;
syntax Return = NoExpression: "return" ";" ;
syntax "insert" = ... # [a-zA-Z0-9-_] ;
syntax "private" = ... # [a-zA-Z0-9-_] ;
syntax "for" = ... # [a-zA-Z0-9-_] ;
syntax "\<=" = ... # [=] [\>] ;
syntax TagString = lex "{" TagChar* "}" ;
syntax "+" = ... # [=] ;
syntax BasicType = ReifiedType: "type" ;
syntax "*" = ... # [=] ;
syntax Pattern = MultiVariable: QualifiedName qualifiedName "*" ;
syntax Declaration = Test: Test test ";" ;
syntax "data" = ... # [a-zA-Z0-9-_] ;
syntax Symbol = Sequence: "(" Symbol head Symbol+ tail ")" ;
syntax "/" = ... # [=] ;
syntax Expression = Set: "{" {Expression ","}* elements "}" ;
syntax "." = ... # [.] ;
syntax BasicType = Tuple: "tuple" ;
syntax "-" = ... # [=] ;
syntax Reserved = "value" ;
syntax Literal = Boolean: BooleanLiteral booleanLiteral ;
syntax Reserved = "fun" ;
syntax "assert" = ... # [a-zA-Z0-9-_] ;
syntax Reserved = "non-terminal" ;
syntax "!" = ... # [~] ;
syntax "!" = ... # [=] ;
syntax Assignment = Addition: "+=" ;
syntax "!" = ... # [:] ;
syntax "return" = ... # [a-zA-Z0-9-_] ;
syntax PostPathChars = lex "" URLChars "|" ;
syntax "&" = ... # [&] ;
syntax "&" = ... # [=] ;
syntax Name = Reserved ;
syntax ":" = ... # [:] ;
syntax ":" = ... # [=] ;
syntax UserType = Name: Name name ;
syntax Statement = Return: Return ret ;
syntax EscapedName = lex [\\] [A-Za-z_] [A-Za-z0-9_-]* ;
syntax MidPathChars = lex "" URLChars "" ;
syntax PathChars = lex URLChars [|] ;
syntax Field = Name: Name fieldName ;
syntax "?" = ... # [=] ;
syntax "=" = ... # [=] ;
syntax "=" = ... # [\>] ;
syntax LAYOUT? = ... # [ \t\n\r] ;
syntax Comprehension = List: "[" {Expression ","}+ results "|" {Expression ","}+ generators "]" ;
syntax Kind = View: "view" ;
syntax RegExp = lex MetaVariable: [\<] LAYOUT? Expression LAYOUT? [\>] ;
syntax TypeVar = Bounded: "&" Name name "\<:" Type bound ;
layout LAYOUT = lex whitespace: [ \t\n\r] ;
syntax Statement = EOS: EOS eos ;
syntax Visit = DefaultStrategy: "visit" "(" Expression subject ")" "{" Case+ cases "}" ;
syntax Name = lex [A-Za-z_] [A-Za-z0-9_]* ;
syntax Symbol = IterSep: "{" Symbol symbol StrCon sep "}" "+" ;
syntax EscapedName = ... # [a-zA-Z0-9_-] ;
syntax "repeat" = ... # [a-zA-Z0-9-_] ;
syntax Symbol = Empty: "(" ")" ;
syntax Strategy = BottomUp: "bottom-up" ;
syntax BasicType = Bag: "bag" ;
syntax EscapeSequence = lex "\\" [0-3] [0-7] [0-7] ;
syntax CharRange = Character: Character character ;
syntax Statement = Fail: Fail fail ;
syntax "default" = ... # [a-zA-Z0-9-_] ;
syntax EOS = While: Label label "while" "(" Expression condition ")" Statement body ;
syntax Reserved = "map" ;
syntax "" = ... # [=] ;
syntax "" = ... # [-] ;
syntax ShellCommand = Test: "test" ;
syntax Toplevel = GivenVisibility: Declaration declaration ;
syntax RegExp = lex Backslash ;
syntax Expression = Range: "[" Expression first ".." Expression last "]" ;
syntax Reserved = "assert" ;
syntax RealLiteral = lex [0-9]+ "." [0-9]* (  [eE]  [+-]?  [0-9]+  )? [dD]? ;
syntax Header = Parameters: Tags tags "module" QualifiedName name ModuleParameters params Import* imports ;
syntax Type = Function: FunctionType function ;
syntax Assignment = Product: "*=" ;
syntax Reserved = "loc" ;
syntax Symbol = Iter: Symbol symbol "+" 
	| Optional: Symbol symbol "?" 
	| IterStar: Symbol symbol "*" 
	> Alternative: Symbol lhs "|" Symbol rhs ;
syntax "extend" = ... # [a-zA-Z0-9-_] ;
syntax Character = Top: "\\TOP" ;
syntax "case" = ... # [a-zA-Z0-9-_] ;
syntax Reserved = "visit" ;
syntax BasicType = Lex: "lex" ;
syntax Expression = Map: "(" {Mapping[[Expression]] ","}* mappings ")" ;
syntax Declaration = Annotation: Tags tags Visibility visibility "anno" Type annoType Type onType "@" Name name ";" ;
syntax LocalVariableDeclaration = Dynamic: "dynamic" Declarator declarator ;
syntax Statement = Assert: "assert" Expression expression ";" ;
syntax CharRanges = Bracket: "(" CharRanges ranges ")" ;
syntax TypeArg = Named: Type type Name name ;
syntax BasicType = String: "str" ;
syntax Header = Default: Tags tags "module" QualifiedName name Import* imports ;
syntax Alternative = NamedType: Name name Type type ;
syntax SingleCharacter = lex ~['\\] ;
syntax BasicType = ReifiedReifiedType: "reified" ;
syntax Reserved = "try" ;
syntax CharacterLiteral = lex "'\\" EscapeSequence "'\\" ;
syntax ShortChar = lex [a-zA-Z0-9] character ;
syntax NamedRegExp = lex ~[/\<\>\\] ;
syntax Reserved = "import" ;
syntax Reserved = "global" ;
syntax PatternWithAction = Arbitrary: Pattern pattern ":" Statement statement ;
syntax Reserved = "all" ;
syntax TagChar = lex [\\] [\\}] ;
syntax Parameters = VarArgs: "(" Formals formals "..." ")" ;
syntax Strategy = Outermost: "outermost" ;
syntax Reserved = "data" ;
syntax Kind = Module: "module" ;
syntax Visibility = Public: "public" ;
syntax Marker = ... # [[] ;
syntax QualifiedName = Default: {Name "::"}+ names ;
syntax ~[\n]* = ... # ~[\n] ;
syntax LongLiteral = OctalLongLiteral: OctalLongLiteral octalLong ;
syntax Expression = StepRange: "[" Expression first "," Expression second ".." Expression last "]" ;
syntax Reserved = "void" ;
syntax Literal = RegExp: RegExpLiteral regExpLiteral ;
syntax {~[\n]* [\n]}* = ... # [\n] ;
syntax Expression = ReifiedType: BasicType basicType "(" {Expression ","}* arguments ")" ;
syntax Tag = Comment: Expression: "@" Name name "=" Expression expression ;
syntax Reserved = "real" ;
syntax Declaration = Variable: Tags tags Visibility visibility Type type {Variable ","}+ variables ";" ;
syntax Bound = Default: ";" Expression expression ;
syntax Test = Labeled: Tags tags "test" Expression expression ":" StringLiteral labeled ;
syntax FunctionDeclaration = Abstract: Tags tags Visibility visibility Signature signature ";" ;
syntax Name = lex EscapedName ;
syntax Reserved = "tag" ;
syntax Reserved = "repeat" ;
syntax "import" = ... # [a-zA-Z0-9-_] ;
syntax Expression = VoidClosure: Parameters parameters "{" Statement+ statements "}" ;
syntax Statement = VariableDeclaration: LocalVariableDeclaration declaration ";" ;
syntax Rest = lex {~[\n]* [\n]}* ;
syntax Assignment = Division: "/=" ;
syntax RealLiteral = lex [0-9]+ [eE] [+-]? [0-9]+ [dD]? ;
syntax Reserved = "private" ;
syntax Reserved = "finally" ;
syntax "any" = ... # [a-zA-Z0-9-_] ;
syntax "true" = ... # [a-zA-Z0-9-_] ;
syntax Literal = Real: RealLiteral realLiteral ;
syntax Reserved = "true" ;
syntax ShellCommand = Help: "help" ;
syntax Command = Shell: ":" ShellCommand command ;
syntax ShellCommand = ListDeclarations: "declarations" ;
syntax OctalLongLiteral = lex [0] [0-7]+ [lL] ;
syntax Expression = Comprehension: Comprehension comprehension ;
syntax RegExp = lex "" Name ":" NamedRegExp* "" ;
syntax CharacterLiteral = lex "'\\" SingleCharacter "'\\" ;
syntax Reserved = "constructor" ;
syntax Symbol = Alternative: Symbol lhs "|" Symbol rhs ;
syntax "loc" = ... # [a-zA-Z0-9-_] ;
syntax FunctionModifiers = List: FunctionModifier* modifiers ;
syntax FunctionBody = Default: "{" Statement* statements "}" ;
syntax Assignment = Subtraction: "-=" ;
syntax Character = Short: ShortChar shortChar ;
syntax TagChar = lex ~[}] ;
syntax NamedBackslash = ... # [\<\>\\] ;
syntax Statement = GlobalDirective: "global" Type type {QualifiedName ","}+ names ";" ;
syntax Reserved = "int" ;
syntax Reserved = "any" ;
syntax Expression = CallOrTree: Expression expression "(" {Expression ","}* arguments ")" 
	| FieldAccess: Expression expression "." Name field 
	| FieldUpdate: Expression expression "[" Name key "=" Expression replacement "]" 
	| ReifiedType: BasicType basicType "(" {Expression ","}* arguments ")" 
	| Subscript: Expression expression "[" {Expression ","}+ subscripts "]" 
	| FieldProject: Expression expression "" {Field ","}+ fields "" 
	> IsDefined: Expression argument "?" 
	> Negation: "!" Expression argument 
	| Negative: "-" Expression argument 
	> TransitiveClosure: Expression argument "+" 
	| TransitiveReflexiveClosure: Expression argument "*" 
	> GetAnnotation: Expression expression "@" Name name 
	| SetAnnotation: Expression expression "[" "@" Name name "=" Expression value "]" 
	> Composition: Expression lhs "o" Expression rhs 
	> Intersection: Expression lhs "&" Expression rhs 
	> IfDefinedOtherwise: Expression lhs "?" Expression rhs 
	> And: Expression lhs "&&" Expression rhs 
	> Or: Expression lhs "||" Expression rhs ;
syntax Command = Expression: Expression expression 
	> EOS: EOS eos 
	| NonEmptyBlock: "{" Statement+ statements "}" ;
syntax Formals = Default: {Formal ","}* formals ;
syntax Replacement = Conditional: Expression replacementExpression "when" {Expression ","}+ conditions ;
syntax "rule" = ... # [a-zA-Z0-9-_] ;
syntax PostProtocolChars = lex "" URLChars "://" ;
syntax StringCharacter = lex UnicodeEscape ;
syntax Case = Default: "default" ":" Statement statement ;
syntax "map" = ... # [a-zA-Z0-9-_] ;
syntax Symbol = Optional: Symbol symbol "?" ;
syntax NoElseMayFollow = ... # [e] [l] [s] [e] ;
syntax ProtocolPart = NonInterpolated: ProtocolChars protocolChars ;
syntax RegExpLiteral = lex "/" RegExp* "/" RegExpModifier ;
syntax NamedRegExp = lex NamedBackslash ;
syntax Type = Structured: StructuredType structured ;
syntax Literal = Integer: IntegerLiteral integerLiteral ;
syntax Visibility = Default: ;
syntax Marker = ... # [i] [m] [p] [o] [r] [t] ;
syntax Reserved = "on" ;
syntax Assignable = FieldAccess: Assignable receiver "." Name field 
	| Subscript: Assignable receiver "[" Expression subscript "]" 
	| IfDefinedOrDefault: Assignable receiver "?" Expression defaultExpression ;
syntax Symbol = IterStarSep: "{" Symbol symbol StrCon sep "}" "*" ;
syntax Command = Import: Import imported ;
syntax Declaration = Rule: Tags tags "rule" Name name PatternWithAction patternAction ";" ;
syntax Declaration = Data: Tags tags Visibility visibility "data" UserType user "=" {Variant "|"}+ variants ";" ;
syntax "tag" = ... # [a-zA-Z0-9-_] ;
syntax Statement = Block: Label label "{" Statement+ statements "}" ;
syntax "o" = ... # [a-zA-Z-_0-9] ;
syntax "all" = ... # [a-zA-Z0-9-_] ;
syntax ShellCommand = Quit: "quit" ;
syntax StringCharacter = lex EscapeSequence ;
syntax Declaration = View: Tags tags Visibility visibility "view" Name view "\<:" Name superType "=" {Alternative "|"}+ alts ";" ;
syntax PreProtocolChars = lex "|" URLChars "" ;
syntax ImportedModule = Renamings: QualifiedName name Renamings renamings ;
syntax Symbol = CharacterClass: CharClass charClass ;
syntax NamedRegExp = lex "" Name "" ;
syntax Reserved = "tuple" ;
syntax NamedRegExp = lex [\\] [\<\>\\] ;

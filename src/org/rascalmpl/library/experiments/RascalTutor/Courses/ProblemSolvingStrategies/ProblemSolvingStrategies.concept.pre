concept("ProblemSolvingStrategies",|std:///experiments/RascalTutor/Courses/ProblemSolvingStrategies/ProblemSolvingStrategies.concept|,[],["Synthesis","Analysis","Extraction"],{"All"},{"Analysis","Extraction","Synthesis"},"","","","",{}," Before you study more complicated examples, it is useful to discuss some general problem solving \n strategies that are relevant in Rascal\'\\s application domain.\n \<br/\>\n\<br/\>\n\n To appreciate these general strategies, it is good to keep some specific problem areas in mind:\n  \<ul\>\<li\> \<b\>Documentation generation\</b\>: extract facts from source code and use them to generate textual documentation.   A typical example is generating web-based documentation for legacy languages like Cobol and PL/I.\n    \<img class=\"TutorImg\" width=\"200px\" style=\"float: right;\"  title=\"Problem Solving Workflow\" alt=\"Problem Solving Workflow\" src=\"Courses/ProblemSolvingStrategies/problem-solving.png\"\>\n\</li\>\n\<li\> \<b\>Metrics calculation\</b\>: extract facts from source code (and possibly other sources like test runs) and use    them to calculate code metrics. Examples are cohesion and coupling of modules and test coverage.\n\</li\>\n\<li\> \<b\>Model extraction\</b\>: extract facts from source code and use them to build an abstract model of the source code.    An example is extracting lock and unlock calls from source code and to build an automaton that guarantees \n   that lock/unlock occurs in pairs along every control flow path.\n\</li\>\n\<li\> \<b\>Model-based code generation\</b\>: given a high-level model of a software system, described in UML or some other modelling language, transform this model into executable code. UML-to-Java code generation falls in this category.\</li\>\n\<li\> \<b\>Source-to-source transformation\</b\>: large-scale, fully automated, source code transformation with certain objectives like removing deprecated language features, upgrading to newer APIs and the like.\</li\>\n\<li\> \<b\>Interactive refactoring\</b\>: given known \<i\>code smells\</i\> a user can interactively indicate how these smells should be removed. The refactoring features in Eclipse and Visual Studio are examples.\</li\>\n\</ul\> With these examples in mind, we can study the overall problem solving workflow as shown \n in the figure \<i\>Problem Solving Workflow\</i\> above.\n It consists of three optional phases:\n  \<ul\>\<li\> Is extraction needed to solve the problem, then define the extraction phase, see \<a href=\"/show?concept=Extraction\"\>Extraction\</a\>.\</li\>\n\<li\> Is analysis needed, then define the analysis phase, see \<a href=\"/show?concept=Analysis\"\>Analysis\</a\>. \<img class=\"TutorImg\" width=\"250px\" style=\"float: right;\" hspace=\"2px\" vspace=\"2px\"  title=\"Validation Workflow\" alt=\"Validation Workflow\" src=\"Courses/ProblemSolvingStrategies/validation.png\"\>\</li\>\n\<li\> Is synthesis needed, then define the synthesis phase, see \<a href=\"/show?concept=Synthesis\"\>Synthesis\</a\>.\</li\>\n\</ul\> Each phase is subject to a validation and improvement workflow as shown in the second figure \<i\>Validation Workflow\</i\>. Each individual phase as well as the combination of phases may introduce errors and has thus to be carefully validated. In combination with the detailed strategies for each phase, this forms a complete approach for problem solving and validation using Rascal.\n \<br/\>\n\<br/\>\n\n A major question in every problem solving situation is how to determine the requirements for each phase of the solution. For instance, how do we know what to extract from the source code if we do not know what the desired end results of the project are? The standard solution is to use a workflow for requirements gathering that is the inverse of the phases needed to solve the complete problem. \n This is shown in the third figure \<i\>Requirements Workflow\</i\> and amounts to the phases: \n  \<ul\>\<li\> Requirements of the synthesis phase. This amounts to making an inventory of the desired results of the whole project and may include generated source code, abstract models, or visualizations. \<img class=\"TutorImg\" width=\"250px\" style=\"float: right;\" hspace=\"2px\" vspace=\"2px\"  title=\"Requirements Workflow\" alt=\"Requirements Workflow\" src=\"Courses/ProblemSolvingStrategies/requirements.png\"\>\</li\>\n\<li\> Requirements of the analysis phase. Once these results of the synthesis phase are known, it is possible to list the analysis results that are needed to synthesize desired results. Possible results of the analysis phase include type information, structural information of the original source.\</li\>\n\<li\> Requirements of the extraction phase. As a last step, one can make an inventory of the facts that have to be extracted to form the starting point for the analysis phase. Typical facts include method calls, inheritance relations, control flow graphs, usage patterns of specific library functions or language constructs.\</li\>\n\</ul\> You will have no problem in identifying requirements for each phase when you apply them to a specific \n example from the list given earlier.\n \<br/\>\n\<br/\>\n\n When these requirements have been established, it becomes much easier to actually carry out the project using the three phases \n of the first figure above.\n","","","",[])
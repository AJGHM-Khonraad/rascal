concept("StaticTyping",|cwd:///src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/StaticTyping/StaticTyping.concept|,[],{"Language"},{},"\n",{},"Rascal is based on static typing, this means that as many errors and inconsistencies as possible are spotted before the program is executed. The types are ordered in a so-called \<i\>type lattice\</i\> shown in the following figure. \<br\>\n\n\<img align=\"right\" width=\"400px\" height=\"400px\"  alt=\"Type Lattice\" src=\"Courses/Rascal/Concepts/StaticTyping/type-lattice.png\"\>\n\<br\>\nThe arrows describe a \<i\>subtype-of\</i\> relation between types. The type \<code\>void\</code\> is the \<i\>smallest\</i\> type and \nis included in all other types and the type \<code\>value\</code\> is the \<i\>largest\</i\> type that includes all other types. \nWe also see that \<code\>rel\</code\> is a subtype of \<code\>set\</code\> and that each ADT is a subtype of \<code\>node\</code\>. \nA special role is played by the datatype \<tt\>Tree\</tt\> that is the generic type of syntax trees. \nSyntax trees for specific languages are all subtypes of \<code\>Tree\</code\>. As a result, syntax trees can be addressed at two levels: \n\<ul\>\n\<li\> in a generic fashion as \<code\>Tree\</code\> and,\</li\>\n\<li\> in a specific fashion as a more precisely typed syntax tree.  Finally, each \<code\>alias\</code\> is structurally equivalent to one or more specific other types.\</li\>\n\n\</ul\>\n","\n","\n","\n",[])
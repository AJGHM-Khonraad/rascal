Name: Properties

Details:

Categories: Library

Syntax:

Types: 
* `FProperty`
* `alias FProperties = list[FProperty];`
* `alias computedInt = int();`
* `alias computedReal = real();`
* `alias computedNum = num();`
* `alias computedStr = str();`
* `alias computedColor = Color();`

Function:

Synopsis:

Description: 

All figures may have an (optional) list of properties.

A property:
* is represented by the type `FProperty`,
* has a standard value, unless it is explicitly defined for a figure,
* describes a property of the figure in which it is declared, but
* the standard value of each property may be redefined for all figures that are contained in a figure.


Several properties have variants that act on one or two dimensions. We call them _2D properties_ and use the following naming scheme:
* `P(num xy)` sets the value for property `P` in both dimensions to the same value `xy`.
* `P(num x, num y)` sets the value for property `P` to distinct values `x`, respectively, `y`.
* `hP(num x)` sets the horizontal value for property `P` to `x`.
* `vP(num y)` sets the vertical value for property `P` to `y`.


The properties `width` and `height` are synonyms for `hsize`, respectively, `vsize`.

Most properties have typed arguments but they come in several versions:

* A version with an argument of type `int`, `real`, `num`, `str` or `Color`. The values of these arguments are computed when the property is constructed, i.e., when the Figure is constructed.
* A version with _computed_ argument like `computeInt`, `computeReal`, `computeNum`, `computeStr` or `computeColor`. These are functions that
  return a value. These functions are called during the _rendering_ of the figure to which this property is attached. In this way, properties
  can be changed.


Properties can be classified as follows:
* __Sizing__: [Properties/size], [hsize], [vsize], [grow], [hgrow], [vgrow], [shrink], [hshrink], [vshrink], 
            [resizable], [hresizable], [vresizable], [lineWidth], [fontSize]
* __Aligning__: [align], [halign], [valign], [Properties/bottom], [Properties/top], [Properties/center], [hcenter], [vcenter]
* __Composing__: [gap], [hgap], [vgap], [startGap], [hstartGap], [vstartGap], [endGap], [hendGap], [vendGap]
* __Styling__: [lineColor], [lineStyle], [fillColor] [font], [fontColor], [shadow], [shadowColor], [shadowPos], [hshadowPos], [vshadowPos].
* __Interacting__: [resizable], [onClick], [onMouseMove], [onMouseOver], [onKey].

Examples:
Just a few examples to show the spirit:
* `size(10, 20)` sets the `size` property to 10 (horizontally), respectively 20 (vertically).
* `hsize(10)` sets the `hsize` property to the value 10.
* `hsize(int(){return 10;})` sets the `hsize` property to the result of executing the argument function `int(){return 10;}` which is, indeed, not a big deal. This usage becomes more interesting when the argument function returns different values for each call.
* `fillColor("blue")` sets the fill color of the current figure.
* `std(fillColor("blue"))` sets the standard fill color for the current figure and for all of its children.


See the more detailed description of each property for examples. 

Benefits:
* Values of properties are defined by an _inheritance-like_ approach: values can be nested and more nested declarations overrule more global ones. Default values can be set locally.

Pitfalls:
* As described above, each argument of a property may be specified in various manners. 
  To avoid clutter, __we only show the simplest version__, but be aware that all versions are allowed.
* A figure may inherit an undesired value for a property; the solution is to redeclare that property locally with the desired value.

Questions:


concept("SyntaxDefinition",|std:///experiments/RascalTutor/Courses/Rascal/Declarations/SyntaxDefinition/SyntaxDefinition.concept|,[],["NonTerminals","RegularExpressionNonTerminals","Disambiguation"],{},{"AbstractDataTypes","Visit","Expressions","Symbols","ParseActions","ConcreteSyntax","Disambiguation","Program","Patterns","ParseTrees","Implode"}," Syntax Definitions allow you to define parsers for programming languages or other formats.\n"," There are four kinds of non-terminals you can define: \<i\>lexical\</i\>, \<i\>syntax\</i\>, \<i\>layout\</i\> and \<i\>keyword\</i\>. They all have the same syntax, but they differ in how they are processed by the parser generator and how parse trees defined by them are processed by pattern matching and expression evaluation. The syntax of syntax definitions is largely dominated by the use of \<a href=\"/show?concept=Symbols\"\>Symbols\</a\> on the right-hand side of the \<code\>=\</code\> sign.\n \<br/\>\n\<br/\>\n\n \<code\>lexical \<i\>Nonterminal\</i\> = \<i\>Symbol\</i\>\<sub\>1\</sub\> \<i\>Symbol\</i\>\<sub\>2\</sub\> ... ;\</code\>\n \<br/\>\n\<br/\>\n\n \<code\>syntax \<i\>Nonterminal\</i\> = \<i\>Symbol\</i\>\<sub\>1\</sub\> \<i\>Symbol\</i\>\<sub\>2\</sub\> ... ;\</code\>\n \<br/\>\n\<br/\>\n\n \<code\>syntax \<i\>Nonterminal\</i\> = \<i\>Symbol\</i\>\<sub\>1\</sub\> \<i\>Label\</i\>\<sub\>1\</sub\> \<i\>Symbol\</i\>\<sub\>2\</sub\> \<i\>Label\</i\>\<sub\>2\</sub\> ... ;\</code\>\n \<br/\>\n\<br/\>\n\n \<code\>start syntax \<i\>Nonterminal\</i\> = \<i\>Symbol\</i\>\<sub\>1\</sub\> \<i\>Symbol\</i\>\<sub\>2\</sub\> ... ;\</code\>\n \<br/\>\n\<br/\>\n\n \<code\>syntax \<i\>Nonterminal\</i\> = \<i\>Name\</i\> : \<i\>Symbol\</i\>\<sub\>1\</sub\> \<i\>Label\</i\>\<sub\>1\</sub\> \<i\>Symbol\</i\>\<sub\>2\</sub\> ...;\</code\>\n \<br/\>\n\<br/\>\n\n \<code\>syntax \<i\>Nonterminal\</i\> = $Alternative_1 | \<i\>Alternative\</i\>\<sub\>2\</sub\> | \<i\>Alternative\</i\>\<sub\>3\</sub\> | ...;\</code\>  \n \<br/\>\n\<br/\>\n\n \<code\>syntax \<i\>Nonterminal\</i\> = $Alternative_1 \> \<i\>Alternative\</i\>\<sub\>2\</sub\> \> \<i\>Alternative\</i\>\<sub\>3\</sub\> \> ...;\</code\>\n \<br/\>\n\<br/\>\n\n \<code\>syntax \<i\>Nonterminal\</i\> = $Alternative_1 \> left { \<i\>Alternative\</i\>\<sub\>2\</sub\> | \<i\>Alternative\</i\>\<sub\>3\</sub\> | ... } | ...;\</code\>\n \<br/\>\n\<br/\>\n\n \<code\>layout \<i\>Nonterminal\</i\> = \<i\>Symbol\</i\>\<sub\>1\</sub\> \<i\>Symbol\</i\>\<sub\>2\</sub\> ... ;\</code\>\n \<br/\>\n\<br/\>\n\n \<code\>keyword \<i\>Nonterminal\</i\> = \<i\>Terminal\</i\>\<sub\>1\</sub\> | \<i\>Terminal\</i\>\<sub\>2\</sub\> | &amp;;\</code\>\n","","",{"\>","}","...;","=","|",";","layout",":","keyword","&;","lexical","syntax","start","Alternative_3","Alternative_2"}," Rascal supports full context-free grammars for syntax definition. It generates scannerless parsers from these definitions. These parsers produce \<a href=\"/show?concept=ParseTrees\"\>ParseTrees\</a\> that can be further processed by Rascal using \<a href=\"/show?concept=ConcreteSyntax\"\>ConcreteSyntax\</a\> fragments in \<a href=\"/show?concept=Patterns\"\>Patterns\</a\> and \<a href=\"/show?concept=Expressions\"\>Expressions\</a\>, or they can be \<i\>imploded\</i\> to \<a href=\"/show?concept=AbstractDataTypes\"\>AbstractDataTypes\</a\>.\n \<br/\>\n\<br/\>\n\n There are four kinds of non-terminals that can be defined with slightly different characteristics.\n \<ul\>\<li\> \<i\>Syntax\</i\> non-terminals are general context-free non-terminals. This mean left-recursion, right-recursion, any of the regular expression \<a href=\"/show?concept=Symbols\"\>Symbols\</a\> and all kinds of \<a href=\"/show?concept=Disambiguation\"\>Disambiguation\</a\> can be used to define it. It is important to note that in between the \<code\>\<i\>Symbols\</i\>\</code\> that define a syntax non-terminal the locally defined layout non-terminal will be interleaved. For example, if you define \<code\>layout ML = [\\ ]*;\</code\> and \<code\>syntax A = \"a\" \"a\"\</code\>, Rascal will \<i\>modify\</i\> the definition of A to \<code\>syntax A = \"a\" ML \"a\";\</code\> before generating a parser.\</li\>\n\<li\> \<i\>Lexical\</i\> non-terminals are just like \<i\>syntax\</i\> non-terminals, very much like \<i\>syntax\</i\> non-terminals. However, the definition of a lexical is \<i\>not\</i\> modified with interleaved layout non-terminals. And, the structure of lexicals is not traversed by the \<a href=\"/show?concept=Visit\"\>Visit\</a\> statement and equality is checked between lexicals by checking the characters (not its structure) for equality. \</li\>\n\<li\> \<i\>Layout\</i\> non-terminals are just like \<i\>syntax\</i\> non-terminals as well. However, they are used to preprocess all \<i\>syntax\</i\> definitons in the same module scope (see above).\</li\>\n\<li\> \<i\>Keyword\</i\> non-terminals are \<i\>not\</i\> like \<i\>syntax\</i\> non-terminals. These only allow definition of enumeration of literal symbols and single character classes. Keyword non-terminals play an important role in the semantics of \<a href=\"/show?concept=Disambiguation\"\>Disambiguation\</a\> where some disambiguation constructs require finite, non-empty enumeration of strings. The prime example is the definition of reserved keywords.\<br/\>\n\<br/\>\n Note that alternative definitions are either separated by \<code\>|\</code\> or by \<code\>\>\</code\> or they are grouped as in \<code\>\<i\>Associativity\</i\> { $Alternatives }\</code\>.\n The \<code\>\>\</code\> operator defines a partial order between production rules and thr groups define the associativity rules between alternatives. These are two of the \<a href=\"/show?concept=Disambiguation\"\>Disambiguation\</a\> constructs that you should read more about.\n\<br/\>\n\<br/\>\n Alternatives can be named or not. The names are essential only if:\n\</li\>\n\<li\> you need to \<a href=\"/show?concept=Implode\"\>Implode\</a\> \<a href=\"/show?concept=ParseTrees\"\>ParseTrees\</a\>\</li\>\n\<li\> you need to use the \<code\>is\</code\> expression, as in \<code\>myStatement is ifThenElse\</code\> instead of using concrete pattern matching.\</li\>\n\<li\> you want to write \<a href=\"/show?concept=ParseActions\"\>ParseActions\</a\> that triggers on the construction of the alternative However, it is generally a good idea to name your rules even if you do not need them. Note that a name may be reused for different alternatives for a single non-terminal, provided that the lists of symbols for these \"overloaded\" alternatives use \<i\>different non-terminal symbols\</i\>. This implies that alternatives for lexicals generally do not use overloaded names because they are often defined only by regular expressions over terminal \<a href=\"/show?concept=Symbols\"\>Symbols\</a\> (literals and character classes).\n\<br/\>\n\<br/\>\n The \<i\>start\</i\> modifier identifies the start of a grammar. The effect of a start modifier is that Rascal will generate an extra syntax definition before generating a parser that allows layout to before and after the start non-terminal. For example: \<code\>layout L = [\\ ]*; start Program = Statement*;\</code\> will produce \<code\>syntax start[Program] = L Program \<i\>top\</i\> L;\</code\>. Note that the start\<a href=\"/show?concept=Program\"\>Program\</a\> type is now available in your program, and \<a href=\"/show?concept=ParseTrees\"\>ParseTrees\</a\> assigned to variable of that type will allow access to the \<code\>\<i\>top\</i\>\</code\> field.\n\</li\>\n\</ul\>"," We may use syntax definitions in a very direct way, without much extra annotation:\n \<pre class=\"screen\"\>\</pre\>\n  Define an Identifier non-terminal using a regular expression over character classes:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>lexical Identifier = [a-z]+;\nok\n\</pre\>\n  Define the whitespace that will be used by following syntax definitions:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>layout MyLayout = [\\ \\t\\n]*;\nok\n\</pre\>\n  Define an expression language that uses the above Identifier and MyLayout definitions:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>syntax Expression \n&gt;&gt;&gt;&gt;&gt;&gt;&gt;  = Identifier\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &gt; left Expression &quot;*&quot; Expression\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &gt; left Expression &quot;+&quot; Expression\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ;\nok\n\</pre\>\n  Define somewhere to start\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>start syntax Calc = {Expression &quot;;&quot;}+;\nok\n\</pre\> However, parse trees generate via such definitions provide meager API. Instead you could define the same language like this:\n \<pre class=\"screen\"\>\</pre\>\n  Define an Identifier non-terminal using a regular expression over character classes:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>lexical Identifier = id: [a-z]+;\nok\n\</pre\>\n  Define the whitespace that will be used by following syntax definitions:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>layout MyLayout = [\\ \\t\\n]*;\nok\n\</pre\>\n  Define an expression language that uses the above Identifier and MyLayout definitions:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>syntax Expression \n&gt;&gt;&gt;&gt;&gt;&gt;&gt;  = id: Identifier id\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &gt; left mult: Expression lhs &quot;*&quot; Expression rhs\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &gt; left add: Expression lhs &quot;+&quot; Expression rhs\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ;\nok\n\</pre\>\n  Define somewhere to start\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>start syntax Calc = {Expression &quot;;&quot;}+;\nok\n\</pre\> Now you can use \n \<pre class=\"listing\"\>\<i\>e\</i\> is mult\n\</pre\> to see if a tree is a multiplication, or \n \<pre class=\"listing\"\>\<i\>e\</i\> has lhs\n\</pre\> to see if it is either \<code\>mult\</code\> or \<code\>add\</code\> but not \<code\>id\</code\>, etc. \n You can also do \n \<pre class=\"listing\"\>\<i\>e\</i\>.lhs\n\</pre\> to project the right-hand side of either a \<code\>mult\</code\> or an \<code\>add\</code\>.\n \<br/\>\n\<br/\>\n\n Either definition allows to call a parser: \n \<pre class=\"listing\"\>c = parse(#start[Calc], \"a + b\");\n\</pre\> Either definition would allow to embed \<a href=\"/show?concept=ConcreteSyntax\"\>ConcreteSyntax\</a\> fragments:\n \<pre class=\"listing\"\>d = (Expression) `a + b`;\n\</pre\> Finally, \<a href=\"/show?concept=ParseTrees\"\>ParseTrees\</a\> can be queried and transformed just like other data in Rascal, as in \n \<pre class=\"listing\"\>for (/(Expression) `&lt;Identifier i\>` := c) \n  println(\"id: &lt;i\>\");\n\</pre\>"," \<ul\>\<li\> modular and composable\</li\>\n\<li\> no grammar normalization or grammar factoring necessary\</li\>\n\<li\> generate a parser for any context-free grammar\</li\>\n\<li\> generate parsers are really fast (for general parsers)\</li\>\n\<li\> powerful disambiguation constructs for common programming language disambiguation patterns\</li\>\n\<li\> data-dependent (context-sensitive) disambiguation via arbitrary functions\</li\>\n\<li\> embedding of concrete syntax fragments in Rascal programs\</li\>\n\</ul\>"," \<ul\>\<li\> grammars may be ambiguous\</li\>\n\<li\> static grammar checker is not finished\</li\>\n\</ul\>",[])
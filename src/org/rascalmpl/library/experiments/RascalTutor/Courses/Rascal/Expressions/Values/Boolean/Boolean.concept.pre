concept("Boolean",|std:///experiments/RascalTutor/Courses/Rascal/Expressions/Values/Boolean/Boolean.concept|,[],[],{"Language"},{"Patterns"},""," \<code\>\n  true\n\</code\>, \<code\>\n  false\n\</code\>\n"," \<code\>\n  bool\n\</code\>\n","",{"true","bool","false"}," The Booleans are represented by the type \<code\>\n  bool\n\</code\> which has two values: \<code\>\n  true\n\</code\> and \<code\>\n  false\n\</code\>.\n \<br/\>\n\<br/\>\n\n The Boolean operators (to be more precise: operators with a value of type Boolean as result) have \<i\>short-circuit\</i\> semantics. \n This means that the operands are evaluated until the outcome of the operator is known.\n \<br/\>\n\<br/\>\n\n Most operator are self-explanatory except the match (:=) and no match (!:=) operators that are also the main reason to treat Boolean operator expressions separately. Although we describe patterns in full detail in the section called \<a href=\"/show?concept=Patterns\"\>Patterns\</a\>, a preview is useful here. A pattern can\n  \<ul\>\n  \<li\> match (or not match) any arbitrary value (that we will call the \<i\>subject value\</i\>);\</li\>\n  \<li\> during the match variables may be bound to subvalues of the subject value.\</li\>\n  \n\</ul\> The \<i\>match\</i\> operator\n \<pre class=\"listing\"\>\<i\>Pat\</i\> := \<i\>Exp\</i\>\n\</pre\> is evaluated as follows:\n  \<ul\>\n  \<li\> \<code\>\n    \<i\>Exp\</i\>\n  \</code\> is evaluated, the result is a subject value;\</li\>\n  \<li\> the subject value is matched against the pattern \<code\>\n    \<i\>Pat\</i\>\n  \</code\>;\</li\>\n  \<li\> if the match succeeds, any variables in the pattern are bound to subvalues of the subject value and the match expression yields \<code\>\n    true\n  \</code\>;\</li\>\n  \<li\> if the match fails, no variables are bound and the match expression yields \<code\>\n    false\n  \</code\>.\</li\>\n  \n\</ul\> This looks and \<i\>is\</i\> nice and dandy, so why all this fuss about Boolean operators?\n The catch is that--as we will see in \<a href=\"/show?concept=Patterns\"\>Patterns\</a\>--a match need not be unique. This means that there may be more than one way of matching the subject value resulting in different variable bindings. \n \<br/\>\n\<br/\>\n\n This behaviour is applicable in the context of all Rascal constructs where a pattern match determines the flow of control of the program, in particular:\n  \<ul\>\n  \<li\> Boolean expressions: when a pattern match fails that is part of a Boolean expression, further solutions are tried in order to try to make the Boolean expression true.\</li\>\n  \<li\> Tests in for, while, do statements.\</li\>\n  \<li\> Tests in one and all expressions.\</li\>\n  \<li\> Tests and enumerators in comprehensions.\</li\>\n  \<li\> Pattern matches in visit expression and switch statement.\</li\>\n  \<li\> Pattern matches during rewriting.\</li\>\n  \n\</ul\>"," Consider the following match of a list\n \<pre class=\"listing\"\>[1, list[int] L, 2, list[int] M] := [1,2,3,2,4]\n\</pre\> By definition \<code\>\n  list[int] L\n\</code\> and \<code\>\n  list[int] M\n\</code\> match list elements that are part of the enclosing list in which they occur. If they should match a nested list each should be enclosed in list brackets.\n \<br/\>\n\<br/\>\n\n There are two solutions for the above match:\n  \<ul\>\n  \<li\> \<code\>\n    L\n  \</code\> = \<code\>\n    []\n  \</code\> and \<code\>\n    M\n  \</code\> =\<code\>\n     [2, 3, 2, 4]\n  \</code\>; and\</li\>\n  \<li\> \<code\>\n    L\n  \</code\> = \<code\>\n    [2,3]\n  \</code\> and \<code\>\n    M\n  \</code\> =\<code\>\n     [4]\n  \</code\>.\</li\>\n  \n\</ul\> Depending on the context, only the first solution of a match expression is used, respectively all solutions are used.\n If a match expression occurs in a larger Boolean expression, a subsequent subexpression may yield false and -- depending on the actual operator -- evaluation backtracks to a previously evaluated match operator to try a next solution. Let\'\\s illustrate this by extending the above example:\n  \<pre class=\"listing\"\>[1, list[int] L, 2, list[int] M] := [1,2,3,2,4] &amp;&amp; size(L) \> 0\n\</pre\> where we are looking for a solution in which L has a non-empty list as value. Evaluation proceeds as follows:\n  \<ul\>\n  \<li\> The left argument of the \<code\>\n    &amp;&amp;\n  \</code\> operator is evaluated: the match expression is evaluated resulting in the bindings \<code\>\n    L = []\n  \</code\> and \<code\>\n    M = [2, 3, 2, 4]\n  \</code\>;\</li\>\n  \<li\> The right argument of the \<code\>\n    &amp;&amp;\n  \</code\> operator is evaluated: \<code\>\n    size(L) \> 0\n  \</code\> yields \<code\>\n    false\n  \</code\>;\</li\>\n  \<li\> Backtrack to the left argument of the \<code\>\n    &amp;&amp;\n  \</code\> operator to check for more solutions: indeed there are more solutions resulting in the bindings \<code\>\n    L = [2,3]\n  \</code\> and \<code\>\n    M = [4]\n  \</code\>;\</li\>\n  \<li\> Proceed to the right operator of \<code\>\n    &amp;&amp;\n  \</code\>: this time \<code\>\n    size(L) \> 0\n  \</code\> yields \<code\>\n    true\n  \</code\>;\</li\>\n  \<li\> The result of evaluating the complete expression is \<code\>\n    true\n  \</code\>.\</li\>\n  \n\</ul\>","","",[])
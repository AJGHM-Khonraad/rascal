concept("AlgebraicDataType",|cwd:///src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Declarations/AlgebraicDataType/AlgebraicDataType.concept|,[],[],{"Language"},{"Constructor"},"","\<code\>data \<i\>Name\</i\> = \<i\>Alt\</i\>\<sub\>1\</sub\> | \<i\>Alt\</i\>\<sub\>1\</sub\> | ... ;\</code\>\n","Introduces the type \<code\>\<i\>Name\</i\>\</code\> and constructor functions for each alternative.\n","",{"=","|",";","data"},"In ordinary programming languages record types or classes exist to introduce a new type name for a collection of related, \nnamed, values and to provide access to the elements of such a collection through their name. \n\nIn Rascal, algebraic data types provide this facility. They have to be declared, and\nthen values can be declared using calls to the declared constructor functions,\nsee \<a href=\"/show?concept=Constructor\"\>Constructor\</a\>.\n","\<pre class=\"screen\"\>\</pre\>\n The following data declaration defines the datatype \<code\>Bool\</code\> that contains various constants (\<code\>tt()\</code\> and \<code\>ff()\</code\>\n and constructor functions \<code\>conj\</code\> and \<code\>disj\</code\>.\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>data Bool = tt() | ff() | conj(Bool L, Bool R)  | disj(Bool L, Bool R);\nok\n\</pre\>\n terms of type \<code\>Bool\</code\> can be constructed using the defined constructors:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>conj(tt(),ff());\nBool: conj(tt(),ff())\n\</pre\>","","",[])
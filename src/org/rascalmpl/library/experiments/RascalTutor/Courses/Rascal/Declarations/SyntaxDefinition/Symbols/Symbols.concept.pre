concept("Symbols",|std:///experiments/RascalTutor/Courses/Rascal/Declarations/SyntaxDefinition/Symbols/Symbols.concept|,[],[],{},{"Disambiguations","Symbols","ConcreteSyntax","SyntaxDefinition","StringLiterals","Patterns","ParseTrees","nN","iI","gG","eE","bB"},""," Nonterminal symbols are written using identifier names that \<i\>start with a capital\</i\>.\n Any symbol can be labeled with field names that start with lowercase characters: \<code\>\<i\>Symbol\</i\> \<i\>fieldName\</i\>\</code\>.\n \<br/\>\n\<br/\>\n\n Then, there are literal symbols and character classes, as in:\n \<ul\>\<li\> \<code\>\"\<i\>stringliteral\</i\>\"\</code\> for literal strings\</li\>\n\<li\> \<code\>\'\\\<i\>stringliteral\</i\>\'\\\</code\> for case-insensitive literal strings\</li\>\n\<li\> \<code\>[$range_1 $range_2 ...]\</code\> for character classes.\<br/\>\n\<br/\>\n We have the following operations on character classes that can be composed arbitrarily:\n\</li\>\n\<li\> \<code\>!\<i\>Class\</i\>\</code\>, for complement w.r.t the UTF8 universe of characters.\</li\>\n\<li\> `\<code\>\<i\>Class\</i\>\<sub\>1\</sub\>\</code\> - \<code\>\<i\>Class\</i\>\<sub\>2\</sub\>\</code\>, for class difference.\</li\>\n\<li\> `\<code\>\<i\>Class\</i\>\<sub\>1\</sub\>\</code\> || \<code\>\<i\>Class\</i\>\<sub\>2\</sub\>\</code\>, for class union\</li\>\n\<li\> `\<code\>\<i\>Class\</i\>\<sub\>1\</sub\>\</code\> &amp;&amp; \<code\>\<i\>Class\</i\>\<sub\>2\</sub\>\</code\>, for class intersection\</li\>\n\<li\> \<code\>($Class)\</code\>, as brackets\<br/\>\n\<br/\>\n We can construct regular expressions over \<a href=\"/show?concept=Symbols\"\>Symbols\</a\>:\n\</li\>\n\<li\> \<code\>\<i\>Symbol\</i\>?\</code\> optional \<code\>\<i\>Symbol\</i\>\</code\>\</li\>\n\<li\> \<code\>\<i\>Symbol\</i\>+\</code\> non-empty list of \<code\>\<i\>Symbol\</i\>\</code\>\</li\>\n\<li\> \<code\>\<i\>Symbol\</i\>*\</code\> possibly empty list of \<code\>\<i\>Symbol\</i\>\</code\>\</li\>\n\<li\> \<code\>{\<i\>Symbol\</i\>\<sub\>1\</sub\> \<i\>Symbol\</i\>\<sub\>2\</sub\>}+\</code\> non-empty list of \<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\>\</code\> separated by \<code\>\<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> \<code\>{\<i\>Symbol\</i\>\<sub\>1\</sub\> \<i\>Symbol\</i\>\<sub\>2\</sub\>}+\</code\> possibly empty list of \<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\>\</code\> separated by \<code\>\<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> \<code\>(\<i\>Symbol\</i\>\<sub\>1\</sub\> \<i\>Symbol\</i\>\<sub\>2\</sub\> ... )\</code\> embedded sequence of symbols \</li\>\n\<li\> \<code\>(\<i\>Symbol\</i\>\<sub\>1\</sub\> | \<i\>Symbol\</i\>\<sub\>2\</sub\> | ... )\</code\> embedded choice of alternative symbols\</li\>\n\<li\> \<code\>()\</code\> the anonymous non-terminal for the language with the empty string\<br/\>\n\<br/\>\n Finally we can add inline conditions (\<a href=\"/show?concept=Disambiguations\"\>Disambiguations\</a\>) to symbols that constrain their acceptability:\n\</li\>\n\<li\> \<code\>\<i\>Symbol\</i\>\\$\</code\>, \<code\>\<i\>Symbol\</i\>\</code\> ends at end of line or file\</li\>\n\<li\> \<code\>^\<i\>Symbol\</i\>\</code\>, \<code\>\<i\>Symbol\</i\>\</code\> starts at start of line\</li\>\n\<li\> \<code\>\<i\>Symbol\</i\> @ \<i\>ColumnIndex\</i\>\</code\>, \<code\>\<i\>Symbol\</i\>\</code\> starts at certain column index\</li\>\n\<li\> \<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\> \>\> \<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\>, \<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\>\</code\> must be (directly) followed by \<code\>\<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> `\<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\>\</code\> !\>\> \<code\>\<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\>, \<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\>\</code\> must \<i\>not\</i\> be (directly) followed by \<code\>\<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> \<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\> &lt;&lt; \<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\>, \<code\>\<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\> must be (directly) preceded by \<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\>\</code\>\</li\>\n\<li\> \<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\> !&lt;&lt; \<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\>, \<code\>\<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\> must \<i\>not\</i\> be (directly) preceded by \<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\>\</code\>\</li\>\n\<li\> \<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\> \\ \<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\>, \<code\>\<i\>Symbol\</i\>\<sub\>1\</sub\>\</code\> must not be in the language defined by \<code\>\<i\>Symbol\</i\>\<sub\>2\</sub\>\</code\>\<br/\>\n\<br/\>\n Symbols can be composed arbitrarily.\n\</li\>\n\</ul\>"," Every non-terminal symbol is a type.\n","",{"?","^","\\","|","{","[","Class","range_2","...]","}+","+","*",")","(","\'\\","\"","!\<\<","()","!","\<\<","\>\>","@"}," The basic symbols are the non-terminal name and the labeled non-terminal name. These refer to the names defined by \<a href=\"/show?concept=SyntaxDefinition\"\>SyntaxDefinition\</a\>. You can use any defined non-terminal name in any other definition (lexical in syntax, syntax in lexical, etc). \n \<br/\>\n\<br/\>\n\n Then we have literals and character classes to define the \<i\>terminals\</i\> of a grammar. When you use a literal such as \<code\>\"begin\"\</code\>, Rascal will produce a definition for it down to the character level before generating a parser: \<code\>syntax \"begin\" = [b][e][g][i][n];\</code\>. This effect will be visible in the \<a href=\"/show?concept=ParseTrees\"\>ParseTrees\</a\> produced by the parser. For case insensitive literals you will see a similar effect; the use of \<code\>\'\\begin\'\\\</code\> produces `syntax \'\\begin\'\\ = \<a href=\"/show?concept=bB\"\>bB\</a\>\<a href=\"/show?concept=eE\"\>eE\</a\>\<a href=\"/show?concept=gG\"\>gG\</a\>\<a href=\"/show?concept=iI\"\>iI\</a\>\<a href=\"/show?concept=nN\"\>nN\</a\>.\n \<br/\>\n\<br/\>\n\n Character classes have the samen escaping conventions as characters in a \<a href=\"/show?concept=StringLiterals\"\>StringLiterals\</a\>, but spaces and newlines are meaningless and have to be escaped and the \<code\>[\</code\> and \<code\>]\</code\> brackets need escaping. For example, one writes \<code\>[\\[ \\] \\ \\n]\</code\> for a class that includes the open and close square brackets and a space and a newline. Please note about character classes that:\n \<ul\>\<li\> the operations on character classes are executed before parser generation time. You will not find explicit representation of the these operations in \<a href=\"/show?concept=ParseTrees\"\>ParseTrees\</a\>, but rather their net effect as resulting character classes. \</li\>\n\<li\> Character classes are also ordered by Rascal and overlapping ranges are merged before parsers are generated. Equality between character classes is checked after this canonicalization.\</li\>\n\<li\> Although all \<a href=\"/show?concept=Symbols\"\>Symbols\</a\> are type constructors, the character class operators are not allowed in types.\<br/\>\n\<br/\>\n The other symbols either \<i\>generate\</i\> for you parts of the construction of a grammar, or they \<i\>constrain\</i\> the rules of the grammar to generate a smaller set of trees as \<a href=\"/show?concept=Disambiguations\"\>Disambiguations\</a\>.\n\<br/\>\n\<br/\>\n The \<i\>generative symbols\</i\> are referred to as the \<i\>regular symbols\</i\>. These are like named non-terminals, except that they are defined implicitly and interpreted by the parser generator to produce a parser that can recognize a symbol optionally, iteratively, alternatively, sequentially, etc. You also need to know this about the regular symbols:\n\</li\>\n\<li\> In \<a href=\"/show?concept=ParseTrees\"\>ParseTrees\</a\> you will find special nodes for the regular expression symbols that hide \<i\>how\</i\> these were recognized. \</li\>\n\<li\> \<a href=\"/show?concept=Patterns\"\>Patterns\</a\> using \<a href=\"/show?concept=ConcreteSyntax\"\>ConcreteSyntax\</a\> have special semantics for the regular symbols (list matching, separator handling, ignoring layout, etc.).\</li\>\n\<li\> Regular symbols are not allowed in \<i\>keyword\</i\> \<a href=\"/show?concept=SyntaxDefinition\"\>SyntaxDefinition\</a\>s\</li\>\n\<li\> Depending on their occurence in a \<i\>lexical\</i\>, \<i\>syntax\</i\> or \<i\>layout\</i\> \<a href=\"/show?concept=SyntaxDefinition\"\>SyntaxDefinition\</a\> the semantics of regular symbols changes. In the \<i\>syntax\</i\> context, layout non-terminals will be woven into the regular symbol, but not in the \<i\>lexical\</i\> and \<i\>layout\</i\> contexts. For example, a \<code\>\<i\>Symbol\</i\>*\</code\> in a \<i\>syntax\</i\> definition such as \<code\>syntax X = A*;\</code\> will be processed to \<code\>syntax X = \</code\>{A Layout}*\<code\>. Similarly, \</code\>syntax X = {A B}+;\<code\> will be processed to \</code\>syntax X = {A (Layout B Layout)}+;`. \<br/\>\n\<br/\>\n The \<i\>constraint\</i\> symbols are specially there to deal with the fact that Rascal does not generate a scanner. There are no a priori disambiguation rules such as prefer keywords or longest match. Instead, you should use the constraint symbols to define the effect of keyword reservation and longest match. \n\</li\>\n\<li\> It is important to note that these constraints work on a character-by-character level in the input stream. So, a follow constraint such as \<code\>A \>\> [a-z]\</code\> means that the character immediately following a recognized A must be in the range \<code\>[a-z]\</code\>.\</li\>\n\<li\> Read more on the constraint symbols via \<a href=\"/show?concept=Disambiguations\"\>Disambiguations\</a\>.\</li\>\n\</ul\>","","","",[])
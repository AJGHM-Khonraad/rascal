course("Rascal Tutorial",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/|,"Rascal",("Rascal/Concepts/ControlStructures":concept("ControlStructures",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/ControlStructures/ControlStructures.concept|,[],{},[],"\n",{},"\nControl structures like \<a href=\"/show?concept=if\"\>if\</a\> and \<a href=\"/show?concept=while\"\>while\</a\> statement are driven by Boolean expressions.\nActually, combinations of generators and Boolean expressions can be used to drive the control structures. \nIn the latter case, the Boolean expression is executed for each generated value.\n","\nA classical if statement:\n\<pre class=\"listing\"\>if(N &lt;= 0)\n     return 1; \n  else\n     return N * fac(N - 1);\n\</pre\>\nA combination of a generator and a test:\n\n\<pre class=\"listing\"\>for(/asgStat(Id name, _) &lt;- P, size(name) \> 10){\n    println(name);\n}\n\</pre\>This statement prints all identifiers in assignment statements (\<code\>asgStat\</code\>) that consist of more than 10 characters.\n","\n","\n",[]),"Rascal/Expressions/Values/Number":concept("Number",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/Number.concept|,[],{"Language"},[],"int\nreal\nnum\n",{},"Numbers include integers (values of type \<tt\>int\</tt\>) and reals (values of type \<tt\>real\</tt\>). If both operands have the same type (\<tt\>int\</tt\> or \<tt\>real\</tt\>) then the operator is the corresponding operator on integers or reals. Otherwise, integer arguments are first converted to real and the real operator is applied.\n","\n","\n","\n",[]),"Rascal/Expressions/Values/Number/arbReal":concept("arbReal",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/arbReal/arbReal.concept|,[],{"Library"},[],"Function: \<code\>real arbReal( )\</code\>\n",{},"Returns an arbitrary real value in the interval [0.0, 1.0].\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Number;\nok\n\<b\>rascal\>\</b\>arbReal();\nreal: 0.20859634979661046\n\<b\>rascal\>\</b\>arbReal();\nreal: 0.7576568818766185\n\<b\>rascal\>\</b\>arbReal();\nreal: 0.4984622347630746\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Patterns":concept("Patterns",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Patterns/Patterns.concept|,[],{},[],"\n",{},"\n","\n","\n","\n",[]),"Rascal/Concepts/Functions":concept("Functions",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/Functions/Functions.concept|,[],{},[],"\n",{},"\nFunctions allow the definition of frequently used operations. They have a name and formal parameters. They are explicitly declared and are fully typed. \nFunctions can also be used as values thus enabling higher-order functions. \nRascal is a higher-order language in which functions are first-class values.\n","\nHere is an example of a function that counts the number of assignment statements in a program:\n\<pre class=\"listing\"\>int countAssignments(PROGRAM P){\n    int n = 0;\n    visit (P){\n    case asgStat(_, _):\n         n += 1;\n    }\n    return n;\n}\n\</pre\>\nConsider the following use of higher-order functions:\n\<pre class=\"listing\"\>int double(int x) { return 2 * x; }\n\nint triple(int x) { return 3 * x; }\n\nint f(int x, int (int) multi){ return multi(x); }\n\</pre\>\nThe functions \<code\>double\</code\> and \<code\>triple\</code\> simply multiply their argument with a constant. \nFunction \<code\>f\</code\> is, however, more interesting. \nIt takes an integer \<code\>x\</code\> and a function \<code\>multi\</code\> (with integer argument and integer result) as argument and \napplies multi to its own argument. \<code\>f(5, triple)\</code\> will hence return \<code\>15\</code\>. \nFunction values can also be created anonymously as illustrated by the following, alternative, \nmanner of writing this same call to \<code\>f\</code\>:\n\<pre class=\"listing\"\>f(5, int (int y){return 3 * y;});\n\</pre\>\nHere the second argument of \<code\>f\</code\> is an anonymous function.\n","\n","\n",[]),"Rascal/Expressions/Values":concept("Values",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Values.concept|,[],{"Language"},[],"\n",{},"\n","\n","\n","\n",[]),"Rascal/Expressions/Values/Set/getOneFrom":concept("getOneFrom",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/getOneFrom/getOneFrom.concept|,[],{"Library"},[],"Function: \<code\>&amp;T getOneFrom(set[&amp;T] s) throws emptySet\</code\>\n",{},"Returns a random element from set \<code\>s\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>getOneFrom({1,2,3,4});\nint: 4\n\<b\>rascal\>\</b\>getOneFrom({1,2,3,4});\nint: 1\n\<b\>rascal\>\</b\>getOneFrom({1,2,3,4});\nint: 4\n\<b\>rascal\>\</b\>getOneFrom({1,2,3,4});\nint: 2\n\</pre\>","\n","\n",[]),"Rascal/EASY/Renovation":concept("Renovation",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/EASY/Renovation/Renovation.concept|,[],{"Example"},[],"\n",{},"\n\<img width=\"300px\" height=\"300px\" align=\"right\"  alt=\"Extract-Analyze-View Paradigm\" src=\"Courses/Rascal/EASY/Renovation/extract-analyze-view-paradigm.png\"\>\n\n_Charlotte_ is software engineer at a large financial institution in Paris and she is looking for options to connect an old and dusty software system to a web interface. She will need to analyze the sources of that system to understand how it can be changed to meet the new requirements. The objects-of-interest are in this case the source files, documentation, test scripts and any other available information. They have to be parsed in some way in order to extract relevant information, say the calls between various parts of the system. The call information can be represented as a binary relation between caller and callee (the internal representation in this example). This relation with 1-step calls is analyzed and further extended with 2-step calls, 3-step calls and so on. In this way call chains of arbitrary length become available. With this new information, we can synthesize results by determining the entry points of the software system, i.e., the points where calls from the outside world enter the system. Having completed this first cycle, Charlotte may be interested in which procedures can be called from the entry points and so on and so forth. Results will be typically represented as pictures that display the relationships that were found. In the case of source code analysis, a variation of our workflow scheme is quite common. It is then called the extract-analyze-view paradigm and is shown in the figure.\n","\n","\n","\n",[]),"Rascal/Expressions/Values/Number/Multiplication":concept("Multiplication",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/Multiplication/Multiplication.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\> * \<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"*","bool"},"Yields the result of multiplying the values of \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\>\</code\> and \<code\>\<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>12 * 13\nint: 156\n\<b\>rascal\>\</b\>12 * 13.5\nreal: 162.00\n\<b\>rascal\>\</b\>-12*13\nint: -156\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:int\> * \<B:int\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:int\> * \<B:real\>","",false,false,[<"A",int(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:real\> * \<B:int\>","",false,false,[<"A",real(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",[],"","","\<A:num\> * \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),""))]),"Rascal/Expressions":concept("Expressions",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Expressions.concept|,[],{"Language"},[],"\n",{},"\nThe expression is the basic unit of evaluation and may consist of the ingredients shown in the figure.\n\<img width=\"300px\" height=\"300px\" align=\"right\"  alt=\"Structure of Expressions\" src=\"Courses/Rascal/Expressions/exp-parts.png\"\>\n\n\<ul\>\n\<li\> An elementary _literal value_, e.g. constants of the types \<a href=\"/show?concept=Boolean\"\>Boolean\</a\>, \<a href=\"/show?concept=Integer\"\>Integer\</a\>, \<a href=\"/show?concept=Real\"\>Real\</a\>, \<a href=\"/show?concept=Number\"\>Number\</a\>, \<a href=\"/show?concept=String\"\>String\</a\>, \<a href=\"/show?concept=Location\"\>Location\</a\> or \<a href=\"/show?concept=DateTime\"\>DateTime\</a\>.\</li\>\n\<li\> A _structured value_ for \<a href=\"/show?concept=List\"\>List\</a\>, \<a href=\"/show?concept=Set\"\>Set\</a\>, \<a href=\"/show?concept=Map\"\>Map\</a\>, \<a href=\"/show?concept=Tuple\"\>Tuple\</a\> or \<a href=\"/show?concept=Relation\"\>Relation\</a\>. The elements are first evaluated before the structured value is built.\</li\>\n\<li\> A _variable_ that evaluates to its current value.\</li\>\n\<li\> A call to a function or constructor:\</li\>\n\<ul\>\n\<li\> A _function call_. First the arguments are evaluated and the corresponding function is called. The value returned by the function is used as value of the function call.\</li\>\n\<li\> A _constructor_. First the arguments are evaluated and then a data value is constructed for the corresponding type. This data value is used as value of the constructor. Constructors are functions that can be used in all contexts where functions can be used.\</li\>\n\n\</ul\>\n\<li\> An operator expression. The operator is applied to the arguments; the evaluation order of the arguments depends on the operator. The result returned by the operator is used as value of the operator expression. \</li\>\n\<li\> A \<a href=\"/show?concept=Pattern\"\>Pattern\</a\>.\</li\>\n\<li\> A pattern with associated action, see \<a href=\"/show?concept=PatternWithAction\"\>PatternWithAction\</a\>.\</li\>\n\<li\> A \<a href=\"/show?concept=Comprehension\"\>Comprehension\</a\>.\</li\>\n\<li\> A \<a href=\"/show?concept=Visit\"\>Visit\</a\> expression.\</li\>\n\<li\> A \<a href=\"/show?concept=One\"\>One\</a\> expression.\</li\>\n\<li\> An \<a href=\"/show?concept=All\"\>All\</a\> expression.\</li\>\n\<li\> Some statements like if, for, while and do can also be used in expressions, see \<a href=\"/show?concept=StatementAsExpression\"\>StatementAsExpression\</a\>.\</li\>\n\n\</ul\>\n","\n","\n","\n",[]),"Rascal/Expressions/Patterns/Abstract":concept("Abstract",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Patterns/Abstract/Abstract.concept|,[],{},[],"\n",{},"\nAn abstract pattern is recursively defined and may contain the following elements:\n\n\<ul\>\n\<li\> Literal of one of the basic types \<a href=\"/show?concept=Boolean\"\>Boolean\</a\>, \<a href=\"/show?concept=Integer\"\>Integer\</a\>, \<a href=\"/show?concept=Real\"\>Real\</a\>, \<a href=\"/show?concept=Number\"\>Number\</a\>, \<a href=\"/show?concept=String\"\>String\</a\>, \<a href=\"/show?concept=Location\"\>Location\</a\>, or \<a href=\"/show?concept=DateTime\"\>DateTime\</a\>.  A literal pattern matches with a value that is identical to the literal.\</li\>\n\<li\> A _variable declaration pattern_ \<listing\> \<code\>\<i\>Type\</i\>\</code\> \<code\>\<i\>Var\</i\>\</code\> \</listing\> A variable declaration introduces a new variable \<code\>\<i\>Var\</i\>\</code\> that matches any value of the given type \<code\>\<i\>Type\</i\>\</code\>. That value is assigned to \<code\>\<i\>Var\</i\>\</code\> when the whole match succeeds.\</li\>\n\<li\> A _multi-variable pattern_ \<listing\> \<code\>\<i\>Var\</i\>\</code\>* \</listing\> A multi-variable is an abbreviation for a variable declaration pattern.  It can occur in a list pattern or set pattern and can match zero or more list or set elements.\</li\>\n\<li\> A _variable pattern_ \<listing\> Var \</listing\> A variable pattern can act in two roles:\</li\>\n\<ul\>\n\<li\>If \<code\>\<i\>Var\</i\>\</code\> has already a defined value then it matches with that value.\</li\>\n\<li\> If \<code\>\<i\>Var\</i\>\</code\> has not been defined before (or it has been declared but not initialized) then it matches any value.      That value is assigned to \<code\>\<i\>Var\</i\>\</code\>. \<warning\>Explain scope.\</warning\>\</li\>\n\n\</ul\>\n\<li\> A _list pattern_ \<listing\> [ \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\> ] \</listing\> A list pattern matches a list value, provided that \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\> match the elements of that list in order.  Two special cases exist when one of the patterns \<code\>\<i\>Pat\</i\>\<sub\>i\</sub\>\</code\> is\</li\>\n\<ul\>\n\<li\> a variable declaration pattern with a list type that is identical to the type of the list that is being matched.\</li\>\n\<li\> a variable pattern, where the variable has been declared, but not initialized, outside the pattern with a list type that is identical to the type of the list that is being matched.\<br/\>\n\<br/\>\nIn both cases list matching is applied and the variable can match an arbitrary number of elements of the subject list.\</li\>\n\n\</ul\>\n\<li\> A _set pattern_ \<listing\> { \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\> } \</listing\> A set pattern matches a set value, provided that \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\> match the elements of that set in any order. Completely analogous to list patterns, there are two special cases when one of the patterns \<code\>\<i\>Pat\</i\>\<sub\>i\</sub\>\</code\> is\</li\>\n\<ul\>\n\<li\> a variable declaration pattern with a set type that is identical to the type of the set that is being matched.\</li\>\n\<li\> a variable pattern, where the variable has been declared, but not initialized, outside the pattern with a set type that is identical to the type of the set that is being matched.\<br/\>\n\<br/\>\nIn both cases set matching is applied and the variable can match an arbitrary number (in arbitrary order!) of elements of the subject set.\</li\>\n\n\</ul\>\n\<li\> A _tuple pattern_ \<listing\> \< \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\> \> \</listing\> A tuple pattern matches a tuple value, provided that \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\>  match the elements of that tuple in order.\</li\>\n\<li\> A _node pattern_ \<listing\> \<code\>\<i\>Name\</i\>\</code\> ( \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\> ) \</listing\> A node pattern matches a node value or a datatype value, provided that \<code\>\<i\>Name\</i\>\</code\> matches with the constructor symbol of that value  and \<code\>\<i\>Pat\</i\>\<sub\>1\</sub\>\</code\>, \<code\>\<i\>Pat\</i\>\<sub\>2\</sub\>\</code\>, ..., \<code\>\<i\>Pat\</i\>\<sub\>n\</sub\>\</code\>  match the children of that value in order.\</li\>\n\<li\> A _descendant pattern_ \<listing\> / \<code\>\<i\>Pat\</i\>\</code\> \</listing\> performs a deep match of the pattern \<code\>\<i\>Pat\</i\>\</code\>. In other words, it matches when any element of the subject at any depth matches \<code\>\<i\>Pat\</i\>\</code\>  and is used to match, for instance, tree nodes at an arbitrary distance from the root.\</li\>\n\<li\> A _labelled pattern_ \<listing\> \<code\>\<i\>Var\</i\>\</code\> : \<code\>\<i\>Pat\</i\>\</code\> \</listing\> A labelled pattern matches the same values as \<code\>\<i\>Pat\</i\>\</code\>, but has as side-effect that the matched value is assigned to \<code\>\<i\>Var\</i\>\</code\>.\</li\>\n\<li\> A _typed, labelled, pattern_ \<listing\> \<code\>\<i\>Type\</i\>\</code\> \<code\>\<i\>Var\</i\>\</code\> : \<code\>\<i\>Pat\</i\>\</code\> \</listing\> A typed, labelled, pattern matches when the subject value has type \<code\>\<i\>Type\</i\>\</code\> and \<code\>\<i\>Pat\</i\>\</code\> matches. The matched value is assigned to \<code\>\<i\>Var\</i\>\</code\>.\</li\>\n\<li\> A _type constrained pattern_ \<listing\> [\<code\>\<i\>Type\</i\>\</code\>] \<code\>\<i\>Pat\</i\>\</code\> \</listing\> matches provided that the subject has type \<code\>\<i\>Type\</i\>\</code\> and \<code\>\<i\>Pat\</i\>\</code\> matches.\</li\>\n\n\</ul\>\n","\n","\n","Map patterns are not yet supported.\n",[]),"Rascal/Expressions/Values/Boolean":concept("Boolean",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Boolean/Boolean.concept|,[],{"Language"},[],"\n\<ul\>\n\<li\> Syntax: \<code\>true\</code\> and \<code\>false\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"bool"},"The Booleans are represented by the type \<code\>bool\</code\> which has two values: \<code\>true\</code\> and \<code\>false\</code\>.\n\nThe Boolean operators (to be more precise: operators with a value of type Boolean as result) have _short-circuit_ semantics. \nThis means that the operands are evaluated until the outcome of the operator is known.\n\nMost operator are self-explanatory except the match (:=) and no match (!:=) operators that are also the main reason to treat Boolean operator expressions separately. Although we describe patterns in full detail in the section called \<a href=\"/show?concept=Patterns\"\>Patterns\</a\>, a preview is useful here. A pattern can\n\n\<ul\>\n\<li\> match (or not match) any arbitrary value (that we will call the _subject value_);\</li\>\n\<li\> during the match variables may be bound to subvalues of the subject value.\</li\>\n\n\</ul\>\nThe _match_ operator\n\<pre class=\"listing\"\>\<i\>Pat\</i\> := \<i\>Exp\</i\>\n\</pre\>is evaluated as follows:\n\n\<ul\>\n\<li\> \<code\>\<i\>Exp\</i\>\</code\> is evaluated, the result is a subject value;\</li\>\n\<li\> the subject value is matched against the pattern \<code\>\<i\>Pat\</i\>\</code\>;\</li\>\n\<li\> if the match succeeds, any variables in the pattern are bound to subvalues of the subject value and the match expression yields \<code\>true\</code\>;\</li\>\n\<li\> if the match fails, no variables are bound and the match expression yields \<code\>false\</code\>.\</li\>\n\n\</ul\>\nThis looks and _is_ nice and dandy, so why all this fuss about Boolean operators?\nThe catch is that--as we will see in \<a href=\"/show?concept=Patterns\"\>Patterns\</a\>--a match need not be unique. This means that there may be more than one way of matching the subject value resulting in different variable bindings. \n\nThis behaviour is applicable in the context of all Rascal constructs where a pattern match determines the flow of control of the program, in particular:\n\n\<ul\>\n\<li\> Boolean expressions: when a pattern match fails that is part of a Boolean expression, further solutions are tried in order to try to make the Boolean expression true.\</li\>\n\<li\> Tests in for, while, do statements.\</li\>\n\<li\> Tests in one and all expressions.\</li\>\n\<li\> Tests and enumerators in comprehensions.\</li\>\n\<li\> Pattern matches in visit expression and switch statement.\</li\>\n\<li\> Pattern matches during rewriting.\</li\>\n\n\</ul\>\n","\nConsider the following match of a list\n\<pre class=\"listing\"\>[1, list[int] L, 2, list[int] M] := [1,2,3,2,4]\n\</pre\>By definition \<code\>list[int] L\</code\> and \<code\>list[int] M\</code\> match list elements that are part of the enclosing list in which they occur. If they should match a nested list each should be enclosed in list brackets.\n\nThere are two solutions for the above match:\n\n\<ul\>\n\<li\> \<code\>L\</code\> = \<code\>[]\</code\> and \<code\>M\</code\> =\<code\> [2, 3, 2, 4]\</code\>; and\</li\>\n\<li\> \<code\>L\</code\> = \<code\>[2,3]\</code\> and \<code\>M\</code\> =\<code\> [4]\</code\>.\</li\>\n\n\</ul\>\nDepending on the context, only the first solution of a match expression is used, respectively all solutions are used.\nIf a match expression occurs in a larger Boolean expression, a subsequent subexpression may yield false and -- depending on the actual operator -- evaluation backtracks to a previously evaluated match operator to try a next solution. Let\'\\s illustrate this by extending the above example:\n\n\<pre class=\"listing\"\>[1, list[int] L, 2, list[int] M] := [1,2,3,2,4] &amp;&amp; size(L) \> 0\n\</pre\>where we are looking for a solution in which L has a non-empty list as value. Evaluation proceeds as follows:\n\n\<ul\>\n\<li\> The left argument of the &amp;&amp; operator is evaluated: the match expression is evaluated resulting in the bindings L = [] and M = [2, 3, 2, 4];\</li\>\n\<li\> The right argument of the &amp;&amp; operator is evaluated: size(L) \> 0 yields false;\</li\>\n\<li\> Backtrack to the left argument of the &amp;&amp; operator to check for more solutions: indeed there are more solutions resulting in the bindings L = [2,3] and M = \<a href=\"/show?concept=4\"\>4\</a\>;\</li\>\n\<li\> Proceed to the right operator of &amp;&amp;: this time size(L) \> 0 yields true;\</li\>\n\<li\> The result of evaluating the complete expression is true.\</li\>\n\n\</ul\>\n","\n","\n",[]),"Rascal/Examples/ColoredTrees":concept("ColoredTrees",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Examples/ColoredTrees/ColoredTrees.concept|,[],{"Example"},[],"\n",{},"\nWe consider binary trees---trees with exactly two children---that have integers as their leaves. \nOur trees can have red and black nodes and we want to perform the following operations on them:\n\<ul\>\n\<li\> Count the number of red nodes.\</li\>\n\<li\> Compute the sum of all the integers that occur in the leaves.\</li\>\n\<li\> Extend the tree data type with green nodes.\</li\>\n\<li\> Replace all red nodes by green ones.\</li\>\n\n\</ul\>\n","The definition of ColoredTrees is as follows:\n\<pre class=\"listing\"\>module demo::ColoredTrees\n\n// Define ColoredTrees with red and black nodes and integer leaves\n\ndata ColoredTree = leaf(int N)      \<img src=\"images/1.png\"\>\n                 | red(ColoredTree left, ColoredTree right) \n                 | black(ColoredTree left, ColoredTree right);\n          \n// Count the number of red nodes\n          \npublic int cntRed(ColoredTree t){\n   int c = 0;\n   visit(t) {\n     case red(_,_): c = c + 1;      \<img src=\"images/2.png\"\>\n   };\n   return c;\n}\n\n// Compute the sum of all integer leaves\n\npublic int addLeaves(ColoredTree t){\n   int c = 0;\n   visit(t) {\n     case leaf(int N): c = c + N;   \<img src=\"images/3.png\"\>\n   };\n   return c;\n}\n\n// Add green nodes to ColoredTree\n\ndata ColoredTree = green(ColoredTree left, ColoredTree right); \<img src=\"images/4.png\"\>\n\n// Transform red nodes into green nodes\n\npublic ColoredTree makeGreen(ColoredTree t){\n   return visit(t) {\n     case red(l, r) =\> green(l, r)   \<img src=\"images/5.png\"\>\n   };\n}\n\</pre\>\nFirst (\<img src=\"images/1.png\"\>) we define the data type of \<code\>ColoredTrees\</code\> with constructors\n\<code\>leaf\</code\>, \<code\>red\</code\> and \<code\>black\</code\>.\n\n\<code\>cntRed\</code\> (\<img src=\"images/2.png\"\>) counts all red nodes by visiting all nodes and incrementing\nthe counter \<code\>c\</code\> for each red one.\n\n\<code\>addLeaves\</code\> (\<img src=\"images/3.png\"\>) visits all nodes and adds the integers in each leaf node.\n\nIn \<img src=\"images/4.png\"\> \<code\>coloredTrees\</code\> are extended with a new constructor \<code\>green\</code\>.\n\<code\>makeGreen\</code\> (\<img src=\"images/5.png\"\>) visits all nodes and turns red nodes in green ones.\n\nWe can now explore ColoredTrees:\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import demo::ColoredTrees;\nok\n\<b\>rascal\>\</b\>rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));\nColoredTree: red(black(leaf(1),red(leaf(2),leaf(3))),black(leaf(3),leaf(4)))\n\</pre\>\n Count the red nodes in \<code\>rb\</code\>:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>cntRed(rb);\nint: 2\n\</pre\>\n and compute the sum of all leaves:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>addLeaves(rb);\nint: 13\n\</pre\>\n Finally, we convert all red nodes:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>makeGreen(rb);\nColoredTree: green(black(leaf(1),green(leaf(2),leaf(3))),black(leaf(3),leaf(4)))\n\</pre\>","This example illustrates the fully automatic visiting of the elements of a structured data type.\nCompare this with the traditional programming style in which a switch statement is used to determine\nthe constructor and recursion is used to visit substructures. This style becomes particularly cumbersome\nfor data types with large numbers of constructors such as, for instance, abstract syntax trees for real\nprogramming languages.\n","The visit statement is based on a new paradigm one has to learn.\n",[]),"Rascal/Expressions/Values/Set/Equal":concept("Equal",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/Equal/Equal.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: `\<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\>\</code\> == \<code\>\<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"bool"},"Yields \<code\>true\</code\> if both arguments are equal sets and \<code\>false\</code\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3} == {3, 2, 1};\nbool: true\n\<b\>rascal\>\</b\>{1, 2, 3} == {1, 2};\nbool: false\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Number/Remainder":concept("Remainder",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/Remainder/Remainder.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>IntExp\</i\>\<sub\>1\</sub\> % \<i\>IntExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>int\</code\>\</li\>\n\n\</ul\>\n",{"int","%"},"Yields the remainder when dividing the of \<code\>\<i\>IntExp\</i\>\<sub\>1\</sub\>\</code\> by the value of \<code\>\<i\>IntExp\</i\>\<sub\>2\</sub\>\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>12 % 5\nint: 2\n\<b\>rascal\>\</b\>12 % 6\nint: 0\n\</pre\>","\n","Remainder is only defined on integers:\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>13.5 % 6\nStatic Error: prompt:///:1,0: modulo not supported on real and int\n\</pre\>",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:int\> % \<B:int\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:int\> % \<B:real\>","",false,false,[<"A",int(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:real\> % \<B:int\>","",false,false,[<"A",real(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",[],"","","\<A:num\> % \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),""))]),"Rascal/Expressions/Values/Set/min":concept("min",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/min/min.concept|,[],{"Library"},[],"Function: \<code\>&amp;T min(set[&amp;T] s)\</code\>\n",{},"Returns the smallest element from a set.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>min({1, 3, 5, 4, 2});\nint: 1\n\</pre\>","\n","\n",[]),"Rascal/Examples/Hello":concept("Hello",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Examples/Hello/Hello.concept|,[],{"Example"},[],"\n",{},"Variations on the ubiquitous \'\\\'\\Hello World\'\\\'\\ example.\n","\n\<h1\> First version: hello on the command line \</h1\>\n\nWe demonstrate hello via an interactive session with the Rascal system. First we get the prompt \<code\>rascal\>\</code\> that shows that Rascal is ready for our input. Next, we import the library module IO since hello world requires printing. Rascal responds with the feedback \<code\>ok\</code\> so we know that all went well. Finally, we call \<code\>println\</code\> and proudly observe our first Rascal output!\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import IO;\nok\n\<b\>rascal\>\</b\>println(&quot;Hello world, this is my first Rascal program&quot;);\nHello world, this is my first Rascal program\nok\n\</pre\>\n\<h1\> Second version: hello in a function \</h1\>\n\nA slightly more audacious approach is to wrap the print statement in a function and call it:\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import IO;\nok\n\<b\>rascal\>\</b\>void hello() {\n\>\>\>\>\>\>\>   println(\"Hello world, this is my first Rascal program\");\n\>\>\>\>\>\>\>}\nvoid (): void hello();\n\</pre\>\nWhen you type in a command and continue it on a new line \nthe Rascal systems prompts you with \<code\>\>\>\>\>\>\>\>\</code\> to \nindicate that more input is needed. Don\'\\t get scared by \nthe \<code\>void (): void hello();\</code\> that you get back \nwhen typing in the hello function. The first \n \<code\>void ()\</code\> part says the result is a function that \n returns nothing, and the second part \n \<code\>void hello()\</code\> summarizes its value \n (or would you prefer a hex dump?).\n Finally, we call the \<tt\>hello\</tt\> function and enjoy its output.\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>hello();\nHello world, this is my first Rascal program\nok\n\</pre\>\n\<h1\> Third version: hello in a module \</h1\>\nThe summit of hello-engineering can be reached by placing all the above in a separate module:\n\n\<pre class=\"listing\"\>module demo::Hello\n\nimport IO;\n\npublic void hello() {\n   println(\"Hello world, this is my first Rascal program\");\n}\n\n\</pre\>\nNote that we added a public modifier to the definition of hello, since we want it to be visible outside the Hello module. Using this Hello module is now simple:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import demo::Hello;\nok\n\<b\>rascal\>\</b\>hello();\nHello world, this is my first Rascal program\nok\n\</pre\>","\n","\n",[]),"Rascal/Concepts/EquationSolving":concept("EquationSolving",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/EquationSolving/EquationSolving.concept|,[],{},[],"\n",{},"Many problems can be solved by forms of _constraint solving_. \nThis is a declarative way of programming: specify the constraints that a problem solution should \nsatisfy and how potential solutions can be generated. \nThe actual solution (if any) is found by enumerating solutions and testing their compliance with the constraints.\n\nRascal provides a [\<a href=\"/show?concept=solve\"\>solve\</a\>] statement that helps writing constraint solvers. \n","\nA typical example is dataflow analysis where the propagation of values through a program can be described by a set of equations. Their solution can be found with the solve statement. \<warning\> add links \</warning\>\n","\n","\n",[]),"Rascal/Concepts/Datatypes":concept("Datatypes",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/Datatypes/Datatypes.concept|,[],{},[],"\n",{},"\nRascal provides a rich set of datatypes:\n\<ul\>\n\<li\> Booleans (\<code\>bool\</code\>).\</li\>\n\<li\> Infinite precision integers (\<code\>int\</code\>), reals (\<code\>real\</code\>), and numbers (\<code\>num\</code\>).\</li\>\n\<li\> Strings (\<code\>str\</code\>) that can act as templates with embedded expressions and statements. \</li\>\n\<li\> Source code locations (\<code\>loc\</code\>) based on an extension of Universal Resource Identifiers (URI) that allow precise description of text areas in local and remote files.\</li\>\n\<li\> Date and time values (\<code\>dateTime\</code\>).\</li\>\n\<li\> Lists (\<code\>list\</code\>).\</li\>\n\<li\> Tuples (\<code\>tuple\</code\>).\</li\>\n\<li\> Sets (\<code\>set\</code\>).\</li\>\n\<li\> Maps (\<code\>map\</code\>) \</li\>\n\<li\> Relations (\<code\>rel\</code\>). \</li\>\n\<li\> Untyped tree structures (\<code\>node\</code\>).  \</li\>\n\<li\> User-defined algebraic datatypes (\<code\>data\</code\>) allow the introduction of problem-specific types and are a subtype of node. This makes it possible to have typed\</li\>\n\<li\>:and untyped views on the same data. \</li\>\n\<li\>:A special case are syntax trees that are the result of parsing source files are represented \</li\>\n\<li\>:as datatypes (\<code\>Tree\</code\>).\<br/\>\n\<br/\>\nThere is a wealth of built-in operators and library functions available on the standard datatypes. \<br/\>\n\<br/\>\nThese builtin datatypes are closely related to each other:\</li\>\n\<li\> In a list all elements have the same static type and the order of elements matters. A list may contain the same value more than once.\</li\>\n\<li\> In a set all elements have the same static type and the order of elements does not matter.\</li\>\n\<li\>: A set contains an element only once. In other words, duplicate elements are eliminated \</li\>\n\<li\>: and no matter how many times an element is added to a set, it will occur in it only once.\</li\>\n\<li\> In a tuple alle elements (may) have a different static type. Each element of a tuple may have a label that can be used to select that element of the tuple.\</li\>\n\<li\> A relation is a set of tuples which all have the same static tuple type.\</li\>\n\<li\> A map is an associative table of (key, value) pairs. Key and value (may) have different static type and a key can only be associated with a value once.\</li\>\n\n\</ul\>\n","\nHere are some examples of the built-in data types:\n\<table\>\n\<colgroup\>\n\<col align=\"left\" span=\"2\"\>\n\<thead\>\n\<tr\>\<th\>_Type_\</th\> \<th\>_Examples_\</th\>\</tr\>\n\<tbody\>\n\<tr\>\<td\>\<code\>bool\</code\>\</td\>\t                   \<td\>\<code\>true\</code\>, \<code\>false\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>int\</code\>\</td\>\t                   \<td\>\<code\>11, 101, 1-11, 1123456789\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>real\</code\>\</td\>\t                   \<td\>\<code\>1.01, 11.0232e201, 1-25.5\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>str\</code\>\</td\>\t                   \<td\>\<code\>\"abc\"\</code\>, \<code\>\"first\\nnext\"\</code\>, \<code\>\"result: &lt;X\>\"\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>loc\</code\>\</td\>\t                    \<td\>\<code\>|file:///etc/passwd|\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>dateTime\</code\>\</td\>               \t\<td\>\<code\>$2101-09-05T07:16:19.714+0200\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>tuple[\<i\>T\</i\>1,...,\<i\>Tn\</i\>]\</code\>\t\t\t\</td\>\<td\>\<code\>&lt;1,2\>\</code\>, \<code\>&lt;\"john\", 43, true\>\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>list[\<i\>T\</i\>]\</code\>\</td\>\t            \<td\>\<code\>[]\</code\>, \<code\>[1]\</code\>, \<code\>[1,2,3]\</code\>, \<code\>[true, 2, \"abc\"]\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>set[\<i\>T\</i\>]\</code\>\</td\>\t            \t\<td\>\<code\>{}\</code\>, \<code\>{1,2,3,5,7}\</code\>, \<code\>{\"john\", 4.0}\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>rel[\<i\>T\</i\>1,...,\<i\>Tn\</i\>]\</code\>\</td\>    \t\<td\>\<code\>{&lt;1,2\>,&lt;2,3\>,&lt;1,3\>}\</code\>, \<code\>{&lt;1,10,100\>, &lt;2,20,200\>}\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>map[\<i\>T\</i\>, \<i\>U\</i\>]\</code\>\</td\>\t    \t\<td\>\<code\>()\</code\>, \<code\>(1:true, 2:false)\</code\>, \<code\>(\"a\":1, \"b\":2)\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>node\</code\>\</td\>\t                    \<td\>\<code\>f()\</code\>, \<code\>add(x,y)\</code\>, \<code\>g(\"abc\", [2,3,4])\</code\>\</td\>\</tr\>\n\</table\>\n\<br\>\nA fragment of the datatype that defines the abstract syntax for statements (assignment, if, while) in a programming language would look as follows:\n\n\<pre class=\"listing\"\>data STAT = asgStat(Id name, EXP exp)\n          | ifStat(EXP exp,list[STAT] thenpart,\n                           list[STAT] elsepart) \n          | whileStat(EXP exp, list[STAT] body)\n          ;\n\</pre\>","","",[]),"Rascal/EASY/Forensics":concept("Forensics",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/EASY/Forensics/Forensics.concept|,[],{"Example"},[],"\n",{},"_Bern_ is a senior software engineer working at the Berlin headquarters of a forensic investigation lab of the German government. His daily work is to find common patterns in files stored on digital media that have been confiscated during criminal investigations. Text, audio and video files are stored in zillions of different data formats and each data format requires its own analysis technique. For each new investigation ad hoc combinations of tools are used. This makes the process very labour-intensive and error-prone. Bernd convinces his manager that designing a new domain-specific language (DSL) for forensic investigations may relieve the pressure on their lab. After designing the DSL---let\'\\s call it DERRICK---he makes an EASY implementation for it. Given a DERRICK program for a specific case under investigation, he first extracts relevant information from it and analyzes it: which media formats are relevant? Which patterns to look for? How should search results be combined? Given this new information, Java code is synthesized that uses the various existing tools and combines their results.\n","\n","\n","\n",[]),"Rascal/Expressions/Values/Set/Product":concept("Product",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/Product/Product.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\> * \<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>set[\<i\>Type\</i\>]\</code\>\</li\>\n\n\</ul\>\n",{"*","set["},"Yields a relation resulting from the product of the values of \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\>\</code\> and \<code\>\<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>. It contains a tuple for each combination of values from both arguments.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3} &amp; {4, 5, 6};\nset[int]: {}\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:set[arb[int,str]]\> * \<B:same[A]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str()]))>,<"B",same("A")>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:set[arb]\> * \<B:same[A]\>","",false,false,[<"A",set(arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),loc(),dateTime()]))>,<"B",same("A")>],[],void(),"")),tvQuestion("3",valueOfExpr(),details("\n",[],"","","\<A:set[arb[0,int,str,num,real]]\> * \<B:same[A]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str(),num(-20,20),real(-20,20)]))>,<"B",same("A")>],[],void(),""))]),"Rascal/Expressions/Values/Number/Addition":concept("Addition",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/Addition/Addition.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\<sup\>num\</sup\> + \<i\>Exp\</i\>\<sub\>2\</sub\>\<sup\>num\</sup\>\</code\>\</li\>\n\<li\> Type: \<code\>int\</code\> or \<code\>real\</code\>\</li\>\n\n\</ul\>\n",{"+"},"Yields the numerical sum of the values of \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\> and \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>12 + 13\nint: 25\n\<b\>rascal\>\</b\>12 + 13.5\nreal: 25.5\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("Adding integers. \n",[],"","","\<A:int[0]\> + \<B:int[0]\>","",false,false,[<"A",int(0,20)>,<"B",int(0,20)>],[],void(),"")),tvQuestion("2",valueOfExpr(),details("Adding integers. \n",[],"","","\<A:int[0]\> + \<B:int[0]\> ","",false,false,[<"A",int(0,20)>,<"B",int(0,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("Adding integers and reals.\n",[],"","","\<A:int[0]\> + \<B:real[0]\>","",false,false,[<"A",int(0,20)>,<"B",real(0,20)>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",[],"","","\<A:int[0]\> + \<B:real[0]\> ","",false,false,[<"A",int(0,20)>,<"B",real(0,20)>],[],void(),"")),tvQuestion("5",valueOfExpr(),details("Use parentheses when addition and negative numbers interact.\n",[],"","","\<A:int\> + (\<B:int[-20,-1]\>)","",false,false,[<"A",int(-20,20)>,<"B",int(-20,-1)>],[],void(),"")),tvQuestion("6",valueOfExpr(),details("Use parentheses when addition and negative numbers interact.\n",[],"","","\<A\> + "," == \<C\>",false,true,[<"A",int(-20,20)>,<"B",int(0,10)>],[<"C","\<A\> - \<B\>">],void(),""))]),"Rascal/Expressions/Values/Set/reducer":concept("reducer",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/reducer/reducer.concept|,[],{"Library"},[],"Function: \<code\>&amp;T reducer(set[&amp;T] s, &amp;T (&amp;T, &amp;T) fn, &amp;T unit)\</code\>\n",{},"Apply the function \<code\>fn\</code\> to successive elements of set \<code\>s\</code\> starting with \<code\>unit\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>int add(int x, int y) { return x + y; }\nint (int, int): int add(int, int);\n\<b\>rascal\>\</b\>reducer({10, 20, 30, 40}, add, 0); \nint: 100\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Set/Intersection":concept("Intersection",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/Intersection/Intersection.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> &amp; \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>set[\<i\>Type\</i\>]\</code\>\</li\>\n\n\</ul\>\n",{"set[","&"},"If both \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\> and \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\> have a set as value, the result is the intersection of these two set values. If one of \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\> or \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\> does not have a set as value, it is first converted to a set before the intersection is computed.\n","\<warning\>&amp; seems to miss the case for a non-set argument\</warning\>\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3, 4, 5} &amp; {4, 5, 6};\nset[int]: {5,4}\n\<b\>rascal\>\</b\>{1, 2, 3} &amp; 4;\nStatic Error: prompt:///:1,0: intersection not supported on set[int] and int\n\<b\>rascal\>\</b\>1 &amp; {1, 2, 3, 4};\nStatic Error: prompt:///:1,0: intersection not supported on int and int\n\</pre\>","\n","\n",[choiceQuestion("1"," When you compute the intersection of two sets, the number of elements in the result is always:\n",[good("Smaller than or equal the number of elements in both sets."),bad("Greater than the number of elements in both sets."),bad("Greater than or equal the number of elements in both sets."),bad("Smaller than the number of elements in both sets.")]),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:set[arb[int,str]]\> & \<B:same[A]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str()]))>,<"B",same("A")>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:set[arb]\> & \<B:same[A]\>","",false,false,[<"A",set(arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),loc(),dateTime()]))>,<"B",same("A")>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",[],"","","\<A:set[arb[0,int,str,num,real]]\> & \<B:same[A]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str(),num(-20,20),real(-20,20)]))>,<"B",same("A")>],[],void(),""))]),"Rascal/Statements":concept("Statements",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Statements/Statements.concept|,[],{"Language"},[],"\n",{},"\n","\n","\n","\n",[]),"Rascal/Expressions/Values/Location":concept("Location",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Location/Location.concept|,[],{},[],"Type: \<code\>loc\</code\>\n",{"loc"},"\n","\n","\n","\n",[]),"Rascal/Expressions/Patterns/Regular":concept("Regular",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Patterns/Regular/Regular.concept|,[],{},[],"\n",{},"\nRegular expressions are used to match a string value and to decompose it in parts and also to compose new strings. Regular expression patterns bind variables of type \<code\>str\</code\> when the match succeeds, otherwise they do not bind anything. \nThey can occur in cases of visit and switch statements, \non the left-hand side of the match operator (\<code\>:=\</code\> or \<code\>!:=\</code\>) and as declarator in enumerators.\n\nWe use a regular expression language that slightly extends/modifies the Java Regex language:\n\n\<ul\>\n\<li\> Regular expression are delimited by \<code\>/\</code\> and \<code\>/\</code\> optionally followed by modifiers (see below).\</li\>\n\<li\> We allow _variable introductions_, syntax \<code\>&lt;\<i\>Name\</i\>:\<i\>Regex\</i\>\>\</code\>, which introduce a variable of type \<code\>str\</code\> named \<code\>\<i\>Name\</i\>\</code\>. A variable introduction corresponds to a group in a Java regexp. Each variable that is introduced should be unique, but may be referenced more than once later in the regular expression.\</li\>\n\<li\> Regular expressions may also contain _references to variables_, syntax \<code\>&lt;\<i\>Name\</i\>\>\</code\>, the string value of variable \<code\>\<i\>Name\</i\>\</code\> is used at the position of the variable reference.  This can be used to define so-called _non-linear_ patterns.\</li\>\n\<li\> Java regular expressions allow optional groups, which may introduce null bindings. Since uninitialized variables are not allowed in Rascal, we limit the kinds of expressions one can write here by not allowing nesting of variable introductions.\</li\>\n\<li\> We allow variable references in a regular expression of the form: \<code\>&lt;\<i\>Name\</i\>\>\</code\> which inserts the string value of \<code\>\<i\>Name\</i\>\</code\> in the pattern. \<code\>\<i\>Name\</i\>\</code\> should have been introduced in the regular experession itself or in the context in which the regular expression occurs.\</li\>\n\<li\> In Perl matching options _follow_ the regular expression, but Java uses the notation \<code\>(?Option)\</code\>  at the _beginning_ of the regular expression to set matching options. We support both styles.  The following modifiers are supported:\</li\>\n\<ul\>\n\<li\>_multi-line matching_: \<code\>(?m)\</code\> at the start of the regular expression or the modifier \<code\>m\</code\> at the end of the regular expression. The anchors \<code\>^\</code\> and \<code\>$\</code\> usually only match at the beginning and end of the subject string. When this option is set they also match any begin or end of line that is embedded in the subject string. Examples:\</li\>\n\<li\>_case-insensitive matching_: \<code\>(?i)\</code\> or modifier \<code\>i\</code\>. Match characters irrespective of their case.\</li\>\n\<li\>_single-line mode_: \<code\>(?s)\</code\> or modifer \<code\>s\</code\>. The \<code\>.\</code\> expression does usually not match line terminators. When single-line mode is set, it will match any character including line terminators.\</li\>\n\<li\>_unix lines_: \<code\>(?d)\</code\> or modifier \<code\>d\</code\>. Usually newlines (\<code\>\\n\</code\>), carriage return (\<code\>\\r\</code\>) and new line carriage return (\<code\>\\n\\r\</code\>) sequences are all considered line terminators. When this option is set, only newline is considered to be a line terminator.\</li\>\n\n\</ul\>\n\n\</ul\>\nFor convenience, we summarize the most frequently used constructs in regular expressions in the following table.\n\n\<table\>\n\<caption\>Frequently used elements of Regular Expression Syntax\</caption\>\n\n\<tr\>\<th align=\"left\"\>Operator\</th\>\t\<th align=\"left\"\>Description\</th\>\</tr\>\n\<tr\>\<td\>\<code\>x\</code\>\</td\>               \<td\>The single character \<code\>x\</code\> as long as it is not a punctuation character with a \n                                                        special meaning in the regular expression syntax\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\p\</code\>\</td\>              \<td\>The punctuation character \<code\>p\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\\\\</code\>\</td\>              \<td\>The backslah character\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\n\</code\>\</td\>              \<td\> Newline character\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\t\</code\>\</td\>               \<td\> Tab character\</td\>\</tr\>\n\<tr\>\<td\>\<code\>[...]\</code\>\</td\>             \<td\> One of the characters between the brackets (also known as _character class_). \n                                                         Character ranges and set operations on character classes may be used.\</td\>\</tr\>\n\<tr\>\<td\>\<code\>[^...]\</code\>\</td\>           \<td\> Any one character not between the brackets.\</td\>\</tr\>\n\<tr\>\<td\>\<code\>[a-z0-9]\</code\>  \</td\>  \<td\> Character range: character between \<code\>a\</code\> and \<code\>z\</code\> or \<code\>0\</code\> and \<code\>9\</code\>.\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\d\</code\>\</td\>              \<td\> Digit: \<code\>[0-9]\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\D\</code\>\</td\>              \<td\> Non-digit:\<code\> [^0-9]\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\s\</code\>\</td\>               \<td\> Whitespace\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\S\</code\>\</td\>               \<td\> Anything but whitespace.\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\w\</code\>\</td\>               \<td\> A word: \<code\>[a-zA-Z0-9_]\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\W\</code\>\</td\>              \<td\> A non-word:\<code\> [^\\w]\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>xy\</code\>\</td\>                \<td\> Match \<code\>x\</code\> followed by \<code\>y\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>x|y\</code\>\</td\>              \<td\> Match \<code\>x\</code\> or \<code\>y\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>x?\</code\>\</td\>               \<td\> Optional occurrence of \<code\>x\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>x*\</code\>\</td\>               \<td\> Zero or more occurrences of \<code\>x\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>x+\</code\>\</td\>              \<td\>\tOne or more occurrences of \<code\>x\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>x{n}\</code\>\</td\>            \<td\>\tExactly \<code\>n\</code\> occurrences of \<code\>x\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>x{n,}\</code\>\</td\>           \<td\>\t\<code\>n\</code\> or more occurrences of \<code\>x\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>x{n,m}\</code\>\</td\>        \<td\>\tAt least \<code\>n\</code\>, at most \<code\>m\</code\> occurrences of \<code\>x\</code\>\</td\>\</tr\>\n\<tr\>\<td\>\<code\>^\</code\>\</td\>                \<td\>\tThe beginning of the subject string\</td\>\</tr\>\n\<tr\>\<td\>\<code\>$\</code\>\</td\>                \<td\>\tThe end of the input string\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\b\</code\>\</td\>              \<td\>\tWord boundary: position between a word and a non-word character\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\\B\</code\>\</td\>              \<td\>\tNon-word boundary: position that is a not a word boundary\</td\>\</tr\>\n\</table\>\n","\nHere are some examples of regular expression patterns.\n\<pre class=\"listing\"\>/\\brascal\\b/i\n\</pre\>does a case-insensitive match (\<code\>i\</code\>) of the word \<code\>rascal\</code\> between word boundaries (\<code\>\\b\</code\>). And\n\<pre class=\"listing\"\>/^.*?&lt;word:\\w+\>&lt;rest:.*$\>/m\n\</pre\>does a multi-line match (\<code\>m\</code\>), matches the first consecutive word characters (\<code\>\\w\</code\>) and assigns them to the variable \<code\>word\</code\>. The remainder of the string is assigned to the variable \<code\>rest\</code\>. \n\<br/\>\n\<br/\>\nA variable reference used to make a non-linear pattern:\n\<pre class=\"listing\"\>/&lt;x:[a-z]+\>---&lt;x\>/\n\</pre\>matches strings like \<code\>abc---abc\</code\> that consist of two identical sequences of letters separated \nby three dashes. Variables that are referenced in a regular expression may also come from \nthe context in which the regular expression occurs. For instance,\n\<pre class=\"listing\"\>/&lt;x\>&lt;n\>/\n\</pre\>will use the current values of \<code\>x\</code\> and \<code\>n\</code\> as regular expression. For values \<code\>\"abc\"\</code\>, respectively, \<code\>3\</code\> this would be equivalent to the regular expression:\n\<pre class=\"listing\"\>/abc3/\n\</pre\>Observe that context variables may be of arbitrary type and that their value is first converted to \na string before it is inserted in the regular expression. This can be used in many ways. \nFor instance, regular expressions may contain restrictions on the number of repetitions \nof an element: \<code\>/a{3}/\</code\> will match exactly three letters a. Also minimum and maximum \nnumber of occurrences can be defined. \nHere is how the repetition count can be inserted by a variable reference \n(where \<code\>n\</code\> is assumed to have an integer value):\n\n\<pre class=\"listing\"\>/a{&lt;n\>}/\n\</pre\>Taking this example one step further, we can even write\n\n\<pre class=\"listing\"\>/&lt;x:a{&lt;n\>}\>/\n\</pre\>in other words, we introduce variable \<code\>x\</code\> and its defining regular expression contains a \nreference to a context variable.\n\<br/\>\n\<br/\>\nMulti-line matching:\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>/XX$/ := &quot;lineoneXX\\nlinetwo&quot;;\nbool: false\n\<b\>rascal\>\</b\>/XX$/m := &quot;lineoneXX\\nlinetwo&quot;;\nbool: true\n\<b\>rascal\>\</b\>/(?m)XX$/ := &quot;lineoneXX\\nlinetwo&quot;;\nbool: true\n\</pre\>\nCase-insensitive matching:\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>/XX/ := &quot;some xx&quot;;\nbool: false\n\<b\>rascal\>\</b\>/XX/i := &quot;some xx&quot;;\nbool: true\n\<b\>rascal\>\</b\>/(?i)XX/ := &quot;some xx&quot;;\nbool: true\n\</pre\>\nSingle-line mode:\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>/a.c/ := &quot;abc&quot;;\nbool: true\n\<b\>rascal\>\</b\>/a.c/ := &quot;a\\nc&quot;;\nbool: false\n\<b\>rascal\>\</b\>/a.c/s := &quot;a\\nc&quot;;\nbool: true\n\<b\>rascal\>\</b\>/(?s)a.c/ := &quot;a\\nc&quot;;\nbool: true\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Set/Superset":concept("Superset",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/Superset/Superset.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\> \>= \<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"\>=","bool"},"Yields \<code\>true\</code\> if the vaue of \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\>\</code\> is a superset of the value of \<code\>\<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\> and \<code\>false\</code\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3, 4} &gt;= {3, 2, 1};\nbool: true\n\<b\>rascal\>\</b\>{1, 2, 3, 4} &gt;= {4, 3, 2, 1};\nbool: true\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:set[arb]\> \>= \<B:same[A]\>","",false,false,[<"A",set(arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),loc(),dateTime()]))>,<"B",same("A")>],[],void(),""))]),"Rascal/Concepts/ImmutableValues":concept("ImmutableValues",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/ImmutableValues/ImmutableValues.concept|,[],{},[],"\n",{},"Values are the basic building blocks of a language and the type of values determines how they may be used.\n\nRascal is a value-oriented language. This means that values are immutable and are always freshly constructed from existing parts and that sharing and aliasing problems are completely avoided. The language also provides variables. A value can be associated with a variable as the result of an explicit assignment statement: during the lifetime of a variable different (immutable) values may be assignment to it. Other ways to associate a value with a variable is by way of function calls (binding of formal parameters to actual values) and as the result of a successful pattern match.\n","\n","\n","\n",[]),"Rascal/Expressions/Values/Set/power":concept("power",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/power/power.concept|,[],{"Library"},[],"Function: \<code\>set[set[&amp;T]] power(set[&amp;T] s)\</code\>\n",{},"Returns a set with all subsets of \<code\>s\</code\>.\n","\<warning\> Break long output lines \</warning\>\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>power({1,2,3,4});\nset[set[int]]: {{4,2,1},{4,3},{4,2},{4,3,1},{4,1},{4,3,2},{4},{4,3,2,1},{3},{2,1},{3,1},{2},{3,2},{1},{3,2,1},{}}\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Set/isEmpty":concept("isEmpty",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/isEmpty/isEmpty.concept|,[],{"Library"},[],"Function: \<code\>bool isEmpty(set[&amp;T] s)\</code\>\n",{},"Yields \<code\>true\</code\> if \<code\>s\</code\> is empty, and \<code\>false\</code\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>isEmpty({1, 2, 3});\nbool: false\n\<b\>rascal\>\</b\>isEmpty({});\nbool: true\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Number/toInt":concept("toInt",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/toInt/toInt.concept|,[],{"Library"},[],"Function: \<code\>int toInt(num n)\</code\>\n",{},"\nConvert a number to an integer. If \<code\>n\</code\> is an integer, this is the identity. If \<code\>n\</code\> is a real value (implemented as BigDecimal) to an integer (implemented as BigInteger). This conversion is analogous to a narrowing primitive conversion from double to long as defined in the Java Language Specification: any fractional part of this BigDecimal will be discarded. Note that this conversion can loose information about the precision of the BigDecimal value.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Number;\nok\n\<b\>rascal\>\</b\>toInt(13)\nint: 13\n\<b\>rascal\>\</b\>toInt(13.5)\nint: 13\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Number/abs":concept("abs",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/abs/abs.concept|,[],{"Library"},[],"Function: \<code\>&amp;T &lt;: num abs(&amp;T &lt;: num n)\</code\>\n",{},"Absolute value of the number \<tt\>n\</tt\>. The result type is equal to the type of the argument \<tt\>n\</tt\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Number;\nok\n\<b\>rascal\>\</b\>abs(13)\nint: 13\n\<b\>rascal\>\</b\>abs(-13)\nint: 13\n\<b\>rascal\>\</b\>abs(3.14)\nreal: 3.14\n\<b\>rascal\>\</b\>abs(-3.14)\nreal: 3.14\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",["import Number;"],"","","abs(\<A:int\>)","",false,false,[<"A",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",["import Number;"],"","","abs(\<A:real\>)","",false,false,[<"A",real(-20,20)>],[],void(),"")),tvQuestion("3",valueOfExpr(),details("\n",["import Number;"],"","","abs(\<A:int[-20,-1]\>)","",false,false,[<"A",int(-20,-1)>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",["import Number;"],"","","abs(\<A:real[-20,-1]\>)","",false,false,[<"A",real(-20,-1)>],[],void(),""))]),"Rascal/Expressions/Values/Set/Difference":concept("Difference",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/Difference/Difference.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> - \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>set[\<i\>Type\</i\>\<sub\>1\</sub\>]\</code\> x \<code\>set[\<i\>Type\</i\>\<sub\>2\</sub\>]\</code\> -\> \<code\>set[lub(\<i\>Type\</i\>\<sub\>1\</sub\>,\<i\>Type\</i\>\<sub\>2\</sub\>)]\</code\>\</li\>\n\<li\> Type: \<code\>\<i\>Type\</i\>\<sub\>1\</sub\>  \</code\> x \<code\>set[\<i\>Type\</i\>\<sub\>2\</sub\>]\</code\> -\> \<code\>set[lub(\<i\>Type\</i\>\<sub\>1\</sub\>,\<i\>Type\</i\>\<sub\>2\</sub\>)]\</code\>\</li\>\n\<li\> Type: \<code\>set[\<i\>Type\</i\>\<sub\>1\</sub\>]\</code\> x \<code\>\<i\>Type\</i\>\<sub\>2\</sub\>\</code\> -\> \<code\>set[lub(\<i\>Type\</i\>\<sub\>1\</sub\>,\<i\>Type\</i\>\<sub\>2\</sub\>)]\</code\>\</li\>\n\n\</ul\>\n",{"-"},"If both \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\> and \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\> have a set as value, the result is the difference of these two set values. If one of \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\> or \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\> does not have a set as value, it is first converted to a set before the difference is computed.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3, 4} - {1, 2, 3};\nset[int]: {4}\n\<b\>rascal\>\</b\>{1, 2, 3, 4} - {3};\nset[int]: {4,2,1}\n\<b\>rascal\>\</b\>{1, 2, 3, 4} - 3;\nset[int]: {4,2,1}\n\<b\>rascal\>\</b\>{1, 2, 3, 4} - {5, 6, 7};\nset[int]: {4,3,2,1}\n\</pre\>","\n","\n",[choiceQuestion("1"," When you compute the difference of two sets, the number of elements in the result is always:\n",[good("Smaller than or equal the number of elements in the first set."),bad("Greater than the number of elements in both sets."),bad("Greater than or equal the number of elements in the first set."),bad("Smaller than the number of elements in both sets.")]),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:set[arb[int,str]]\> + \<B:same[A]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str()]))>,<"B",same("A")>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:set[arb]\> - \<A:same[A]\>","",false,false,[<"A",set(arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),loc(),dateTime()]))>,<"A",same("A")>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",[],"","","\<A:set[arb[0,int,str,num,real]]\> - \<B:same[A]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str(),num(-20,20),real(-20,20)]))>,<"B",same("A")>],[],void(),""))]),"Rascal/Concepts/CaseDistinction":concept("CaseDistinction",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/CaseDistinction/CaseDistinction.concept|,[],{},[],"\n",{},"\nThe switch statement as known from C and Java is generalized: the subject value to switch on may be an \narbitrary value and the cases are arbitrary patterns followed by a statement. \nEach case is comparable to a _transaction_: when the pattern succeeds and the following statement is \nexecuted successfully, all changes to variables made by the statement are committed and thus become permanent. \nThe variables bound by the pattern are always local to the statement associated with the case. \nWhen a match fails or when the associated statement fails, a _rollback_ takes place and all side-effects are undone. \nExternal side-effects like I/O and side-effects in user-defined Java code are not undone. \n","Here is an example where we take a program \<code\>P\</code\> and distinguish two cases for while and if statement:\n\<pre class=\"listing\"\>switch (P){\ncase whileStat(_, _):\n     println(\"A while statement\");\ncase ifStat(_, _, _):\n     println(\"An if statement\");\n}\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Patterns/Concrete":concept("Concrete",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Patterns/Concrete/Concrete.concept|,[],{},[],"\n",{},"\nSuppose we want to manipulate text written in some hypothetical language LANG. \nThen first the concrete syntax of LANG has to be defined by importing an SDF module that declares the non-terminals and syntax rules for LANG. \nNext LANG programs have to be parsed. LANG programs made come from text files or they may be included in the Rascal program as literals. \nIn both cases the text is parsed according to the defined syntax and the result is a parse tree in the form of a value of type Tree. \nConcrete patterns operate on these trees.\n\nA _concrete pattern_ is a quoted concrete syntax fragment that may contain variables. The syntax that is used to parse the concrete pattern may come from any SDF module that has been imported in the module in which the concrete pattern occurs.\n\nA concrete pattern may have the following forms:\n\n\<ul\>\n\<li\> _Quoted pattern_ \<listing\> ` \<code\>\<i\>Token\</i\>\<sub\>1\</sub\>\</code\> \<code\>\<i\>Token\</i\>\<sub\>2\</sub\>\</code\> ... \<code\>\<i\>Token\</i\>\<sub\>n\</sub\>\</code\> ` \</listing\> Inside a quoted pattern arbitrary lexical tokens may occur. Quoted patterns may contain variable declaration patterns and variable patterns (see below).\</li\>\n\<li\> A_ typed quoted pattern_ \<listing\> (\<code\>\<i\>Symbol\</i\>\</code\>) ` \<code\>\<i\>Token\</i\>\<sub\>1\</sub\>\</code\> \<code\>\<i\>Token\</i\>\<sub\>2\</sub\>\</code\> ... \<code\>\<i\>Token\</i\>\<sub\>n\</sub\>\</code\> ` \</listing\> is a quoted pattern that is preceded by an SDF symbol to define its desired syntactic type.\</li\>\n\<li\> A _typed variable pattern_ \<listing\> \<$Type$ $Var$\> \<listing\>\</li\>\n\<li\> A _variable pattern_ \</listing\> \<$Var$\> \</listing\>\</li\>\n\n\</ul\>\nInside concrete syntax patterns, layout is ignored.\n","Examples (in a context where an SDF module has been imported that defines the appropriate syntax):\n\n\<ul\>\n\<li\> Quoted syntax pattern with two pattern variable declarations: \<listing\> \<code\> while &lt;EXP Exp\> do &lt;{STATEMENT \";\"}* Stats\> od \</code\> \</listing\> Two observations can be made about this example:\</li\>\n\<ul\>\n\<li\>The non-terminals (sorts in SDF parlance) \<code\>\<i\>EXP\</i\>\</code\> and ${STATEMENT \";\"}*$ are declared in the imported SDF module and can be used  as types in the Rascal program.\</li\>\n\<li\> When this pattern is matched successfully against a subject, the variables \<code\>\<i\>Exp\</i\>\</code\> and \<code\>\<i\>Stats\</i\>\</code\> will be bound.\</li\>\n\n\</ul\>\n\<li\> Quoted syntax pattern with two pattern variable uses (\<code\>\<i\>Exp\</i\>\</code\> and \<code\>\<i\>Stats\</i\>\</code\> should already have a value): \<listing\> ` while \<Exp\> do \<Stats\> od ` \</listing\>\</li\>\n\<li\> Identical to the previous example, but with a declaration of the desired syntactic type: \<listing\> STATEMENT ` while \<Exp\> do \<Stats\> od ` \</listing\>\</li\>\n\n\</ul\>\n","\n","\n",[]),"Rascal/Expressions/Values/Number/Negation":concept("Negation",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/Negation/Negation.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>- \<i\>NumExp\</i\>\</code\>\</li\>\n\<li\> Type: \<code\>int\</code\> or \<code\>real\</code\>\</li\>\n\n\</ul\>\n",{"-"},"Yields the negated values of \<code\>\<i\>NumExp\</i\>\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>-12\nint: -12\n\<b\>rascal\>\</b\>-13.5\nreal: -13.5\n\<b\>rascal\>\</b\>- -12\nint: 12\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","-\<A:int\>","",false,false,[<"A",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","-\<A:real\>","",false,false,[<"A",real(-20,20)>],[],void(),"")),tvQuestion("3",valueOfExpr(),details("\n",[],"","","-\<A:num\>","",false,false,[<"A",num(-20,20)>],[],void(),""))]),"Rascal/Expressions/Operators":concept("Operators",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Operators/Operators.concept|,[],{},[],"\n",{},"\nAn _operator expression_ consists of an operator and one or more operands. The evaluation order of the operands depends on the operator. \nThe operator is applied to the operands and the resulting value (or values in some cases) is the result of the operator expression. \n\nAll operators are summarized in the following table. They are listed from highest precendence\n to lowest precedence. In other words, operators listed earlier in the table bind stronger.\n\<br/\>\n\<br/\>\n\<table width=\"100%\"\>\n\<caption\>__Rascal Operators (from highest to lowest precedence)__\</caption\>\n\<col align=left width=\"30%\"\>\n\<col align=left width=\"30%\"\>\n\<col align=left width=\"40%\"\>\n\n\<tr\>\<th align=\"left\"\>Operator\</th\>\t                   \<th align=\"left\"\>See\</th\>\t               \<th align=\"left\"\>Short Description\</th\>\</tr\>\n  \n\<tr\>\<td\>\<code\>\<i\>Exp\</i\> . \<i\>Name\</i\>\</code\>\</td\>\t                   \<td\>\<a href=\"/show?concept=FieldSelection\"\>FieldSelection\</a\>\</td\>                 \<td\>Select named field from structured value\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> [ \<i\>Name\</i\> = \<i\>Exp\</i\>\<sub\>2\</sub\> ]\</code\>\</td\>     \<td\>\<a href=\"/show?concept=FieldAssignment\"\>FieldAssignment\</a\>\</td\>             \<td\>Change value of named field of structured value\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\> &lt; \<i\>field\</i\>\<sub\>1\</sub\>, ... \>\</code\>\</td\>               \<td\>\<a href=\"/show?concept=FieldProjection\"\>FieldProjection\</a\>\</td\>                \<td\>Select fields from relation or structured value\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> [ \<i\>Exp\</i\>\<sub\>2\</sub\> , \<i\>Exp\</i\>\<sub\>3\</sub\>, .... ]\</code\>\</td\> \<td\>\<a href=\"/show?concept=Subscription\"\>Subscription\</a\>\</td\>                    \<td\>Retrieve values for given index from list, tuple or relation.\</td\>\</tr\>\n\n\<tr\>\<td\> \<code\>\<i\>Exp\</i\>?\</code\>\</td\>                                        \<td\>\<a href=\"/show?concept=Boolean/IsDefined\"\>Boolean/IsDefined\</a\>\</td\>          \<td\>Test whether an expression has a defined value\</td\>\</tr\>\n\n\<tr\>\<td\> \<code\>!\<i\>Exp\</i\>\</code\>\</td\>                                          \<td\>\<a href=\"/show?concept=Boolean/Negation\"\>Boolean/Negation\</a\>\</td\>           \<td\>Negate a Boolean value\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>- \<i\>Exp\</i\>\</code\>\</td\>                                        \<td\>\<a href=\"/show?concept=Integer/Negation\"\>Integer/Negation\</a\>,\n                                                                                            \<a href=\"/show?concept=Real/Negation\"\>Real/Negation\</a\>,\n                                                                                            \<a href=\"/show?concept=Number/Negation\"\>Number/Negation\</a\>\</td\>\t       \<td\>Negation of integer, real or number\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\> +\</code\>\</td\>\t                                   \<td\>Transitive closure\</td\>\t       \<td\>Transitive closure on relation\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\> *\</code\>\</td\>                                        \<td\>Reflexive transitive closure\</td\>\n                                                                                                                                               \<td\>Reflexive transitive closure on relation\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\> @ \<i\>Name\</i\>\</code\>\</td\>\t                   \<td\>Annotation selection\</td\>\t       \<td\>Value of annotation \<code\>\<i\>Name\</i\>\</code\> of \<code\>\<i\>Exp\</i\>\</code\>\'\\s value\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> [@ \<i\>Name\</i\> = \<i\>Exp\</i\>\<sub\>2\</sub\>]\</code\>\</td\>\t   \<td\>Annotation replacement\</td\>   \<td\>Assign value of \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\> to annotation \<code\>\<i\>Name\</i\>\</code\> of \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\>\'\\s \n                                                                                                                                                        value\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> o \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>Composition\</td\>\t               \<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\> and \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\> should evaluate to a relation; \n                                                                                                                                                         return their composition. Note: the letter \"o\" is thus a\n                                                                                                                                                          keyword!\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> x \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>CarthesianProduct\</td\>\t        \<td\>Carthesian product of two relations\</td\>\</tr\>\n\<br/\>\n\<br/\>\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> / \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>\<a href=\"/show?concept=Integer/Division\"\>Integer/Division\</a\>,\n                                                                                                \<a href=\"/show?concept=Real/Division\"\>Real/Division\</a\>,\n                                                                                                \<a href=\"/show?concept=Number/Division\"\>Number/Division\</a\>\</td\>\t        \<td\>Divide two integers, reals or numbers\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> % \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>\<a href=\"/show?concept=Integer/Modulo\"\>Integer/Modulo\</a\>\</td\>\t        \<td\>Modulo on integers\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> * \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>\<a href=\"/show?concept=Integer/Multiplication\"\>Integer/Multiplication\</a\>,\n                                                                                                 \<a href=\"/show?concept=Real/Multiplication\"\>Real/Multiplication\</a\>,\n                                                                                                 \<a href=\"/show?concept=Number/Multiplication\"\>Number/Multiplication\</a\>,\n                                                                                                 \<a href=\"/show?concept=List/Product\"\>List/Product\</a\>,\n                                                                                                 \<a href=\"/show?concept=Set/Product\"\>Set/Product\</a\>,\n                                                                                                 \<a href=\"/show?concept=Relation/Product\"\>Relation/Product\</a\>\</td\>\t\<td\>Multiply integers, reals or number; product of list, set, or relation\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> &amp; \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>                        \<td\>\<a href=\"/show?concept=List/Intersection\"\>List/Intersection\</a\>,\n                                                                                                  \<a href=\"/show?concept=Set/Intersection\"\>Set/Intersection\</a\>,\n                                                                                                  \<a href=\"/show?concept=Map/Intersection\"\>Map/Intersection\</a\>,\n                                                                                                  \<a href=\"/show?concept=Relation/Intersection\"\>Relation/Intersection\</a\>\</td\>\<td\>Intersection of list, set, map or relation\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> + \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>\<a href=\"/show?concept=Integer/Addition\"\>Integer/Addition\</a\>,\n                                                                                                 \<a href=\"/show?concept=Real/Addition\"\>Real/Addition\</a\>,\n                                                                                                 \<a href=\"/show?concept=Number/Addition\"\>Number/Addition\</a\>,\n                                                                                                 \<a href=\"/show?concept=String/Concatenate\"\>String/Concatenate\</a\>,\n                                                                                                 \<a href=\"/show?concept=List/Concatenate\"\>List/Concatenate\</a\>,\n                                                                                                 \<a href=\"/show?concept=Tuple/Concatenate\"\>Tuple/Concatenate\</a\>,\n                                                                                                 \<a href=\"/show?concept=Set/Union\"\>Set/Union\</a\>,\n                                                                                                 \<a href=\"/show?concept=Map/Union\"\>Map/Union\</a\>,\n                                                                                                 \<a href=\"/show?concept=Relation/Union\"\>Relation/Union\</a\>\</td\>           \<td\> Add integer, real or number; concatenate string, list or tuple; \n                                                                                                                                                             union on set, map, or relation\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> - \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>                         \<td\>\<a href=\"/show?concept=Integer/Subtraction\"\>Integer/Subtraction\</a\>,\n                                                                                                 \<a href=\"/show?concept=Real/Subtraction\"\>Real/Subtraction\</a\>,\n                                                                                                 \<a href=\"/show?concept=Number/Subtraction\"\>Number/Subtraction\</a\>,\n                                                                                                 \n                                                                                                 \<a href=\"/show?concept=List/Difference\"\>List/Difference\</a\>,\n                                                                                                \n                                                                                                 \<a href=\"/show?concept=Set/Difference\"\>Set/Difference\</a\>,\n                                                                                                 \<a href=\"/show?concept=Map/Difference\"\>Map/Difference\</a\>,\n                                                                                                 \<a href=\"/show?concept=Relation/Difference\"\>Relation/Difference\</a\>\</td\>\t\<td\>Subtract integer, real or number; difference of list, set, map,\n                                                                                                                                                                         or relation\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> join \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>\<a href=\"/show?concept=Relation/Join\"\>Relation/Join\</a\>\</td\>                                        \<td\>Join on relation\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> in \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>ElementOf\</td\>                         \<td\>Membership test for element in  list, map, set or relation\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> notin \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t           \<td\>NotElementOf\</td\>                   \<td\>Negated membership test for element in  list, map, set or relation\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> &lt;= \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>\<a href=\"/show?concept=Integer/LessThanOrEqual\"\>Integer/LessThanOrEqual\</a\>, \<a href=\"/show?concept=Real/LessThanOrEqual\"\>Real/LessThanOrEqual\</a\>,\<a href=\"/show?concept=Number/LessThanOrEqual\"\>Number/LessThanOrEqual\</a\>,\n                                                                                              \<a href=\"/show?concept=String/LessThanOrEqual\"\>String/LessThanOrEqual\</a\>, \<a href=\"/show?concept=Location/LessThanOrEqual\"\>Location/LessThanOrEqual\</a\>, \<a href=\"/show?concept=DateTime/LessThanOrEqual\"\>DateTime/LessThanOrEqual\</a\>,\n                                                                                              \<a href=\"/show?concept=List/SubList\"\>List/SubList\</a\>, \<a href=\"/show?concept=Set/SubSet\"\>Set/SubSet\</a\>, \<a href=\"/show?concept=Map/SubSet\"\>Map/SubSet\</a\>, \<a href=\"/show?concept=Relation/Subset\"\>Relation/Subset\</a\>\</td\>\n                                                                                                                                              \<td\>Less than or equal on all values\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> &lt; \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                    \<td\>\<a href=\"/show?concept=Integer/LessThan\"\>Integer/LessThan\</a\>, \<a href=\"/show?concept=Real/LessThan\"\>Real/LessThan\</a\>,\<a href=\"/show?concept=Number/LessThan\"\>Number/LessThan\</a\>,\n                                                                                              \<a href=\"/show?concept=String/LessThan\"\>String/LessThan\</a\>, \<a href=\"/show?concept=Location/LessThan\"\>Location/LessThan\</a\>, \<a href=\"/show?concept=DateTime/LessThan\"\>DateTime/LessThan\</a\>,\n                                                                                              \<a href=\"/show?concept=List/StrictSubList\"\>List/StrictSubList\</a\>, \<a href=\"/show?concept=Set/StrictSubSet\"\>Set/StrictSubSet\</a\>, \<a href=\"/show?concept=Map/StrictSubSet\"\>Map/StrictSubSet\</a\>, \<a href=\"/show?concept=Relation/StrictSubset\"\>Relation/StrictSubset\</a\>\</td\>\n                                                                                                                                              \<td\>Less than on all values\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> \>= \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                    \<td\>\<a href=\"/show?concept=Integer/GreaterThanOrEqual\"\>Integer/GreaterThanOrEqual\</a\>, \<a href=\"/show?concept=Real/GreaterThanOrEqual\"\>Real/GreaterThanOrEqual\</a\>,\<a href=\"/show?concept=Number/GreaterThanOrEqual\"\>Number/GreaterThanOrEqual\</a\>,\n                                                                                              \<a href=\"/show?concept=String/GreaterThanOrEqual\"\>String/GreaterThanOrEqual\</a\>, \<a href=\"/show?concept=Location/GreaterThanOrEqual\"\>Location/GreaterThanOrEqual\</a\>, \<a href=\"/show?concept=DateTime/GreaterThanOrEqual\"\>DateTime/GreaterThanOrEqual\</a\>,\n                                                                                              \<a href=\"/show?concept=List/SuperList\"\>List/SuperList\</a\>, \<a href=\"/show?concept=Set/SuperSet\"\>Set/SuperSet\</a\>, \<a href=\"/show?concept=Map/SuperSet\"\>Map/SuperSet\</a\>, \<a href=\"/show?concept=Relation/Superset\"\>Relation/Superset\</a\>\</td\>\n                                                                                                                                              \<td\>Greater than or equal on all values\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> \> \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>\<a href=\"/show?concept=Integer/GreaterThan\"\>Integer/GreaterThan\</a\>, \<a href=\"/show?concept=Real/GreaterThan\"\>Real/GreaterThan\</a\>,\<a href=\"/show?concept=Number/GreaterThan\"\>Number/GreaterThan\</a\>,\n                                                                                              \<a href=\"/show?concept=String/GreaterThan\"\>String/GreaterThan\</a\>, \<a href=\"/show?concept=Location/GreaterThan\"\>Location/GreaterThan\</a\>, \<a href=\"/show?concept=DateTime/GreaterThan\"\>DateTime/GreaterThan\</a\>,\n                                                                                              \<a href=\"/show?concept=List/StrictSuperList\"\>List/StrictSuperList\</a\>, \<a href=\"/show?concept=Set/StrictSuperSet\"\>Set/StrictSuperSet\</a\>, \<a href=\"/show?concept=Map/StrictSuperSet\"\>Map/StrictSuperSet\</a\>, \<a href=\"/show?concept=Relation/StrictSuperset\"\>Relation/StrictSuperset\</a\>\</td\>\n                                                                                                                                              \<td\>Greater than on all values.\</td\>\</tr\>\n\n\<tr\>\<td\> \<code\>\<i\>Pat\</i\> := \<i\>Exp\</i\>\</code\>\</td\>                           \<td\>Match\</td\>                             \<td\>Pattern matches value of expression\</td\>\</tr\>\n\n\<tr\>\<td\> \<code\>\<i\>Pat\</i\> !:= \<i\>Exp\</i\>\</code\>\</td\>                          \<td\>NoMatch\</td\>                         \<td\>Pattern does not match value of expression\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> == \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>\<a href=\"/show?concept=Integer/Equal\"\>Integer/Equal\</a\>, \<a href=\"/show?concept=Real/Equal\"\>Real/Equal\</a\>,\<a href=\"/show?concept=Number/Equal\"\>Number/Equal\</a\>,\n                                                                                              \<a href=\"/show?concept=String/Equal\"\>String/Equal\</a\>, \<a href=\"/show?concept=Location/Equal\"\>Location/Equal\</a\>, \<a href=\"/show?concept=DateTime/Equal\"\>DateTime/Equal\</a\>,\n                                                                                              \<a href=\"/show?concept=List/Equal\"\>List/Equal\</a\>, \<a href=\"/show?concept=Set/Equal\"\>Set/Equal\</a\>, \<a href=\"/show?concept=Map/Equal\"\>Map/Equal\</a\>, \<a href=\"/show?concept=Relation/Equal\"\>Relation/Equal\</a\>\</td\>\n                                                                                                                                              \<td\>Equality on all values\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> != \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>\t                   \<td\>\<a href=\"/show?concept=Integer/NotEqual\"\>Integer/NotEqual\</a\>, \<a href=\"/show?concept=Real/NotEqual\"\>Real/NotEqual\</a\>,\<a href=\"/show?concept=Number/NotEqual\"\>Number/NotEqual\</a\>,\n                                                                                              \<a href=\"/show?concept=String/NotEqual\"\>String/NotEqual\</a\>, \<a href=\"/show?concept=Location/NotEqual\"\>Location/NotEqual\</a\>, \<a href=\"/show?concept=DateTime/NotEqual\"\>DateTime/NotEqual\</a\>,\n                                                                                              \<a href=\"/show?concept=List/NotEqual\"\>List/NotEqual\</a\>, \<a href=\"/show?concept=Set/NotEqual\"\>Set/NotEqual\</a\>, \<a href=\"/show?concept=Map/NotEqual\"\>Map/NotEqual\</a\>, \<a href=\"/show?concept=Relation/NotEqual\"\>Relation/NotEqual\</a\>\</td\>\n                                                                                                                                              \<td\>Inequality on integers, reals, numbers, strings,\n                                                                                                                                                          locations, dateTime, value,\n                                                                                                                                                          lists, \n                                                                                                                                                          maps, sets, relations.\</td\>\</tr\>\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> ? \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>                     \<td\>IfDefinedOtherwise\</td\>        \<td\>Value of expression when it is defined, \n                                                                                                                                                        otherwise alternative value\</td\>\</tr\>\n\n\<tr\>\<td\>\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> ? \<i\>Exp\</i\>\<sub\>2\</sub\> : \<i\>Exp\</i\>\<sub\>3\</sub\>\</code\>\</td\>          \<td\>ConditionalExpressions\</td\> \<td\>Conditional expression for all types\</td\>\</tr\>\n\n\<tr\>\<td\> \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> ==\> \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>                  \<td\>Implication\</td\>                    \<td\>Implication on Boolean values\</td\>\</tr\>\n\n\<tr\>\<td\> \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> &lt;==\> \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>               \<td\>Equivalence\</td\>                   \<td\>Equivalence on Boolean values\</td\>\</tr\>\n\n\<tr\>\<td\> \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> &amp;&amp; \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>                     \<td\>And\</td\>                                \<td\>And on Boolean values\</td\>\</tr\>\n\n\<tr\>\<td\> \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> || \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</td\>                       \<td\>Or\</td\>                                    \<td\>Or on Boolean values\</td\>\</tr\>\n\n\</table\>\n","\n","\n","\n",[]),"Rascal/Expressions/Operators/Subscription":concept("Subscription",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Operators/Subscription/Subscription.concept|,[],{},[],"Syntax: \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> [ \<i\>Exp\</i\>\<sub\>2\</sub\> , \<i\>Exp\</i\>\<sub\>3\</sub\>, .... ]\</code\>\n",{"]",",","[","...."},"\nSubscription selects values with a given computed index from a larger value that has a variable number of elements:\nThe values of \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>, \<code\>\<i\>Exp\</i\>\<sub\>3\</sub\>\</code\>, ... are used as index in \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\>\'\\s value. Subscription is defined for various types:\n\n\<ul\>\n\<li\> For lists and tuples a single integer expression is allowed as index and the returned value is the element with that index (counting from 0). \</li\>\n\<li\> For maps, the index type should correspond to the key type of the map and the value associated with the index is returned. \</li\>\n\<li\> For relations, more than one index expression is allowed and as value a new, reduced, relation is returned with all elements that contained the index values at the corresponding tuples positions (but these values are removed, hence a reduced relation). \</li\>\n\n\</ul\>\n","\<pre class=\"screen\"\>\</pre\>\n Introduce a list, assign it to L and retrieve the element with index 1:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>L = [10, 20, 30];\nlist[int]: [10,20,30]\n\<b\>rascal\>\</b\>L[1];\nint: 20\n\</pre\>\n Introduce a tuple, assign it to \<code\>T\</code\> and retrieve the element with index 0:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>T = &lt;&quot;mon&quot;, 1&gt;;\ntuple[str,int]: \<\"mon\",1\>\n\<b\>rascal\>\</b\>T[0];\nstr: \"mon\"\n\</pre\>\n Introduce a map, assign it to \<code\>colors\</code\>, and retrieve the element with index \<code\>\"trumps\"\</code\>:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>\ncancelled\n\<b\>rascal\>\</b\>colors = (&quot;hearts&quot;:&quot;red&quot;, &quot;clover&quot;:&quot;black&quot;, \n\>\>\>\>\>\>\>                \"trumps\":\"black\", \"clubs\":\"red\");\nmap[str, str]: (\"clubs\":\"red\",\"clover\":\"black\",\"hearts\":\"red\",\"trumps\":\"black\")\n\<b\>rascal\>\</b\>colors[&quot;trumps&quot;];\nstr: \"black\"\n\</pre\>\n Explore some erroneous subscription expressions:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>colors[0];\nStatic Error: prompt:///:1,0: Expected str, but got int\n\<b\>rascal\>\</b\>colors[&quot;square&quot;];\nUncaught Rascal Exception: prompt:///:1,0: NoSuchKey(\"square\")\n\</pre\>\n Introduce a relation with economic data and assign it to \<code\>GDP\</code\>:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>rel[str country, int year, int amount] GDP =\n\>\>\>\>\>\>\>{\<\"US\", 2008, 14264600\>, \<\"EU\", 2008, 18394115\>,\n\>\>\>\>\>\>\> \<\"Japan\", 2008, 4923761\>, \<\"US\", 2007, 13811200\>, \n\>\>\>\>\>\>\> \<\"EU\", 2007, 13811200\>, \<\"Japan\", 2007, 4376705\>};\nrel[str country, int year, int amount]: {\<\"EU\",2008,18394115\>,\<\"US\",2007,13811200\>,\<\"Japan\",2007,4376705\>,\<\"US\",2008,14264600\>,\<\"EU\",2007,13811200\>,\<\"Japan\",2008,4923761\>}\n\</pre\>\n and then retrieve the information for the index \<code\>\"Japan\"\</code\>:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>GDP[&quot;Japan&quot;];\nrel[int, int]: {\<2008,4923761\>,\<2007,4376705\>}\n\</pre\>\n or rather for the indices \<code\>\"Japan\"\</code\> and \<code\>2008\</code\>:\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>GDP[&quot;Japan&quot;, 2008];\nset[int]: {4923761}\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Number/Conditional":concept("Conditional",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/Conditional/Conditional.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>Exp\</i\>\<sup\>bool\</sup\> ? \<i\>Exp\</i\>\<sub\>1\</sub\>\<sup\>num\</sup\> : \<i\>Exp\</i\>\<sub\>2\</sub\>\<sup\>num\</sup\>\</code\>\</li\>\n\<li\> Type: \<code\>int\</code\> or \<code\>real\</code\>\</li\>\n\n\</ul\>\n",{"?",":"},"If the value of \<code\>\<i\>Exp\</i\>\</code\> is \<code\>true\</code\> then the value of \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\> else the value of \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>(3 &gt; 2) ? 10 : 20\nint: 10\n\<b\>rascal\>\</b\>(3 &gt; 20) ? 10 : 20\nint: 20\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","(\<A:int\> \> \<B:int\>) ? \<C:int\> : \<D:int\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>,<"C",int(-20,20)>,<"D",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","(\<A:int\> \> \<B:int\>) ? \<C:real\> : \<D:real\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>,<"C",real(-20,20)>,<"D",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","(\<A:int\> \> \<B:int\>) ? \<C:int\> : \<D:real\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>,<"C",int(-20,20)>,<"D",real(-20,20)>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",[],"","","(\<A:int\> \> \<B:int\>) ? \<C:int\> : \<D:int\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>,<"C",int(-20,20)>,<"D",int(-20,20)>],[],void(),"")),tvQuestion("5",valueOfExpr(),details("\n",[],"","","(\<A:int\> \> \<B:int\>) ? \<C:int\> : \<D:real\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>,<"C",int(-20,20)>,<"D",real(-20,20)>],[],void(),""))]),"Rascal/Expressions/Values/Real":concept("Real",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Real/Real.concept|,[],{"Language"},[],"real\n",{},"The real values are represented by the type \<tt\>real\</tt\> and are written as usual in most programming languages.\nThey can have arbitrary size and precision.\n","\<ul\>\n\<li\> 1.5\</li\>\n\<li\> 3.14e-123\</li\>\n\n\</ul\>\n","\n","\n",[]),"Rascal/Expressions/Values/Number/max":concept("max",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/max/max.concept|,[],{"Library"},[],"Function: \<code\>&amp;T &lt;: num max(&amp;T &lt;: num n, &amp;T &lt;: num m)\</code\>\n",{},"The largest of two numbers. The type of the result is the same as the type of the largest argument.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Number;\nok\n\<b\>rascal\>\</b\>max(12, 13);\nint: 13\n\<b\>rascal\>\</b\>max(12, 13.5);\nnum: 13.5\n\<b\>rascal\>\</b\>max(12, 11.5);\nnum: 12\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",["import Number;"],"","","max(\<A:int\>, \<B:int\>)","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",["import Number;"],"","","max(\<A:int\>, \<B:real\>)","",false,false,[<"A",int(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",valueOfExpr(),details("\n",["import Number;"],"","","max(\<A:num\>, \<B:num\>)","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",["import Number;"],"","","max(\<A\>, ",") == \<C\>",false,true,[<"A",num(-20,20)>,<"B",num(0,20)>],[<"C","\<A\> + \<B\>">],void(),"\<C\>")),tvQuestion("5",valueOfExpr(),details("\n",["import Number;"],"","","max(\<A\>, ",") == \<A\>",false,true,[<"A",num(-20,20)>],[],void(),"any value smaller than \<A\>"))]),"Rascal/Concepts/Enumerators":concept("Enumerators",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/Enumerators/Enumerators.concept|,[],{},[],"\n",{},"Enumerators enumerate the values in a given (finite) domain, be it the elements in a list, the substrings of a string, \nor all the nodes in a tree. \nEach value that is enumerated is first matched against a pattern before it can possibly contribute to the result of \nthe enumerator.\n","\<pre class=\"listing\"\>int x &lt;- { 1, 3, 5, 7, 11 }\nint x &lt;- [ 1 .. 10 ]\n/asgStat(Id name, _) &lt;- P\n\</pre\>\nThe first two produce the integer elements of a set of integers, respectively, a range of integers. \nObserve that the left-hand side of an enumerator is a pattern, of which \<code\>int x\</code\> is a specific instance. \nThe use of more general patterns is illustrated by the third enumerator that does a deep traversal \n(as denoted by the descendant operator \<code\>/\</code\>) of the complete program \<code\>P\</code\> (that is assumed to have a \n\<code\>PROGRAM\</code\> as value) and only yields statements that match the assignment pattern (\<code\>asgStat\</code\>).\nNote the use of an anonymous variable at the \<code\>EXP\</code\> position in the pattern.\n","\n","\n",[]),"Rascal/Concepts":concept("Concepts",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/Concepts.concept|,[],{"Language"},[],"\n",{},"\nRascal has a statically checked type system that prevents type errors and uninitialized variables at runtime. \nThere are no runtime type casts as in Java and there are therefore less opportunities for run-time errors. \nThe language provides higher-order, parametric polymorphism. \nA type aliasing mechanism allows documenting specific uses of a type. \nBuilt-in operators are heavily overloaded. \nFor instance, the operator \<code\>+\</code\> is used for addition on integers and reals but also for list concatenation, \nset union and the like.\n\<br/\>\n\<br/\>\nThe flow of Rascal program execution is completely explicit. Boolean expressions determine choices that drive the control structures. Rewrite rules form the only exception to the explicit control flow principle. Only local backtracking is provided in the context of boolean expressions and pattern matching; side effects are undone in case of backtracking.\n\<br/\>\n\<br/\>\nMost language concepts are described separately but some features we just mention here:\n\n\<ul\>\n\<li\> Rascal programs consist of modules that are organized in packages.\</li\>\n\<li\> Modules can import other modules.\</li\>\n\<li\> The visibility of entities declared in modules can be controlled using public/private modifiers.\</li\>\n\<li\> Datastructures may have annotations that can be explicitly used and modified.\</li\>\n\<li\> There is an extensive library for builtin datatypes, input/output, fact extraction from Java source code, visualization, and more.\</li\>\n\n\</ul\>\n","\n","\n","\n",[]),"Rascal/Expressions/Values/DateTime":concept("DateTime",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/DateTime/DateTime.concept|,[],{},[],"Type: \<code\>dateTime\</code\>\n",{"dateTime"},"\n","\n","\n","\n",[]),"Rascal/Concepts/PatternMatching":concept("PatternMatching",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/PatternMatching/PatternMatching.concept|,[],{},[],"\n",{},"\nPattern Matching\n\nPattern matching determines whether a given pattern matches a given value. \nThe outcome can be \<code\>false\</code\> (no match) or \<code\>true\</code\> (a match). A pattern match that succeeds may bind values to variables.\n\<br/\>\n\<br/\>\nPattern matching is _the_ mechanism for case distinction (\<a href=\"/show?concept=switch\"\>switch\</a\> statement) and search (\<a href=\"/show?concept=visit\"\>visit\</a\> statement) in Rascal. Patterns can also be used in an explicit match operator \<code\>:=\</code\> and can then be part of larger boolean expressions. Since a pattern match may have more than one solution, local backtracking over the alternatives of a match is provided. Patterns can also be used in \<a href=\"/show?concept=enumerator\"\>enumerator\</a\>s and control structures like \<a href=\"/show?concept=for\"\>for\</a\> and \<a href=\"/show?concept=while\"\>while\</a\> statement.\n\<br/\>\n\<br/\>\nA very rich pattern language is provided that includes string matching based on regular expressions, matching of abstract patterns, and matching of concrete syntax patterns. Some of the features that are provided are list (associative) matching, set (associative, commutative, idempotent) matching, and deep matching of descendant patterns. All these forms of matching can be used in a single pattern and can be nested. Patterns may contain variables that are bound when the match is successful. Anonymous (don\'\\t care) positions are indicated by the underscore (\<code\>_\</code\>).\n\<br/\>\n\<br/\>\nHere is a _regular expression_ that matches a line of text, finds the first alphanumeric word in it, and extracts the word itself as well as the before and after it (\<code\>\\W\</code\> matches all non-word characters; \<code\>\\w\</code\> matches all word characters):\n\n\<pre class=\"listing\"\>/^&lt;before:\\W*\>&lt;word:\\w+\>&lt;after:.*$\>/\n\</pre\>\nRegular expressions follow the Java regular expression syntax with one exception: instead of using numbered groups to refer to parts of the subject string that have been matched by a part of the regular expression we use the notation:\n\n\<pre class=\"listing\"\>&lt;\<i\>Name\</i\>:\<i\>RegularExpression\</i\>\>\n\</pre\>\nIf \<code\>\<i\>RegularExpression\</i\>\</code\> matches, the matched substring is assigned to string variable \<code\>\<i\>Name\</i\>\</code\>.\n\<br/\>\n\<br/\>\nThe following abstract pattern matches the abstract syntax of a while statement defined earlier:\n\n\<pre class=\"listing\"\>whileStat(EXP Exp, list[STAT] Stats)\n\</pre\>\nVariables in a pattern are either explicitly declared in the pattern itself---as done in the example---or they may be declared in the context in which the pattern occurs. So-called multi-variables in list and set patterns are declared by a \<code\>*\</code\> suffix: \<code\>X*\</code\> is thus \nan abbreviation for \<code\>list[...] X\</code\> or \<code\>set[...] X\</code\>, where the precise element type depends on the context. The above pattern can then be written as\n\n\<pre class=\"listing\"\>whileStat(EXP Exp, Stats*)\n\</pre\>or, if you are not interested in the actual value of the statements as\n\n\<pre class=\"listing\"\>whileStat(EXP Exp, _*)\n\</pre\>\nWhen there is a grammar for this example language (in the form of an imported SDF definition), we can also write concrete patterns as we will see.\n\<warning\> add link\</warning\>\n","\n","\n","\n",[]),"Rascal/Concepts/SyntaxDefinitionAndParsing":concept("SyntaxDefinitionAndParsing",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/SyntaxDefinitionAndParsing/SyntaxDefinitionAndParsing.concept|,[],{},[],"\n",{},"\nAll source code analysis projects need to extract information directly from the source code. \nThere are two main approaches to this:\n\n\<ul\>\n\<li\> _Lexical information_: Use regular expressions to extract useful, but somewhat superficial, flat, information.     This can be achieved using regular expression patterns.\</li\>\n\<li\> _Structured information_: Use syntax analysis to extract the complete, nested, structure of the source code     in the form of a syntax tree.\</li\>\n\n\</ul\>\nIn Rascal, we reuse the Syntax Definition Formalism (SDF) and its tooling. \nSee \<a href=\"http://www.meta-environment.org/Meta-Environment/Documentation\"\>http://www.meta-environment.org/Meta-Environment/Documentation\</a\> for tutorials and manuals for SDF.\n\nSDF modules define grammars and these modules can be imported in a Rascal module. \nThese grammar rules can be applied in writing concrete patterns to match parts of parsed source code. \nHere is an example of the same pattern we saw in \<a href=\"/show?concept=Concepts/PatternMatching\"\>Concepts/PatternMatching\</a\>, but now in concrete form:\n\n\<pre class=\"listing\"\>while &lt;Exp\> do &lt;Stats\> od\n\</pre\>Importing an SDF module has the following effects:\n\n\<ul\>\n\<li\>  All non-terminals (sorts in SDF jargon) that are used in the imported grammar are implicitly      declared as Rascal types. For each SDF sort S also composite symbols like \<code\>S*\</code\>, \<code\>{S \",\"}+\</code\> also become      available as type. This makes it possible to handle parse trees and parse tree fragments as fully typed      values and assign them to variables, store them in larger datastructures or pass them as arguments      to functions and use them in pattern matching.\</li\>\n\<li\>  For all _start symbols_ of the grammar _parse functions_ are implicitly declared that can parse source files      according to a specific start symbol.\</li\>\n\<li\>  Concrete syntax patterns for that specific grammar can be used.\</li\>\n\<li\>  Concrete syntax constructors can be used that allow the construction of new parse trees.\</li\>\n\n\</ul\>\n","\nThe following example parses a Java compilation unit from a text file and counts the number of method declarations:\n\n\<pre class=\"listing\"\>module Count\nimport languages::java::syntax::Java;\nimport ParseTree;\n\npublic int countMethods(loc file){\n  int n = 0;\n  for(/MethodDeclaration md &lt;- parse(#CompilationUnit, file))\n      n += 1;\n  return n;\n}\n\</pre\>First observe that importing the Java grammar has as effect that non-terminals like \<code\>MethodDeclaration\</code\> and \n\<code\>CompilationUnit\</code\> become available as type in the Rascal program.\n\nThe implicitly declared function \<code\>parse\</code\> takes a reified type (\<code\>#CompilationUnit\</code\>) and a location \nas arguments and parses the contents of the location according to the given non-terminal. \nNext, a match for embedded \<code\>MethodDeclaration\</code\>s is done in the enumerator of the for statement. \n","\n","This example ignores many potential error conditions but does illustrate some of Rascal\'\\s syntax and \nparsing features.\n",[]),"Rascal/Expressions/Values/Set/power1":concept("power1",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/power1/power1.concept|,[],{"Library"},[],"Function: \<code\>set[set[&amp;T]] power1(set[&amp;T] s)\</code\>\n",{},"Return all subsets (excluding the empty set) of \<code\>s\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>power1({1,2,3,4});\nset[set[int]]: {{4,2,1},{4,3},{4,2},{4,3,1},{4,1},{4,3,2},{4},{4,3,2,1},{3},{2,1},{3,1},{2},{3,2},{1},{3,2,1}}\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Number/LessThan":concept("LessThan",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/LessThan/LessThan.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\> &lt; \<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"\<","bool"},"Yields \<code\>true\</code\> if the value of \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\>\</code\> is numerically less than the value of \<code\>\<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>, and \<code\>false\</code\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>13 &lt; 12\nbool: false\n\<b\>rascal\>\</b\>12 &lt; 13\nbool: true\n\<b\>rascal\>\</b\>13.5 &lt; 12\nbool: false\n\<b\>rascal\>\</b\>12.5 &lt; 13\nbool: true\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:int\> \< \<A:int\>","",false,false,[<"A",int(-20,20)>,<"A",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:real\> \< \<B:real\>","",false,false,[<"A",real(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:num\> \< \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("4",typeOfExpr(),details("\n",[],"","","\<A:num\> \< \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("5",valueOfExpr(),details("\n",[],"","","\<A:num\> \< \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),""))]),"Rascal":concept("Rascal",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Rascal.concept|,[],{"Library","Example","Language"},[],"\n",{},"\n_Meta-programs_ are programs that analyze, transform or generate other programs. Ordinary programs work on data; meta-programs work on programs. The range of programs to which meta-programming can be applied is large: from programs in standard languages like C and Java to domain-specific languages for describing high-level system models or applications in specialized areas like gaming or finance. In some cases, even test results or performance data are used as input for meta-programs.\n\nRascal is a new language for _meta-programming_, this is the activity of writing meta-programs.\nIt is intended for reading, analyzing, and transforming other programs. \n","Typical applications of Rascal are:\n\<ul\>\n\<li\> Refactoring of Java source code.\</li\>\n\<li\> Searching for buffer overflows in C code.\</li\>\n\<li\> Analyzing the version history of a large software project.\</li\>\n\<li\> Implementing a _domain-specific language_ (DSL) for describing business processes.\</li\>\n\n\</ul\>\nAll these cases involve a form of meta-programming: software programs (in a wide sense) are the objects-of-interest that are being analyzed, transformed or generated. The Rascal language is designed for meta-programming following the \<a href=\"/show?concept=EASY\"\>EASY\</a\> paradigm. It can be applied in domains ranging from compiler construction and implementing domain-specific languages to constraint solving and software renovation.\n\nSince representation of information is central to the approach, Rascal provides a rich set of built-in data types. To support extraction and analysis, parsing and advanced pattern matching are provided. High-level control structures make analysis and synthesis of complex datastructures simple.\n","\n\<ul\>\n\<li\> __Familiar syntax__ in a _what-you-see is-what-you-get_ style is used even for sophisticated concepts     and this makes the language easy to learn and easy to use.\</li\>\n\<li\> __Sophisticated built-in data types__ provide standard solutions for many meta-programming problems.\</li\>\n\<li\> __Safety__ is achieved by finding most errors before the program is executed and by making common errors    like missing initializations or invalid pointers impossible. \</li\>\n\<li\> __Local type inference__ makes local variable declarations redundant.\</li\>\n\<li\> __Pattern matching__ can be used to analyze all complex datastructures.\</li\>\n\<li\> __Syntax definitions__ make it possible to define new and existing languages and to write tools for them.\</li\>\n\<li\> __Visiting__ makes it easy to traverse datastructures and to extract information from them or to synthesize results.\</li\>\n\<li\> __Templates__ enable easy code generation.\</li\>\n\<li\> __Functions as values__ permit programming styles with high re-use.\</li\>\n\<li\> __Generic types__ allow writing functions that are applicable for many different types.\</li\>\n\<li\> __Eclipse integration__ makes Rascal programming a breeze. All familiar tools are at your fingertips.\</li\>\n\n\</ul\>\n","\<ul\>\n\<li\> Rascal programs are not yet highly optimized so execution maybe slow for some programs.\</li\>\n\<li\> At the time of writing, this checking is done during execution, but we are working on this.\</li\>\n\n\</ul\>\n",[]),"Rascal/Concepts/RewriteRules":concept("RewriteRules",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/RewriteRules/RewriteRules.concept|,[],{},[],"\n",{},"\nRewrite Rules\n\nA rewrite rule is a recipe on how to simplify values. \nRemember: (\<code\>\<i\>a\</i\>\</code\> + \<code\>\<i\>b\</i\>\</code\>)\<code\>\<i\>\</i\>\<sup\>2\</sup\>\</code\> = \<code\>\<i\>a\</i\>\<sup\>2\</sup\>\</code\> + 2\<code\>\<i\>ab\</i\>\</code\> + \<code\>\<i\>b\</i\>\<sup\>2\</sup\>\</code\>? \nA rewrite rule has a pattern as left-hand side (here: (\<code\>\<i\>a\</i\>\</code\> + \<code\>\<i\>b\</i\>\</code\>)\<code\>\<i\>\</i\>\<sup\>2\</sup\>\</code\> and a replacement as \nright-hand side (here: \<code\>\<i\>a\</i\>\<sup\>2\</sup\>\</code\> + 2\<code\>\<i\>ab\</i\>\</code\> + \<code\>\<i\>b\</i\>\<sup\>2\</sup\>\</code\>). \nGiven a value and a set of rewrite rules the patterns are tried on every subpart of the value and replacements are made if a match is successful. This is repeated as long as some pattern matches.\n\nRewrite rules are the only implicit control mechanism in the language and are used to maintain invariants \nduring computations.\nSince rewrite rules are activated automatically, one may always assume that expressions are in simplified form.\n","\nIn a package for symbolic differentiation it is desirable to keep expressions in simplified form in order \nto avoid intermediate results like \<code\>sum(product(num(1), x), product(num(0), y))\</code\> that can be simplified to \<code\>x\</code\>. \nThe following rules achieve this:\n\<pre class=\"listing\"\>rule simplify1 product(num(1), Expression e) =\> e;\nrule simplify2 product(Expression e, num(1)) =\> e;\nrule simplify3 product(num(0), Expression e) =\> num(0);\nrule simplify4 product(Expression e, num(0)) =\> num(0);\nrule simplify5 sum(num(0), Expression e)     =\> e;\nrule simplify6 sum(Expression e, num(0))     =\> e;\n\</pre\>Whenever a new value of type \<code\>Expression\</code\> is constructed during symbolic differentiation, these rules are _implicitly_ applied \nto that expression and all its subexpressions and when a pattern at the left-hand side of a rule applies the matching subexpression is replaced by the right-hand side of the rule. This is repeated as long as any rule can be applied.\n","\n","\nRewrite rules are _Turing complete_, in other words any computable function can be defined using rewrite rules, \nincluding functions that do not terminate. This is a point of attention when using rewrite rules.\n",[]),"Rascal/Expressions/Values/Void":concept("Void",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Void/Void.concept|,[],{"Language"},[],"Type: \<code\>void\</code\>\n",{"void"},"Void stands for _nothing_ and is represented by the type \<code\>void\</code\>. \nIt is a type without any values.\n","\n","\n","\n",[]),"Rascal/Expressions/Values/Set/takeOneFrom":concept("takeOneFrom",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/takeOneFrom/takeOneFrom.concept|,[],{"Library"},[],"Function: \<code\>tuple[&amp;T, set[&amp;T]] takeOneFrom(set[&amp;T] s)\</code\>\n",{},"Remove an arbitrary element from set \<code\>s\</code\> and return a tuple consisting of the element and the modified set.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>takeOneFrom({1, 2, 3, 4});\ntuple[int,set[int]]: \<4,{3,2,1}\>\n\<b\>rascal\>\</b\>takeOneFrom({1, 2, 3, 4});\ntuple[int,set[int]]: \<1,{4,3,2}\>\n\<b\>rascal\>\</b\>takeOneFrom({1, 2, 3, 4});\ntuple[int,set[int]]: \<2,{4,3,1}\>\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Number/GreaterThanOrEqual":concept("GreaterThanOrEqual",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/GreaterThanOrEqual/GreaterThanOrEqual.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\> \>= \<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"\>=","bool"},"Yields \<code\>true\</code\> if the value of \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\>\</code\> is numerically greather than or equal to the value of \<code\>\<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>, and \<code\>false\</code\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>13 &gt;= 12\nbool: true\n\<b\>rascal\>\</b\>12 &gt;= 13\nbool: false\n\<b\>rascal\>\</b\>13.5 &gt;= 12\nbool: true\n\<b\>rascal\>\</b\>12.5 &gt;= 13\nbool: false\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:int\> \>= \<B:int\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:real\> \>= \<B:real\>","",false,false,[<"A",real(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:num\> \>= \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("4",typeOfExpr(),details("\n",[],"","","\<A:num\> \>= \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("5",valueOfExpr(),details("\n",[],"","","\<A:num\> \>= \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),""))]),"Rascal/EASY/Security":concept("Security",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/EASY/Security/Security.concept|,[],{"Example"},[],"\n",{},"_Alice_ is system administrator of a large online marketplace and she is looking for security breaches in her system. The objects-of-interest are the system\'\\s log files. First relevant entries are extracted. This will include, for instance, messages from the SecureShell demon that reports failed login attempts. From each entry login name and originating IP address are extracted and put in a table (the internal representation in this example). These data are analyzed by detecting duplicates and counting frequencies. Finally results are synthesized by listing the most frequently used login names and IP addresses.\n","\n","\n","\n",[]),"Rascal/Expressions/Values/String":concept("String",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/String/String.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<warning\>explain string syntax\</warning\>\</li\>\n\<li\> Type: \<code\>str\</code\>\</li\>\n\n\</ul\>\n",{"str"},"The string values are represented by the type \<code\>str\</code\> and consist of character \nsequences surrounded by double quotes. e.g., \<code\>\"a\"\</code\> or \<code\>\"a\\nlong\\nstring\"\</code\>.\n\nString literals support so-called _string interpolation_: \ninside string constants text between angle brackets (\<code\>&lt;\</code\> and \<code\>\>\</code\>) is first executed and then replaced by\n its string value.\nVarious statements (if, for, while, do) also return a value and can be used in this way.\nIn the interpolation variant of these statements the block or blocks that are part of the statement become arbitrary text \n(that may itself contain interpolations). \n\<br/\>\n\<br/\>\nTheir forms are:\n\n\<ul\>\n\<li\> \<code\>&lt;if(\<i\>Exp\</i\>){\> ... \<i\>Text\</i\> ... &lt;}\>\</code\>\</li\>\n\<li\> \<code\>&lt;if(\<i\>Exp\</i\>){\> ... \<i\>Text\</i\> ... &lt;} else {\>  ... \<i\>Text\</i\> ... &lt;}\>\</code\>\</li\>\n\<li\> \<code\>&lt;for(\<i\>Exp\</i\>){\>... \<i\>Text\</i\> ... &lt;}\>\</code\>\</li\>\n\<li\> \<code\>&lt;while(\<i\>Exp\</i\>){\> ... \<i\>Text\</i\> ... &lt;}\>\</code\>\</li\>\n\<li\> \<code\>&lt;do {\>... \<i\>Text\</i\> ... &lt;} while (\<i\>Exp\</i\>)\>\</code\>\</li\>\n\n\</ul\>\nHere \<code\>\<i\>Text\</i\>\</code\> is arbitrary text that may itself contain again contain interpolations.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>N = 13;\nint: 13\n\<b\>rascal\>\</b\>&quot;The value of N is &lt;N&gt;&quot;;\nstr: \"The value of N is 13\"\n\<b\>rascal\>\</b\>&quot;The value of N*N is &lt;N*N&gt;&quot;;\nstr: \"The value of N*N is 169\"\n\<b\>rascal\>\</b\>&quot;The value is &lt;(N &lt; 10) ? 10 : N*N&gt;&quot;;\nstr: \"The value is 169\"\n\</pre\>\nAs you can see the string value of variables and expressions is interpolated in the result as expected. \n\<br\>\nSome examples of more advances string interpolation \n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>&quot;N is &lt;if(N &lt; 10){&gt; small &lt;} else {&gt; large &lt;}&gt;&quot;;\nstr: \"N is  large \"\n\<b\>rascal\>\</b\>&quot;N is &lt;if(N &lt; 10){&gt; small &lt;} else {&gt; large (&lt;N&gt;)&lt;}&gt;&quot;;\nstr: \"N is  large (13)\"\n\<b\>rascal\>\</b\>&quot;before &lt;for(x&lt;-[1..5]){&gt;a &lt;x&gt; b &lt;}&gt;after&quot;;\nstr: \"before a 1 b a 2 b a 3 b a 4 b a 5 b after\"\n\</pre\>","String interpolation enables very flexible template-based text generation as used in generators for\nsource code, markup and the like.\n","\n",[]),"Rascal/Examples/Factorial":concept("Factorial",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Examples/Factorial/Factorial.concept|,[],{"Example"},[],"\n",{},"Compute the factorial function.\n","\n\<pre class=\"listing\"\>module demo::Factorial\n\n// The factorial function N! = N * (N-1) * (N-2) * ... * 1;\n\npublic int fac(int N)\n{\n  return N &lt;= 0 ? 1 : N * fac(N - 1);\n}\n\</pre\>\nIt uses a conditional statement to distinguish cases and here is how to use it:\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import demo::Factorial;\nok\n\<b\>rascal\>\</b\>fac(47);\nint: 258623241511168180642964355153611979969197632389120000000000\n\</pre\>\nIndeed, Rascal has arbitrary length integers.\n","\n","This example illustrates some ordinary programming features in Rascal. It does not highlight Rascal\'\\s specific strength.\n",[]),"Rascal/Expressions/Values/Set/Subset":concept("Subset",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/Subset/Subset.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\> &lt;= \<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"bool","\<="},"Yields \<code\>true\</code\> if the value of \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\>\</code\> is a subset of the value of \<code\>\<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>, and \<code\>false\</code\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3} &lt;= {1, 2, 3, 4};\nbool: true\n\<b\>rascal\>\</b\>{1, 2, 3} &lt;= {1, 2, 3};\nbool: true\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:set[arb[0,int,str,real]]\> \<= \<B:same[A]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str(),real(-20,20)]))>,<"B",same("A")>],[],void(),""))]),"Rascal/Expressions/Values/Set/size":concept("size",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/size/size.concept|,[],{"Library"},[],"Function: \<code\>int size(set[&amp;T] s)\</code\>\n",{},"Returns the number of elements in \<code\>s\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>size({1,2,3,4});\nint: 4\n\<b\>rascal\>\</b\>size({});\nint: 0\n\</pre\>","\n","\n",[tvQuestion("1",valueOfExpr(),details("\n",["import Set;"],"","","size({ "," }) == \<N\>",false,true,[<"N",int(0,5)>],[],void(),"\<N\> values separated by commas"))]),"Rascal/Expressions/Values/Set/mapper":concept("mapper",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/mapper/mapper.concept|,[],{"Library"},[],"Function: \<code\>set[&amp;U] mapper(set[&amp;T] s, &amp;U(&amp;T) fn)\</code\>\n",{},"Return a set obtained by applying function \<code\>fn\</code\> to all elements of set \<code\>s\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>int incr(int x) { return x + 1; }\nint (int): int incr(int);\n\<b\>rascal\>\</b\>mapper({1, 2, 3, 4}, incr);\nset[int]: {5,4,3,2}\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Number/Subtraction":concept("Subtraction",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/Subtraction/Subtraction.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\> - \<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>int\</code\> or \<code\>real\</code\>\</li\>\n\n\</ul\>\n",{"-"},"Yields the numerical result of subtracting the value of \<code\>\<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\> from the value of \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\>\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>13 - 12\nint: 1\n\<b\>rascal\>\</b\>13.5 - 12\nreal: 1.5\n\<b\>rascal\>\</b\>12 - 13\nint: -1\n\<b\>rascal\>\</b\>12 - 13.5\nreal: -1.5\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:int\> - \<B:int\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:int\> - \<B:real\>","",false,false,[<"A",int(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:real\> - \<B:int\>","",false,false,[<"A",real(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",[],"","","\<A:num\> - \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),""))]),"Rascal/Expressions/Values/Set/toMap":concept("toMap",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/toMap/toMap.concept|,[],{"Library"},[],"Function: \<code\>map[&amp;A, set[&amp;B]] toMap(set[tuple[&amp;A, &amp;B]] s)\</code\>\n",{},"Convert a set of tuples to a map in which the first element of each tuple is associated with the set of second elements of all tuples with the same first element.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>toMap({&lt;&quot;a&quot;, 1&gt;, &lt;&quot;b&quot;, 2&gt;, &lt;&quot;a&quot;, 10&gt;});\nmap[str, set[int]]: (\"b\":{2},\"a\":{10,1})\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Number/min":concept("min",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/min/min.concept|,[],{"Library"},[],"Function: \<code\>&amp;T &lt;: num min(&amp;T &lt;: num n, &amp;T &lt;: num m)\</code\>\n",{},"The smallest of two numbers. The type of the result is the same as the type of the smallest argument.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Number;\nok\n\<b\>rascal\>\</b\>min(12, 13);\nint: 12\n\<b\>rascal\>\</b\>min(12, -13);\nint: -13\n\<b\>rascal\>\</b\>min(3.14, 4);\nnum: 3.14\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",["import Number;"],"","","min(\<A:int\>, \<B:int\>)","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",["import Number;"],"","","min(\<A:int\>, \<B:real\>)","",false,false,[<"A",int(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",["import Number;"],"","","min(\<A:real\>, \<B:real\>)","",false,false,[<"A",real(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",["import Number;"],"","","min(\<A:num\>, \<B:num\>)","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),""))]),"Rascal/Expressions/Values/Number/toString":concept("toString",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/toString/toString.concept|,[],{"Library"},[],"Function: \<code\>str toString(num n)\</code\>\n",{},"Convert a number to a string.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Number;\nok\n\<b\>rascal\>\</b\>toString(12)\nstr: \"12\"\n\<b\>rascal\>\</b\>toString(3.14)\nstr: \"3.14\"\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Value":concept("Value",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Value/Value.concept|,[],{"Language"},[],"Type: \<code\>value\</code\>\n",{"value"},"Value stands for all possible Rascal values and is represented by the type \<code\>value\</code\>.\nThis type is a container for all other types and does not have any values itself.\n","\n","\n","\n",[]),"Rascal/Expressions/Values/Set/toList":concept("toList",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/toList/toList.concept|,[],{"Library"},[],"Function: \<code\>list[&amp;T] toList(set[&amp;T] s)\</code\>\n",{},"Convert a set to a list.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>toList({1, 2, 3, 4});\nlist[int]: [1,2,3,4]\n\</pre\>","\n","\n",[]),"Rascal/Concepts/Visiting":concept("Visiting",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/Visiting/Visiting.concept|,[],{},[],"\n",{},"\nVisiting the elements of a datastructure is one of the most common operations in our domain \nand the visitor design pattern is a solution known to every software engineer. \nGiven a tree-like datastructure we want to perform an operation on some (or all) nodes of the tree. The purpose of the visitor design pattern is to decouple the logistics of visiting each node from the actual operation on each node. In Rascal the logistics of visiting is completely automated.\n\nVisiting is achieved by way of visit expressions that resemble the switch statement. A visit expressions traverses an arbitrarily complex subject value and applies a number of cases to all its subtrees. \nAll the elements of the subject are visited and when one of the cases matches the statements associated \nwith that case are executed. These cases may:\n\n\<ul\>\n\<li\> cause some side effect, i.e., assign a value to local or global variables;\</li\>\n\<li\> execute an [\<a href=\"/show?concept=insert\"\>insert\</a\>] statement that replaces the current element;\</li\>\n\<li\> execute a [\<a href=\"/show?concept=fail\"\>fail\</a\>] statement that causes the match for the current case to fail (and undoing all side-effects due to the successful match itself and the execution of the statements so far).\<br/\>\n\<br/\>\nThe value of a visit expression is the original subject value with all replacements made as dictated by matching cases. The traversal order in a visit expressions can be explicitly defined by the programmer. \</li\>\n\n\</ul\>\n","\nAn example of visiting is given in [\<a href=\"/show?concept=ColoredTrees\"\>ColoredTrees\</a\>].\n","\n","\n",[]),"Rascal/Expressions/Values/Set/toMapUnique":concept("toMapUnique",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/toMapUnique/toMapUnique.concept|,[],{"Library"},[],"Function: \<code\>map[&amp;A, set[&amp;B]] toMapUnique(set[tuple[&amp;A, &amp;B]] s) throws DuplicateKey\</code\>\n",{},"Convert a set of tuples to a map. The result should be a legal map (i.e., without duplicate keys).\n","\<warning\>toMapUnique seems to be broken\</warning\>\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>toMapUnique({&lt;&quot;a&quot;, 1&gt;, &lt;&quot;b&quot;, 2&gt;, &lt;&quot;c&quot;, 10&gt;});\nmap[str, int]: (\"c\":10,\"b\":2,\"a\":1)\n\<b\>rascal\>\</b\>toMapUnique({&lt;&quot;a&quot;, 1&gt;, &lt;&quot;b&quot;, 2&gt;, &lt;&quot;a&quot;, 10&gt;});\nmap[str, int]: (\"b\":2,\"a\":1)\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Number/arbInt":concept("arbInt",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/arbInt/arbInt.concept|,[],{"Library"},[],"\<ul\>\n\<li\> Function: \<code\>int arbInt( )\</code\>\</li\>\n\<li\> Function: \<code\>int arbInt(int limit)\</code\>\</li\>\n\n\</ul\>\n",{},"Return an arbitrary integer value. When the argument \<code\>limit\</code\> is given, the generated value is in the interval [0, \<code\>limit\</code\>].\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Integer;\nok\n\<b\>rascal\>\</b\>arbInt()\nint: -1191207610\n\<b\>rascal\>\</b\>arbInt()\nint: -285121851\n\<b\>rascal\>\</b\>arbInt()\nint: 359531172\n\</pre\>","\<tt\>arbInt\</tt\> is a convenient generator for pseudo-random integers.\n","\n",[]),"Rascal/Expressions/Values/Set":concept("Set",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/Set.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>{ \<i\>Exp\</i\>\<sub\>1\</sub\>, \<i\>Exp\</i\>\<sub\>2\</sub\>, ... }\</code\>\</li\>\n\<li\> Type: \<code\>set[\<i\>Type\</i\>]\</code\>\</li\>\n\n\</ul\>\n",{"...","}",",","{","set["},"A set is an unordered sequence of values and has the following properties:\n\<ul\>\n\<li\> All elements have the same static type.\</li\>\n\<li\> The order of the elements does not matter.\</li\>\n\<li\> A set contains an element only once. In other words, duplicate elements are eliminated and no matter how many times an element is added to a set, it will occur in it only once.\</li\>\n\n\</ul\>\nThe type of a set has the form \<code\>set[\<i\>Type\</i\>]\</code\>,\nwhere \<code\>\<i\>Type\</i\>\</code\> is an arbitrary type.\n\nWhen variables of type set occur inside a set, their elements are automatically _spliced_ into the surrounding set. This can be prevented by surrounding them with extra \<code\>{\</code\> and \<code\>}\</code\> brackets. Note that this approach is atypical: in Rascal splicing is implicit while in other languages it has to be indicated explicitly by the programmer.\n","\<h1\> Set types \</h1\>\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3};\nset[int]: {3,2,1}\n\<b\>rascal\>\</b\>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;};\nrel[int, int]: {\<2,20\>,\<1,10\>,\<3,30\>}\n\<b\>rascal\>\</b\>{1, &quot;b&quot;, 3};\nset[value]: {3,\"b\",1}\n\<b\>rascal\>\</b\>{&lt;&quot;a&quot;, 10&gt;, &lt;&quot;b&quot;, 20&gt;, &lt;&quot;c&quot;, 30&gt;}\nrel[str, int]: {\<\"b\",20\>,\<\"a\",10\>,\<\"c\",30\>}\n\<b\>rascal\>\</b\>{{&quot;a&quot;, &quot;b&quot;}, {&quot;c&quot;, &quot;d&quot;, &quot;e&quot;}}\nset[set[str]]: {{\"b\",\"a\"},{\"e\",\"d\",\"c\"}}\n\</pre\>Note that\n\<ul\>\n\<li\> \<code\>{1, 2, 3}\</code\> and \<code\>{3, 2, 1}\</code\> are identical sets (since order is not relevant).\</li\>\n\<li\> \<code\> {1, 2, 3}\</code\> and \<code\>{1, 2, 3, 1}\</code\> are also identical sets (since duplication is not relevant).\</li\>\n\<h1\> Set splicing \</h1\>\n\n\</ul\>\n\n\<pre class=\"screen\"\>\</pre\>\nIntroduce a set variable \<tt\>S\</tt\>\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>S = {1, 2, 3};\nset[int]: {3,2,1}\n\</pre\>\n and observe how \<code\>S\</code\> is spliced in another set\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{10, S, 20};\nset[int]: {10,20,3,2,1}\n\</pre\>\nor becomes a subset when it is surrounded with extra braces\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{10, {S}, 20};\nset[value]: {10,20,{3,2,1}}\n\</pre\>","\n","\n",[choiceQuestion("1"," Sets can be used to represent a sequence of values when\n",[good("The values have no duplicates and no order."),bad("The values have duplicates."),bad("The values are unordered.")]),choiceQuestion("2"," The type of a set is determined by:\n",[good("The upperbound of the type of all elements."),bad("The type of the first element that was first added to the set."),bad("The upperbound of the type of two arbitrary elements.")]),tvQuestion("3",typeOfExpr(),details("\n",[],"","","{1, "," }",false,true,[],[],set(int(-20,20)),"one or more integer values separated by commas")),tvQuestion("4",typeOfExpr(),details("\n",[],"","","\<A:set[arb]\>","",false,false,[<"A",set(arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),loc(),dateTime()]))>],[],void(),"")),tvQuestion("5",typeOfExpr(),details("\n",[],"","","{\<A:int\>, \<B:str\>, \<C:int\>}","",false,false,[<"A",int(-20,20)>,<"B",str()>,<"C",int(-20,20)>],[],void(),""))]),"Rascal/EASY/ModelDrivenEngineering":concept("ModelDrivenEngineering",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/EASY/ModelDrivenEngineering/ModelDrivenEngineering.concept|,[],{"Example"},[],"\n",{},"\n_Elisabeth_ is a software architect at a large airplane manufacturer and her concern is reliability and dependability of airplane control software. She and her team have designed a UML model of the control software and have extended it with annotations that describe the reliability of individual components. She will use this annotated model in two ways: \n\<ul\>\n\<li\> to extract relevant information from it to synthesize input for a statistical tool that will compute overall system reliability from the reliability of individual components;\</li\>\n\<li\> to generate executable code that takes the reliability issues into account.\</li\>\n\n\</ul\>\n","\n","\n","\n",[]),"Rascal/Concepts/Comprehensions":concept("Comprehensions",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/Comprehensions/Comprehensions.concept|,[],{},[],"\n",{},"\nComprehensions are a notation inspired by mathematical set-builder notation that helps to write succinct definitions of lists and sets. They are also inspired by queries as found in a language like SQL.\n\nRascal generalizes comprehensions in various ways. Comprehensions exist for lists, sets and maps. \nA comprehension consists of an expression that determines the successive elements to be included in the \nresult and a list of enumerators and tests (boolean expressions). \nThe enumerators produce values and the tests filter them. \n","\nA standard example is\n\n\<pre class=\"listing\"\>{ x * x | int x &lt;- [1 .. 10], x % 3 == 0 }\n\</pre\>which returns the set \<code\>{9, 36, 81}\</code\>, i.e., the squares of the integers in the range \<code\>[ 1 .. 10 ]\</code\> that \nare divisible by 3. A more intriguing example is\n\n\<pre class=\"listing\"\>{name | /asgStat(Id name, _) &lt;- P}\n\</pre\>\nwhich traverses program \<code\>P\</code\> and constructs a set of all identifiers that occur on the left hand \nside of assignment statements in \<code\>P\</code\>.\n","\n","\n",[]),"Rascal/Expressions/Values/Set/toString":concept("toString",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/toString/toString.concept|,[],{"Library"},[],"Function: \<code\>str toString(set[&amp;T] s)\</code\>\n",{},"Converts a set to a string.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>toString({1, 2, 3});\nstr: \"{3,2,1}\"\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Set/StrictSubset":concept("StrictSubset",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/StrictSubset/StrictSubset.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\> &lt; \<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"\<","bool"},"Yields \<code\>true\</code\> if the value of \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\>\</code\> is a strict subset of the value of \<code\>\<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>,  and \<code\>false\</code\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3} &lt; {1, 2, 3, 4};\nbool: true\n\<b\>rascal\>\</b\>{1, 2, 3} &lt; {1, 3, 4};\nbool: false\n\<b\>rascal\>\</b\>{1, 2, 3} &lt; {1, 2, 3};\nbool: false\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:set[arb]\> \< \<B:same[A]\>","",false,false,[<"A",set(arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),loc(),dateTime()]))>,<"B",same("A")>],[],void(),""))]),"Rascal/Expressions/Operators/FieldSelection":concept("FieldSelection",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Operators/FieldSelection/FieldSelection.concept|,[],{},[],"Syntax: \<code\>\<i\>Exp\</i\> . \<i\>Name\</i\>\</code\>\n",{"."},"\nField selection applies to all values that have named components like tuples and relations with named elements, data types, and locations.\n\<code\>\<i\>Exp\</i\>\</code\> should evaluate to a tuple or datatype with field \<code\>\<i\>Name\</i\>\</code\> and returns the value of that field.\n\<code\>\<i\>Name\</i\>\</code\> stands for itself and is not evaluated.\n","\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>tuple[int key, str val] T = &lt;1, &quot;abc&quot;&gt;;\ntuple[int key,str val]: \<1,\"abc\"\>\n\<b\>rascal\>\</b\>T.val;\nstr: \"abc\"\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Map":concept("Map",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Map/Map.concept|,[],{"Language"},[],"\n",{},"\n","\n","\n","\n",[]),"Rascal/EASY":concept("EASY",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/EASY/EASY.concept|,[],{},[],"\n",{},"\<img width=\"300px\" height=\"300px\" align=\"right\"  alt=\"Easy Wokflow\" src=\"Courses/Rascal/EASY/easy-workflow.png\"\>\nMany meta-programming problems follow a fixed pattern. \nStarting with some input system (a black box that we usually call _system-of-interest_), \nfirst relevant information is extracted from it and stored in an internal representation. \nThis internal representation is then analyzed and used to synthesize results.\n If the synthesis indicates this, these steps can be repeated over and over again. These steps are shown in the following figure.\nThis is an abstract view on solving meta-programming problems, but is rather common.\n\nWe give some typical use cases in the details.\n","\n","\n","\n",[]),"Rascal/Expressions/Values/Set/in":concept("in",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/in/in.concept|,[],{"Language"},[],"\<ul\>\n\<li\>Syntax: \<code\>\<i\>Exp\</i\> in \<i\>SetExp\</i\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"bool","in"},"Yields \<code\>true\</code\> if the value of \<code\>\<i\>Exp\</i\>\</code\> occurs as element in the value of \<code\>\<i\>SetExp\</i\>\</code\> and \<code\>false\</code\> otherwise. The type of \<code\>\<i\>Exp\</i\>\</code\> should be compatible with the element type of \<code\>\<i\>SetExp\</i\>\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>2 in {1, 2, 3};\nbool: true\n\<b\>rascal\>\</b\>4 in {1, 2, 3};\nbool: false\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Number/LessThanOrEqual":concept("LessThanOrEqual",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/LessThanOrEqual/LessThanOrEqual.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\> &lt;= \<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"bool","\<="},"Yields \<code\>true\</code\> if the value of \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\>\</code\> is numerically less than or equal to the value of \<code\>\<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>, and \<code\>false\</code\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>13 &lt;= 12\nbool: false\n\<b\>rascal\>\</b\>12 &lt;= 13\nbool: true\n\<b\>rascal\>\</b\>13.5 &lt;= 12\nbool: false\n\<b\>rascal\>\</b\>12.5 &lt;= 13\nbool: true\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:int\> \<= \<B:int\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:real\> \<= \<B:real\>","",false,false,[<"A",real(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:num\> \<= \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("4",typeOfExpr(),details("\n",[],"","","\<A:num\> \<= \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("5",valueOfExpr(),details("\n",[],"","","\<A:num\> \<= \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),""))]),"Rascal/Expressions/Values/Number/Division":concept("Division",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/Division/Division.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\> / \<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>int\</code\> or \<code\>real\</code\>\</li\>\n\n\</ul\>\n",{"/"},"Yields the result of dividing the value of \<code\>\<i\>NumExp\</i\>1\</code\> by the value of \<code\>\<i\>NumExp\</i\>2\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>12 / 3\nint: 4\n\<b\>rascal\>\</b\>10 / 3\nint: 3\n\<b\>rascal\>\</b\>12 / 3.0\nreal: 4.\n\<b\>rascal\>\</b\>10 / 3.0\nreal: 3.333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333...\n\<b\>rascal\>\</b\>12 / 0\nUnexpected exception (generic Throwable): / by zero\nstacktrace: / by zero\n    at org.eclipse.imp.pdb.facts.impl.fast.IntegerValue.divide(IntegerValue.java:215)\n    at org.rascalmpl.interpreter.result.IntegerResult.divideInteger(IntegerResult.java:121)\n    at org.rascalmpl.interpreter.result.IntegerResult.divide(IntegerResult.java:41)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionDivision(Evaluator.java:2812)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionDivision(Evaluator.java:1)\n    at org.rascalmpl.ast.Expression$Division.accept(Expression.java:875)\n    at org.rascalmpl.interpreter.Evaluator.visitCommandExpression(Evaluator.java:1050)\n    at org.rascalmpl.interpreter.Evaluator.visitCommandExpression(Evaluator.java:1)\n    at org.rascalmpl.ast.Command$Expression.accept(Command.java:64)\n    at org.rascalmpl.interpreter.Evaluator.eval(Evaluator.java:779)\n    at org.rascalmpl.interpreter.Evaluator.eval(Evaluator.java:750)\n    at org.rascalmpl.interpreter.RascalShell.handleInput(RascalShell.java:153)\n    at org.rascalmpl.interpreter.RascalShell.run(RascalShell.java:91)\n    at org.rascalmpl.library.Scripting.shell(Scripting.java:69)\n    at org.rascalmpl.library.Scripting.shell(Scripting.java:97)\n    at sun.reflect.GeneratedMethodAccessor135.invoke(null:-1)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at org.rascalmpl.interpreter.result.JavaMethod.invoke(JavaMethod.java:105)\n    at org.rascalmpl.interpreter.result.JavaMethod.call(JavaMethod.java:69)\n    at org.rascalmpl.interpreter.result.OverloadedFunctionResult.call(OverloadedFunctionResult.java:83)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1746)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1)\n    at org.rascalmpl.ast.Expression$CallOrTree.accept(Expression.java:64)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1833)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Expression.accept(Statement.java:248)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementAssignment(Evaluator.java:2035)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementAssignment(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Assignment.accept(Statement.java:266)\n    at org.rascalmpl.interpreter.result.RascalFunction.call(RascalFunction.java:87)\n    at org.rascalmpl.interpreter.result.OverloadedFunctionResult.call(OverloadedFunctionResult.java:83)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1746)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1)\n    at org.rascalmpl.ast.Expression$CallOrTree.accept(Expression.java:64)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1833)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Expression.accept(Statement.java:248)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementAssignment(Evaluator.java:2035)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementAssignment(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Assignment.accept(Statement.java:266)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementNonEmptyBlock(Evaluator.java:2049)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementNonEmptyBlock(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$NonEmptyBlock.accept(Statement.java:532)\n    at org.rascalmpl.interpreter.Evaluator.matchAndEval(Evaluator.java:3264)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementSwitch(Evaluator.java:3331)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementSwitch(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Switch.accept(Statement.java:192)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementNonEmptyBlock(Evaluator.java:2049)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementNonEmptyBlock(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$NonEmptyBlock.accept(Statement.java:532)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementWhile(Evaluator.java:2331)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementWhile(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$While.accept(Statement.java:80)\n    at org.rascalmpl.interpreter.result.RascalFunction.call(RascalFunction.java:87)\n    at org.rascalmpl.interpreter.result.OverloadedFunctionResult.call(OverloadedFunctionResult.java:83)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1746)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1)\n    at org.rascalmpl.ast.Expression$CallOrTree.accept(Expression.java:64)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1833)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Expression.accept(Statement.java:248)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementReturn(Evaluator.java:1929)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementReturn(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Return.accept(Statement.java:327)\n    at org.rascalmpl.interpreter.result.RascalFunction.call(RascalFunction.java:87)\n    at org.rascalmpl.interpreter.result.OverloadedFunctionResult.call(OverloadedFunctionResult.java:83)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1746)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1)\n    at org.rascalmpl.ast.Expression$CallOrTree.accept(Expression.java:64)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1833)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Expression.accept(Statement.java:248)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementAssignment(Evaluator.java:2035)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementAssignment(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Assignment.accept(Statement.java:266)\n    at org.rascalmpl.interpreter.result.RascalFunction.call(RascalFunction.java:87)\n    at org.rascalmpl.interpreter.result.OverloadedFunctionResult.call(OverloadedFunctionResult.java:83)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1746)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1)\n    at org.rascalmpl.ast.Expression$CallOrTree.accept(Expression.java:64)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1833)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Expression.accept(Statement.java:248)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementReturn(Evaluator.java:1929)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementReturn(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Return.accept(Statement.java:327)\n    at org.rascalmpl.interpreter.result.RascalFunction.call(RascalFunction.java:87)\n    at org.rascalmpl.interpreter.result.OverloadedFunctionResult.call(OverloadedFunctionResult.java:83)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1746)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1)\n    at org.rascalmpl.ast.Expression$CallOrTree.accept(Expression.java:64)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1833)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Expression.accept(Statement.java:248)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementReturn(Evaluator.java:1929)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementReturn(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Return.accept(Statement.java:327)\n    at org.rascalmpl.interpreter.result.RascalFunction.call(RascalFunction.java:87)\n    at org.rascalmpl.interpreter.result.OverloadedFunctionResult.call(OverloadedFunctionResult.java:83)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1746)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1)\n    at org.rascalmpl.ast.Expression$CallOrTree.accept(Expression.java:64)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1833)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Expression.accept(Statement.java:248)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementAssignment(Evaluator.java:2035)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementAssignment(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Assignment.accept(Statement.java:266)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementNonEmptyBlock(Evaluator.java:2049)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementNonEmptyBlock(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$NonEmptyBlock.accept(Statement.java:532)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementFor(Evaluator.java:3978)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementFor(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$For.accept(Statement.java:55)\n    at org.rascalmpl.interpreter.result.RascalFunction.call(RascalFunction.java:87)\n    at org.rascalmpl.interpreter.result.OverloadedFunctionResult.call(OverloadedFunctionResult.java:83)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1746)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1)\n    at org.rascalmpl.ast.Expression$CallOrTree.accept(Expression.java:64)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1833)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Expression.accept(Statement.java:248)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementAssignment(Evaluator.java:2035)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementAssignment(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Assignment.accept(Statement.java:266)\n    at org.rascalmpl.interpreter.result.RascalFunction.call(RascalFunction.java:87)\n    at org.rascalmpl.interpreter.result.OverloadedFunctionResult.call(OverloadedFunctionResult.java:83)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1746)\n    at org.rascalmpl.interpreter.Evaluator.visitExpressionCallOrTree(Evaluator.java:1)\n    at org.rascalmpl.ast.Expression$CallOrTree.accept(Expression.java:64)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1833)\n    at org.rascalmpl.interpreter.Evaluator.visitStatementExpression(Evaluator.java:1)\n    at org.rascalmpl.ast.Statement$Expression.accept(Statement.java:248)\n    at org.rascalmpl.interpreter.Evaluator.eval(Evaluator.java:674)\n    at org.rascalmpl.interpreter.Evaluator.visitCommandStatement(Evaluator.java:1040)\n    at org.rascalmpl.interpreter.Evaluator.visitCommandStatement(Evaluator.java:1)\n    at org.rascalmpl.ast.Command$Statement.accept(Command.java:48)\n    at org.rascalmpl.interpreter.Evaluator.eval(Evaluator.java:779)\n    at org.rascalmpl.interpreter.Evaluator.eval(Evaluator.java:750)\n    at org.rascalmpl.interpreter.RascalShell.handleInput(RascalShell.java:153)\n    at org.rascalmpl.interpreter.RascalShell.run(RascalShell.java:91)\n    at org.rascalmpl.interpreter.RascalShell.main(RascalShell.java:194)\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:int\> / \<B:int\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:int\> / \<B:real\>","",false,false,[<"A",int(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:real\> / \<B:int\>","",false,false,[<"A",real(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",[],"","","\<A:num\> / \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),""))]),"Rascal/Expressions/Values/Set/notin":concept("notin",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/notin/notin.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>Exp\</i\> notin \<i\>SetExp\</i\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"bool","notin"},"Yields \<code\>true\</code\> if the value of \<code\>\<i\>Exp\</i\>\</code\> does not occur as element in the value of \<code\>\<i\>SetExp\</i\>\</code\> and \<code\>false\</code\> otherwise. The type of \<code\>\<i\>Exp\</i\>\</code\> should be compatible with the element type of \<code\>\<i\>SetExp\</i\>\</code\>.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>4 notin {1, 2, 3};\nbool: true\n\<b\>rascal\>\</b\>4 notin {1, 2, 3, 4};\nbool: false\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Number/NotEqual":concept("NotEqual",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/NotEqual/NotEqual.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\> != \<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>int\</code\> or \<code\>real\</code\>\</li\>\n\n\</ul\>\n",{"!="},"Yields \<code\>true\</code\> if the value of both arguments is numerically unequal, and \<code\>false\</code\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>12 != 13\nbool: true\n\<b\>rascal\>\</b\>12 != 12\nbool: false\n\<b\>rascal\>\</b\>12 != 13.0\nbool: true\n\<b\>rascal\>\</b\>12.0 != 13\nbool: true\n\<b\>rascal\>\</b\>3.14 != 3\nbool: true\n\<b\>rascal\>\</b\>3.14 != 3.14\nbool: false\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:int\> != \<B:int\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:real\> != \<B:real\>","",false,false,[<"A",real(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:num\> != \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("4",typeOfExpr(),details("\n",[],"","","\<A:num\> != \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("5",valueOfExpr(),details("\n",[],"","","\<A:num\> != \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),""))]),"Rascal/Expressions/Values/Set/StrictSuperset":concept("StrictSuperset",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/StrictSuperset/StrictSuperset.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\> \> \<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"\>","bool"},"Yields \<code\>true\</code\> if the vaue of \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\>\</code\> is a strict superset of the value of \<code\>\<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>, and \<code\>false\</code\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3, 4} &gt; {3, 2, 1};\nbool: true\n\<b\>rascal\>\</b\>{1, 2, 3, 4} &gt; {4, 3, 2, 1};\nbool: false\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:set[arb]\> \> \<B:same[A]\>","",false,false,[<"A",set(arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),loc(),dateTime()]))>,<"B",same("A")>],[],void(),""))]),"Rascal/Expressions/Operators/FieldProjection":concept("FieldProjection",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Operators/FieldProjection/FieldProjection.concept|,[],{},[],"Syntax: \<code\>\<i\>Exp\</i\> &lt; \<i\>Field\</i\>\<sub\>1\</sub\>, \<i\>Field\</i\>\<sub\>2\</sub\> ... \>\</code\>\n",{"\>","...",",","\<"},"\n\<code\>\<i\>Exp\</i\>\</code\> should evaluate to a tuple or relation, and \<code\>\<i\>Field\</i\>\<sub\>i\</sub\>\</code\> should be a field name or an integer constant\n that refers to elements in the order in which they occur in the original value (counting from 0). \n","\nSuppose we have a relation with traffic information that records the name of the day, the day number, and the length of the traffic jams at that day.\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>rel[str day, int daynum, int length] Traffic = \n\>\>\>\>\>\>\>{\<\"mon\", 1, 100\>, \<\"tue\", 2, 150\>, \<\"wed\", 3, 125\>, \n\>\>\>\>\>\>\> \<\"thur\", 4, 110\>, \<\"fri\", 5, 90\>};\nrel[str day, int daynum, int length]: {\<\"wed\",3,125\>,\<\"mon\",1,100\>,\<\"fri\",5,90\>,\<\"thur\",4,110\>,\<\"tue\",2,150\>}\n\<b\>rascal\>\</b\>Traffic&lt;length,daynum&gt;;\nrel[int length, int daynum]: {\<150,2\>,\<100,1\>,\<110,4\>,\<125,3\>,\<90,5\>}\n\<b\>rascal\>\</b\>Traffic&lt;2,day&gt;;\nrel[int length, str day]: {\<100,\"mon\"\>,\<90,\"fri\"\>,\<150,\"tue\"\>,\<125,\"wed\"\>,\<110,\"thur\"\>}\n\</pre\>Field projection thus selects parts from a larger value that has a fixed number of parts. The selection is based on position and not on value and can be used to completely reorder or remove the parts of a larger value.\n","\n","\n",[]),"Rascal/Expressions/Values/Set/Union":concept("Union",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/Union/Union.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> + \<i\>Exp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>set[\<i\>Type\</i\>]\</code\>\</li\>\n\n\</ul\>\n",{"+","set["},"If both \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\> and \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\> have a set as value, the result is the union of these two set values. If one of \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\> or \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\> does not have a set as value, it is first converted to a set before the union is computed.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3} + {4, 5, 6};\nset[int]: {6,5,4,3,2,1}\n\<b\>rascal\>\</b\>{1, 2, 3} + 4;\nset[int]: {4,3,2,1}\n\<b\>rascal\>\</b\>1 + { 2, 3, 4};\nset[int]: {4,3,2,1}\n\</pre\>","\n","\n",[choiceQuestion("1"," When you compute the union of two sets, the number of elements in the result is always:\n",[good("Greater than or equal the number of elements in both sets."),bad("Greater than the number of elements in both sets."),bad("Smaller than the number of elements in both sets."),bad("Smaller than or equal the number of elements in both sets.")]),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:set[arb[int,str,real]]\> + \<B:same[A]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str(),real(-20,20)]))>,<"B",same("A")>],[],void(),"")),tvQuestion("3",valueOfExpr(),details("\n",[],"","","\<A:set[arb[int,str,real]]\> + \<B:same[A]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str(),real(-20,20)]))>,<"B",same("A")>],[],void(),"")),tvQuestion("4",valueOfExpr(),details("\n",[],"","","\<A\> + "," == \<C\>",false,true,[<"A",set(arb(0,[int(-20,20),str()]))>,<"B",same("A")>],[<"C","\<A\> + \<B\>">],void(),"\<B\>")),tvQuestion("5",valueOfExpr(),details("\n",[],"","","\<A:set[arb[0,int,str,num,real]]\> + \<B:same[A]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str(),num(-20,20),real(-20,20)]))>,<"B",same("A")>],[],void(),""))]),"Rascal/Examples":concept("Examples",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Examples/Examples.concept|,[],{"Example"},[],"\n",{},"\n","\n","\n","\n",[]),"Rascal/Expressions/Operators/FieldAssignment":concept("FieldAssignment",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Operators/FieldAssignment/FieldAssignment.concept|,[],{},["FieldSelection"],"Syntax: \<code\>\<i\>Exp\</i\>\<sub\>1\</sub\> [ \<i\>Name\</i\> = \<i\>Exp\</i\>\<sub\>2\</sub\> ]\</code\>\n",{"]","=","["},"\n\<code\>\<i\>Exp\</i\>\<sub\>1\</sub\>\</code\> should evaluate to a tuple or datatype with a field \<code\>\<i\>Name\</i\>\</code\>; assign the value of \<code\>\<i\>Exp\</i\>\<sub\>2\</sub\>\</code\> to that field\n\nField assignment applies to all values that have named components like tuples and relations with named elements, data types, and locations. \nField assignment returns a new value in which the named component has been replaced by a new value.\n\<code\>\<i\>Name\</i\>\</code\> stands for itself and is not evaluated.\n","\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>tuple[int key, str val] T = &lt;1, &quot;abc&quot;&gt;;\ntuple[int key,str val]: \<1,\"abc\"\>\n\<b\>rascal\>\</b\>T[val = &quot;def&quot;];\ntuple[int key,str val]: \<1,\"def\"\>\n\<b\>rascal\>\</b\> T;\ntuple[int key,str val]: \<1,\"abc\"\>\n\</pre\>\nObserve that field assignment creates a new value with an updated field. The old value remains unchanged as can be seen from the unchanged value of T in the above example.\n","\n","\n",[]),"Rascal/Expressions/Values/Set/Join":concept("Join",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/Join/Join.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\> join \<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>set[\<i\>Type\</i\>]\</code\>\</li\>\n\n\</ul\>\n",{"join","set["},"Relation resulting from the natural join of the set values of the two arguments.\nThis relation contains tuples that are the result from concatenating the elements from both arguments.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{&lt;1,2&gt;, &lt;10,20&gt;} join {&lt;2,3&gt;};\nrel[int, int, int, int]: {\<1,2,2,3\>,\<10,20,2,3\>}\n\<b\>rascal\>\</b\>{&lt;1,2&gt;} join {3, 4};\nrel[int, int, int]: {\<1,2,4\>,\<1,2,3\>}\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:set[tuple[arb[int,str]]]\> join \<B:set[tuple[arb,str,int]]\>","",false,false,[<"A",set(tuple([arb(0,[int(-20,20),str()])]))>,<"B",set(tuple([arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),loc(),dateTime()]),str(),int(-20,20)]))>],[],void(),"")),tvQuestion("2",valueOfExpr(),details("\n",[],"","","\<A:set[tuple[arb[int,str]]]\> join \<B:set[tuple[arb,str,int]]\>","",false,false,[<"A",set(tuple([arb(0,[int(-20,20),str()])]))>,<"B",set(tuple([arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),loc(),dateTime()]),str(),int(-20,20)]))>],[],void(),""))]),"Rascal/Expressions/Values/Number/toReal":concept("toReal",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/toReal/toReal.concept|,[],{"Library"},["Real"],"Function: \<code\>real toReal(num n)\</code\>\n",{},"Convert a number to a real\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Number;\nok\n\<b\>rascal\>\</b\>toReal(12)\nreal: 12.0\n\<b\>rascal\>\</b\>toReal(3.14)\nreal: 3.14\n\</pre\>","\n","\n",[]),"Rascal/EASY/Concurrency":concept("Concurrency",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/EASY/Concurrency/Concurrency.concept|,[],{"Example"},[],"\n",{},"\n_Daniel_ is a concurrency researcher at one of the largest hardware manufacturers worldwide. He is working from an office in the Bay Area. Concurrency is the big issue for his company: it is becoming harder and harder to make CPUs faster, therefore more and more of them are bundled on a single chip. Programming these multi-core chips is difficult and many programs that worked fine on a single CPU contain hard to detect concurrency errors due to subtle differences in the order of execution that results from executing the code on more than one CPU. Here is where Daniel enters the picture. He is working on tools for finding concurrency errors. First he extracts facts from the code that are relevant for concurrency problems and have to do with calls, threads, shared variables and locks. Next, he analyzes these facts and synthesizes an abstract model that captures the essentials of the concurrency behaviour of the program. Finally he runs a third-party verification tool with this model as input to do the actual verification.\n","\n","\n","\n",[]),"Rascal/Expressions/Values/Integer":concept("Integer",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Integer/Integer.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: sequence of digits of arbitrary length.\</li\>\n\<li\> Type: \<code\>int\</code\>\</li\>\n\n\</ul\>\n",{"int"},"The integer values are represented by the type \<tt\>int\</tt\> and are written as usual. They can be arbitrarily large.\n","\<ul\>\n\<li\> \<tt\>12\</tt\>\</li\>\n\<li\> \<tt\>0\</tt\>\</li\>\n\<li\> \<tt\>-123456789\</tt\>\</li\>\n\n\</ul\>\n","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:int\>","",false,false,[<"A",int(-20,20)>],[],void(),""))]),"Rascal/Expressions/Values/Number/GreaterThan":concept("GreaterThan",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/GreaterThan/GreaterThan.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\> \> \<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"\>","bool"},"Yields \<code\>true\</code\> if the value of \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\>\</code\> is numerically greater than the value of \<code\>\<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>, and \<code\>false\</code\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>13 &gt; 12\nbool: true\n\<b\>rascal\>\</b\>12 &gt; 13\nbool: false\n\<b\>rascal\>\</b\>13.5 &gt; 12\nbool: true\n\<b\>rascal\>\</b\>12.5 &gt; 13\nbool: false\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:int\> \> \<B:int\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:real\> \> \<B:real\>","",false,false,[<"A",real(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:num\> \> \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("4",typeOfExpr(),details("\n",[],"","","\<A:num\> \> \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("5",valueOfExpr(),details("\n",[],"","","\<A:num\> \> \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),""))]),"Rascal/Expressions/Values/Set/Conditional":concept("Conditional",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/Conditional/Conditional.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>( \<i\>BoolExp\</i\> ) ? \<i\>SetExp\</i\>\<sub\>1\</sub\> : \<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>set[\<i\>Type\</i\>]\</code\>\</li\>\n\n\</ul\>\n",{"?",":","set[",")","("},"Yields the value of \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\>\</code\> if the value of \<code\>\<i\>BoolExp\</i\>\</code\> is \<code\>true\</code\> and the value of \<code\>\<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\> otherwise. \n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>( 3 &gt; 2 ) ? {1, 2} : {3, 4};\nset[int]: {2,1}\n\<b\>rascal\>\</b\>( 3 &lt; 2 ) ? {1, 2} : {3, 4};\nset[int]: {4,3}\n\</pre\>","\n","\n",[]),"Rascal/Concepts/StaticTyping":concept("StaticTyping",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Concepts/StaticTyping/StaticTyping.concept|,[],{"Language"},["Boolean","Integer","Real","Set","Map"],"\n",{},"Rascal is based on static typing, this means that as many errors and inconsistencies as possible are spotted before the program is executed. The types are ordered in a so-called _type lattice_ shown in the following figure. \<br\>\n\n\<img align=\"right\" width=\"400px\" height=\"400px\"  alt=\"Type Lattice\" src=\"Courses/Rascal/Concepts/StaticTyping/type-lattice.png\"\>\n\<br\>\nThe arrows describe a _subtype-of_ relation between types. The type \<code\>void\</code\> is the _smallest_ type and \nis included in all other types and the type \<code\>value\</code\> is the _largest_ type that includes all other types. \nWe also see that \<code\>rel\</code\> is a subtype of \<code\>set\</code\> and that each ADT is a subtype of \<code\>node\</code\>. \nA special role is played by the datatype \<tt\>Tree\</tt\> that is the generic type of syntax trees. \nSyntax trees for specific languages are all subtypes of \<code\>Tree\</code\>. As a result, syntax trees can be addressed at two levels: \n\<ul\>\n\<li\> in a generic fashion as \<code\>Tree\</code\> and,\</li\>\n\<li\> in a specific fashion as a more precisely typed syntax tree.  Finally, each \<code\>alias\</code\> is structurally equivalent to one or more specific other types.\</li\>\n\n\</ul\>\n","\n","\n","\n",[]),"Rascal/Statements/if":concept("if",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Statements/if/if.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>if ( \<i\>BoolExp\</i\> ) \<i\>Statement\</i\>\</code\>\</li\>\n\<li\> Syntax: \<code\>if ( \<i\>BoolExp\</i\> ) \<i\>Statement\</i\>\<sub\>1\</sub\> else \<i\>Statement\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\n\</ul\>\n",{"if","else",")","("},"The test \<code\>\<i\>BoolExp\</i\>\</code\> is evaluated and its outcome determines the statement to be executed: \<code\>\<i\>Statement\</i\>\<sub\>1\</sub\>\</code\> if \<code\>\<i\>BoolExp\</i\>\</code\> is \<code\>true\</code\> and \<code\>\<i\>Statement\</i\>\<sub\>2\</sub\>\</code\> otherwise. The value of an if-then statement is equal to \<code\>\<i\>Statement\</i\>\</code\> when its test is true. Otherwise it is void.\nThe value of an if-then-else statement is the value of the statement that was executed.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>if( 3 &gt; 2 ) 30; else 40;\nint: 30\n\<b\>rascal\>\</b\>if( 3 &gt; 2 ) 30;\nint: 30\n\</pre\>\n An if-then statement yields \<code\>void\</code\>  when its test is false\n (demonstrated by the __ok__ that is printed by the Rascal system):\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>if( 2 &gt; 3 ) 30;\nok\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","if( \<A:int\> \> \<B:int\> ) 10; else 20;","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","if( \<A:int\> \> \<B:int\> ) \<C:str\>; else \<D:str\>;","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>,<"C",str()>,<"D",str()>],[],void(),"")),tvQuestion("3",valueOfExpr(),details("\n",[],"","","if( \<A:int\> \> \<B:int\> ) 10; else 20;","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),""))]),"Rascal/Expressions/Values/Set/max":concept("max",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/max/max.concept|,[],{"Library"},[],"Function: \<code\>&amp;T max(set[&amp;T] s)\</code\>\n",{},"Returns the largest element from a set.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>import Set;\nok\n\<b\>rascal\>\</b\>max({1, 3, 5, 2, 4});\nint: 5\n\</pre\>","\n","\n",[]),"Rascal/Expressions/Values/Set/NotEqual":concept("NotEqual",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/NotEqual/NotEqual.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>SetExp\</i\>\<sub\>1\</sub\> != \<i\>SetExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"!=","bool"},"Yields \<tt\>true\</tt\> if both arguments are unequal sets and \<tt\>false\</tt\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3} != {3, 2, 1};\nbool: false\n\<b\>rascal\>\</b\>{1, 2, 3} != {1, 2};\nbool: true\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:set[arb]\> != \<B:same[A]\>","",false,false,[<"A",set(arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),loc(),dateTime()]))>,<"B",same("A")>],[],void(),""))]),"Rascal/Expressions/Values/Number/Equal":concept("Equal",|file:///Users/paulklint/software/source/roll/rascal/src/org/rascalmpl/library/experiments/RascalTutor/Courses/Rascal/Expressions/Values/Number/Equal/Equal.concept|,[],{"Language"},[],"\<ul\>\n\<li\> Syntax: \<code\>\<i\>NumExp\</i\>\<sub\>1\</sub\> == \<i\>NumExp\</i\>\<sub\>2\</sub\>\</code\>\</li\>\n\<li\> Type: \<code\>bool\</code\>\</li\>\n\n\</ul\>\n",{"bool","=="},"Yields \<tt\>true\</tt\> if the value of both arguments is numerically equal, and \<tt\>false\</tt\> otherwise.\n","\<pre class=\"screen\"\>\<b\>rascal\>\</b\>12 == 12\nbool: true\n\<b\>rascal\>\</b\>12 == 12.0\nbool: true\n\<b\>rascal\>\</b\>12 == 13\nbool: false\n\<b\>rascal\>\</b\>12 == 13.0\nbool: false\n\<b\>rascal\>\</b\>3.14 == 3.14\nbool: true\n\<b\>rascal\>\</b\>3.14 == 3\nbool: false\n\</pre\>","\n","\n",[tvQuestion("1",typeOfExpr(),details("\n",[],"","","\<A:int\> == \<B:int\>","",false,false,[<"A",int(-20,20)>,<"B",int(-20,20)>],[],void(),"")),tvQuestion("2",typeOfExpr(),details("\n",[],"","","\<A:real\> == \<B:real\>","",false,false,[<"A",real(-20,20)>,<"B",real(-20,20)>],[],void(),"")),tvQuestion("3",typeOfExpr(),details("\n",[],"","","\<A:num\> == \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("4",typeOfExpr(),details("\n",[],"","","\<A:num\> == \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),"")),tvQuestion("5",valueOfExpr(),details("\n",[],"","","\<A:num\> == \<B:num\>","",false,false,[<"A",num(-20,20)>,<"B",num(-20,20)>],[],void(),""))])),{<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/min">,<"Rascal/Concepts","Rascal/Concepts/Enumerators">,<"Rascal/EASY","Rascal/EASY/Forensics">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/StrictSubset">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/isEmpty">,<"Rascal/Expressions/Values","Rascal/Expressions/Values/Set">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/power1">,<"Rascal/Concepts","Rascal/Concepts/CaseDistinction">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/GreaterThanOrEqual">,<"Rascal/Concepts","Rascal/Concepts/StaticTyping">,<"Rascal/Expressions/Values","Rascal/Expressions/Values/Real">,<"Rascal/Expressions/Operators","Rascal/Expressions/Operators/FieldSelection">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/Addition">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/Equal">,<"Rascal/Concepts","Rascal/Concepts/EquationSolving">,<"Rascal/Expressions","Rascal/Expressions/Operators">,<"Rascal/Concepts","Rascal/Concepts/Functions">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/NotEqual">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/Equal">,<"Rascal/Expressions/Patterns","Rascal/Expressions/Patterns/Concrete">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/power">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/GreaterThan">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/Subtraction">,<"Rascal/Concepts","Rascal/Concepts/Datatypes">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/Negation">,<"Rascal/Statements","Rascal/Statements/if">,<"Rascal/Concepts","Rascal/Concepts/SyntaxDefinitionAndParsing">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/reducer">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/toString">,<"Rascal/EASY","Rascal/EASY/Security">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/NotEqual">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/LessThanOrEqual">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/Subset">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/toInt">,<"Rascal","Rascal/Statements">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/arbReal">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/mapper">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/toMap">,<"Rascal/Expressions/Values","Rascal/Expressions/Values/Map">,<"Rascal/Concepts","Rascal/Concepts/RewriteRules">,<"Rascal/Expressions/Patterns","Rascal/Expressions/Patterns/Regular">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/Join">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/getOneFrom">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/Superset">,<"Rascal/Expressions/Values","Rascal/Expressions/Values/String">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/min">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/Division">,<"Rascal/Expressions/Operators","Rascal/Expressions/Operators/Subscription">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/takeOneFrom">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/Conditional">,<"Rascal/Expressions/Operators","Rascal/Expressions/Operators/FieldProjection">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/StrictSuperset">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/Difference">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/size">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/toList">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/Multiplication">,<"Rascal/EASY","Rascal/EASY/Concurrency">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/arbInt">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/max">,<"Rascal/Concepts","Rascal/Concepts/Comprehensions">,<"Rascal","Rascal/Concepts">,<"Rascal/EASY","Rascal/EASY/Renovation">,<"Rascal/Expressions/Patterns","Rascal/Expressions/Patterns/Abstract">,<"Rascal/Expressions/Values","Rascal/Expressions/Values/Number">,<"Rascal/Expressions/Values","Rascal/Expressions/Values/Void">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/LessThan">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/toMapUnique">,<"Rascal/Examples","Rascal/Examples/Hello">,<"Rascal/Expressions/Values","Rascal/Expressions/Values/Value">,<"Rascal","Rascal/Examples">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/in">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/Intersection">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/notin">,<"Rascal","Rascal/EASY">,<"Rascal/Expressions","Rascal/Expressions/Values">,<"Rascal/Expressions/Values","Rascal/Expressions/Values/Integer">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/Remainder">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/Union">,<"Rascal/Examples","Rascal/Examples/Factorial">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/toString">,<"Rascal/Expressions/Values","Rascal/Expressions/Values/Boolean">,<"Rascal/Expressions/Values","Rascal/Expressions/Values/DateTime">,<"Rascal/Expressions/Operators","Rascal/Expressions/Operators/FieldAssignment">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/toReal">,<"Rascal/Expressions","Rascal/Expressions/Patterns">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/abs">,<"Rascal/Concepts","Rascal/Concepts/ImmutableValues">,<"Rascal/Concepts","Rascal/Concepts/ControlStructures">,<"Rascal/Expressions/Values/Number","Rascal/Expressions/Values/Number/max">,<"Rascal","Rascal/Expressions">,<"Rascal/Examples","Rascal/Examples/ColoredTrees">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/Conditional">,<"Rascal/Expressions/Values/Set","Rascal/Expressions/Values/Set/Product">,<"Rascal/Concepts","Rascal/Concepts/PatternMatching">,<"Rascal/EASY","Rascal/EASY/ModelDrivenEngineering">,<"Rascal/Concepts","Rascal/Concepts/Visiting">,<"Rascal/Expressions/Values","Rascal/Expressions/Values/Location">},["!=","%","&","(",")","*","+",",","-",".","...","....","/",":","\<","\<=","=","==","\>","\>=","?","Abstract","Addition","Boolean","CaseDistinction","ColoredTrees","Comprehensions","Concepts","Concrete","Concurrency","Conditional","ControlStructures","Datatypes","DateTime","Difference","Division","EASY","Enumerators","Equal","EquationSolving","Examples","Expressions","Factorial","FieldAssignment","FieldProjection","FieldSelection","Forensics","Functions","GreaterThan","GreaterThanOrEqual","Hello","ImmutableValues","Integer","Intersection","Join","LessThan","LessThanOrEqual","Location","Map","ModelDrivenEngineering","Multiplication","Negation","NotEqual","Number","Operators","PatternMatching","Patterns","Product","Rascal","Real","Regular","Remainder","Renovation","RewriteRules","Security","Set","Statements","StaticTyping","StrictSubset","StrictSuperset","String","Subscription","Subset","Subtraction","Superset","SyntaxDefinitionAndParsing","Union","Value","Values","Visiting","Void","[","]","abs","arbInt","arbReal","bool","dateTime","else","getOneFrom","if","in","int","isEmpty","join","loc","mapper","max","min","notin","power","power1","reducer","set[","size","str","takeOneFrom","toInt","toList","toMap","toMapUnique","toReal","toString","value","void","{","}"],("Integer":"Rascal/Expressions/Values/Integer","Real":"Rascal/Expressions/Values/Real","Map":"Rascal/Expressions/Values/Map","Boolean":"Rascal/Expressions/Values/Boolean","Set":"Rascal/Expressions/Values/Set","FieldSelection":"Rascal/Expressions/Operators/FieldSelection"),{"Library","Example","Language"})
concept("Set",|std:///experiments/RascalTutor/Courses/Rascal/Expressions/Values/Set/Set.concept|,[],[],{"Language"},{},""," \<code\>\n  { \<i\>Exp\</i\>\<sub\>1\</sub\>, \<i\>Exp\</i\>\<sub\>2\</sub\>, ... }\n\</code\>\n"," \<table\>\n  \<col align=\"left\" /\>\<col align=\"left\" /\>\<col align=\"left\" /\>\<col align=\"left\" /\>\<tr\>\<th align=\"left\"\>  \<code\>\n    \<i\>Exp\</i\>\<sub\>1\</sub\>\n  \</code\> \</th\>\<th align=\"left\"\>  \<code\>\n    \<i\>Exp\</i\>\<sub\>2\</sub\>\n  \</code\> \</th\>\<th align=\"left\"\>  ...  \</th\>\<th align=\"left\"\>  \<code\>\n    { \<i\>Exp\</i\>\<sub\>1\</sub\>, \<i\>Exp\</i\>\<sub\>2\</sub\>, ... }\n  \</code\>   \</th\>\</tr\>\<tr\>\<td align=\"left\"\>\n     \<code\>\n      \<i\>T\</i\>\<sub\>1\</sub\>\n    \</code\>    \n  \</td\>\<td align=\"left\"\>\n     \<code\>\n      \<i\>T\</i\>\<sub\>2\</sub\>\n    \</code\>    \n  \</td\>\<td align=\"left\"\>\n      ...  \n  \</td\>\<td align=\"left\"\>\n      \<code\>\n      set[ lub(\<i\>T\</i\>\<sub\>1\</sub\>, \<i\>T\</i\>\<sub\>2\</sub\>, ... ) ]\n    \</code\> \n  \</td\>\</tr\>\n\</table\>","",{"]","}",",","[","{","lub",")","(","set"}," A set is an unordered sequence of values and has the following properties:\n  \<ul\>\n  \<li\> All elements have the same static type.\</li\>\n  \<li\> The order of the elements does not matter.\</li\>\n  \<li\> A set contains an element only once. In other words, duplicate elements are eliminated and no    matter how many times an element is added to a set, it will occur in it only once.\n  \</li\>\n  \n\</ul\> The type of a set has the form \<code\>\n  set[\<i\>T\</i\>]\n\</code\>,\n where \<code\>\n  \<i\>T\</i\>\n\</code\> is an arbitrary type.\n \<br/\>\n\<br/\>\n\n When variables of type set occur inside a set, their elements are automatically \<i\>spliced\</i\> into the surrounding set. This can be prevented by surrounding them with extra \<code\>\n  {\n\</code\> and \<code\>\n  }\n\</code\> brackets. Note that this approach is atypical: in Rascal splicing is implicit while in other languages it has to be indicated explicitly by the programmer.\n"," \<h1\> Set types \</h1\> \<pre class=\"screen\"\>\<b\>rascal\>\</b\>{1, 2, 3};\nset[int]: {3,2,1}\n\<b\>rascal\>\</b\>{&lt;1,10&gt;, &lt;2,20&gt;, &lt;3,30&gt;};\nrel[int, int]: {\n  &lt;2,20&gt;,\n  &lt;1,10&gt;,\n  &lt;3,30&gt;\n}\n\<b\>rascal\>\</b\>{1, &quot;b&quot;, 3};\nset[value]: {3,&quot;b&quot;,1}\n\<b\>rascal\>\</b\>{&lt;&quot;a&quot;, 10&gt;, &lt;&quot;b&quot;, 20&gt;, &lt;&quot;c&quot;, 30&gt;}\nrel[str, int]: {\n  &lt;&quot;b&quot;,20&gt;,\n  &lt;&quot;a&quot;,10&gt;,\n  &lt;&quot;c&quot;,30&gt;\n}\n\<b\>rascal\>\</b\>{{&quot;a&quot;, &quot;b&quot;}, {&quot;c&quot;, &quot;d&quot;, &quot;e&quot;}}\nset[set[str]]: {\n  {&quot;b&quot;,&quot;a&quot;},\n  {&quot;e&quot;,&quot;d&quot;,&quot;c&quot;}\n}\n\</pre\> Note that\n \<ul\>\n  \<li\> \<code\>\n    {1, 2, 3}\n  \</code\> and \<code\>\n    {3, 2, 1}\n  \</code\> are identical sets (since order is not relevant).\</li\>\n  \<li\> \<code\>\n     {1, 2, 3}\n  \</code\> and \<code\>\n    {1, 2, 3, 1}\n  \</code\> are also identical sets (since duplication is not relevant).\</li\>\n  \n\</ul\>  \<h1\> Set splicing \</h1\> \<pre class=\"screen\"\>\</pre\>\n Introduce a set variable \<tt\>S\</tt\>\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>S = {1, 2, 3};\nset[int]: {3,2,1}\n\</pre\>\n  and observe how \<code\>\n  S\n\</code\> is spliced in another set\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{10, S, 20};\nset[int]: {10,20,3,2,1}\n\</pre\>\n or becomes a subset when it is surrounded with extra braces\n\n\<pre class=\"screen\"\>\<b\>rascal\>\</b\>{10, {S}, 20};\nset[value]: {\n  10,\n  20,\n  {3,2,1}\n}\n\</pre\>","","",[choiceQuestion("1","  Sets can be used to represent a sequence of values when\n",[good("The values have no duplicates and no order."),bad("The values have duplicates."),bad("The values are unordered.")]),choiceQuestion("2","  The type of a set is determined by:\n",[good("The upperbound of the type of all elements."),bad("The type of the first element that was first added to the set."),bad("The upperbound of the type of two arbitrary elements.")]),tvQuestion("3",typeOfExpr(),details(" ",[],"","","{1, "," }",false,true,[],[],set(int(-20,20)),"one or more integer values separated by commas")),tvQuestion("4",typeOfExpr(),details(" ",[],"","","\<A:set[arb]\>","",false,false,[<"A",set(arb(0,[bool(),int(-20,20),real(-20,20),num(-20,20),str(),\loc(),datetime()]))>],[],void(),"")),tvQuestion("5",typeOfExpr(),details(" ",[],"","","{\<A:int\>, \<B:str\>, \<C:int\>}","",false,false,[<"A",int(-20,20)>,<"B",str()>,<"C",int(-20,20)>],[],void(),""))])
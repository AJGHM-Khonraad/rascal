concept("IntroDatatypes",|std:///experiments/RascalTutor/Courses/Rascal/Concepts/IntroDatatypes/IntroDatatypes.concept|,[],[],{},{"List","Real","Integer","Relation","Map","DateTime","Number","Tuple","Boolean","Location","Node","Set","String","Declarations/AlgebraicDataType"},"","","","",{}," Rascal provides a rich set of datatypes:\n \<ul\>\n  \<li\> \<a href=\"/show?concept=Boolean\"\>Boolean\</a\> (\<code\>\n    bool\n  \</code\>).\</li\>\n  \<li\> Infinite precision \<a href=\"/show?concept=Integer\"\>Integer\</a\> (\<code\>\n    int\n  \</code\>), \<a href=\"/show?concept=Real\"\>Real\</a\> (\<code\>\n    real\n  \</code\>), and \<a href=\"/show?concept=Number\"\>Number\</a\> (\<code\>\n    num\n  \</code\>).\</li\>\n  \<li\> \<a href=\"/show?concept=String\"\>String\</a\>s (\<code\>\n    str\n  \</code\>) that can act as templates with embedded expressions and statements. \</li\>\n  \<li\> Source code \<a href=\"/show?concept=Location\"\>Location\</a\>s (\<code\>\n    loc\n  \</code\>) based on an extension of Universal Resource Identifiers (URI) that allow precise description of text areas in local and remote files.\</li\>\n  \<li\> Date and time values (\<a href=\"/show?concept=DateTime\"\>DateTime\</a\>, \<code\>\n    datetime\n  \</code\>).\</li\>\n  \<li\> \<a href=\"/show?concept=List\"\>List\</a\> (\<code\>\n    list\n  \</code\>).\</li\>\n  \<li\> \<a href=\"/show?concept=Tuple\"\>Tuple\</a\> (\<code\>\n    tuple\n  \</code\>).\</li\>\n  \<li\> \<a href=\"/show?concept=Set\"\>Set\</a\> (\<code\>\n    set\n  \</code\>).\</li\>\n  \<li\> \<a href=\"/show?concept=Map\"\>Map\</a\> (\<code\>\n    map\n  \</code\>) \</li\>\n  \<li\> \<a href=\"/show?concept=Relation\"\>Relation\</a\> (\<code\>\n    rel\n  \</code\>). \</li\>\n  \<li\> Untyped tree structures (\<a href=\"/show?concept=Node\"\>Node\</a\>, \<code\>\n    node\n  \</code\>).  \</li\>\n  \<li\> User-defined algebraic datatypes (\<a href=\"/show?concept=Declarations/AlgebraicDataType\"\>Declarations/AlgebraicDataType\</a\>, \<code\>\n    data\n  \</code\>) allow the introduction of problem-specific types and are a subtype of node.    This makes it possible to have typed\n     and untyped views on the same data. \n     A special case are syntax trees that are the result of parsing source files are represented \n     as datatypes (\<code\>\n    Tree\n  \</code\>).\n  \</li\>\n  \n\</ul\> There is a wealth of built-in operators and library functions available on the standard datatypes. \n \<br/\>\n\<br/\>\n\n These builtin datatypes are closely related to each other:\n  \<ul\>\n  \<li\> In a list all elements have the same static type and the order of elements matters. A list may contain the same value more than once.\</li\>\n  \<li\> In a set all elements have the same static type and the order of elements does not matter.   A set contains an element only once. In other words, duplicate elements are eliminated \n     and no matter how many times an element is added to a set, it will occur in it only once.\n  \</li\>\n  \<li\> In a tuple alle elements (may) have a different static type. Each element of a tuple may have a label that can be used to select that     element of the tuple.\n  \</li\>\n  \<li\> A relation is a set of tuples which all have the same static tuple type.\</li\>\n  \<li\> A map is an associative table of (key, value) pairs. Key and value (may) have different static    type and a key can only be associated with a value once.\n  \</li\>\n  \n\</ul\>"," Here are some examples of the built-in data types:\n \<table\>\n \<colgroup\>\n \<col align=\"left\" span=\"2\"\>\n \<thead\>\n \<tr\>\<th\>\<i\>Type\</i\>\</th\> \<th\>\<i\>Examples\</i\>\</th\>\</tr\>\n \<tbody\>\n \<tr\>\<td\>\<code\>\n  bool\n\</code\>\</td\>\t                   \<td\>\<code\>\n  true\n\</code\>, \<code\>\n  false\n\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>\n  int\n\</code\>\</td\>\t                   \<td\>\<code\>\n  11, 101, 1-11, 1123456789\n\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>\n  real\n\</code\>\</td\>\t                   \<td\>\<code\>\n  1.01, 11.0232e201, 1-25.5\n\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>\n  str\n\</code\>\</td\>\t                   \<td\>\<code\>\n  \"abc\"\n\</code\>, \<code\>\n  \"first\\nnext\"\n\</code\>, \<code\>\n  \"result: &lt;X\>\"\n\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>\n  loc\n\</code\>\</td\>\t                    \<td\>\<code\>\n  |file:///etc/passwd|\n\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>\n  dateTime\n\</code\>\</td\>               \t\<td\>\<code\>\n  $2101-09-05T07:16:19.714+0200\n\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>\n  tuple[\<i\>T\</i\>1,...,\<i\>Tn\</i\>]\n\</code\>\t\t\t\</td\>\<td\>\<code\>\n  &lt;1,2\>\n\</code\>, \<code\>\n  &lt;\"john\", 43, true\>\n\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>\n  list[\<i\>T\</i\>]\n\</code\>\</td\>\t            \<td\>\<code\>\n  []\n\</code\>, \<code\>\n  [1]\n\</code\>, \<code\>\n  [1,2,3]\n\</code\>, \<code\>\n  [true, 2, \"abc\"]\n\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>\n  set[\<i\>T\</i\>]\n\</code\>\</td\>\t            \t\<td\>\<code\>\n  {}\n\</code\>, \<code\>\n  {1,2,3,5,7}\n\</code\>, \<code\>\n  {\"john\", 4.0}\n\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>\n  rel[\<i\>T\</i\>1,...,\<i\>Tn\</i\>]\n\</code\>\</td\>    \t\<td\>\<code\>\n  {&lt;1,2\>,&lt;2,3\>,&lt;1,3\>}\n\</code\>, \<code\>\n  {&lt;1,10,100\>, &lt;2,20,200\>}\n\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>\n  map[\<i\>T\</i\>, \<i\>U\</i\>]\n\</code\>\</td\>\t    \t\<td\>\<code\>\n  ()\n\</code\>, \<code\>\n  (1:true, 2:false)\n\</code\>, \<code\>\n  (\"a\":1, \"b\":2)\n\</code\>\</td\>\</tr\>\n \<tr\>\<td\>\<code\>\n  node\n\</code\>\</td\>\t                    \<td\>\<code\>\n  f()\n\</code\>, \<code\>\n  add(x,y)\n\</code\>, \<code\>\n  g(\"abc\", [2,3,4])\n\</code\>\</td\>\</tr\>\n \</table\>\n \<br\>\n A fragment of the datatype that defines the abstract syntax for statements (assignment, if, while) in a programming language would look as follows:\n  \<pre class=\"listing\"\>data STAT = asgStat(Id name, EXP exp)\n          | ifStat(EXP exp,list[STAT] thenpart,\n                           list[STAT] elsepart) \n          | whileStat(EXP exp, list[STAT] body)\n          ;\n\</pre\>","","",[])
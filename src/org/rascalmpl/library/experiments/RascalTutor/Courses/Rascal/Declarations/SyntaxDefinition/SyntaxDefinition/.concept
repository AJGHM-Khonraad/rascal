Name: SyntaxDefinition

Details: NonTerminals RegularExpressionNonTerminals Disambiguation

Categories:

Syntax: 

There are four kinds of non-terminals you can define: _lexical_, _syntax_, _layout_ and _keyword_. They all have the same syntax, but they differ in how they are processed by the parser generator and how parse trees defined by them are processed by pattern matching and expression evaluation.

`lexical $Nonterminal$ = $Symbol_1$ $Symbol_2$ ... ;`

`syntax $Nonterminal$ = $Symbol_1$ $Symbol_2$ ... ;`

`start syntax $Nonterminal$ = $Symbol_1$ $Symbol_2$ ... ;`

`syntax $Nonterminal$ = $Name$ : $Symbol_1$ $Symbol_2$ ...;`

`syntax $Nonterminal$ = $Alternative_1 | $Alternative_2$ | $Alternative_3$ | ...;`  

`syntax $Nonterminal$ = $Alternative_1 > $Alternative_2$ > $Alternative_3$ > ...;`

`syntax $Nonterminal$ = $Alternative_1 > left { $Alternative_2$ | $Alternative_3$ | ... } | ...;`

`layout $Nonterminal$ = $Symbol_1$ $Symbol_2$ ... ;`

`keyword $Nonterminal$ = $Terminal_1$ | $Terminal_2$ | &;`

Types:

Function:

Synopsis: Syntax Definitions allow you to define parsers for programming languages or other formats.

Description: Rascal supports full context-free grammars for syntax definition. It generates scannerless parsers from these definitions. The definitions can be ambiguous, which is why we provide [Disambiguation] methods.

_Syntax_ non-terminals are general context-free non-terminals. This mean left-recursion, right-recursion, any of the regular expression [Symbols] and all kinds of [Disambiguation] can be used to define it. It is important to note that in between the $Symbols$ that define a syntax non-terminal the locally defined layout non-terminal will be interleaved. For example, if you define `layout ML = [\ ]*;` and `syntax A = "a" "a"`, Rascal will _modify_ the definition of A to `syntax A = "a" ML "a";` before generating a parser.

_Lexical_ non-terminals are just like _syntax_ non-terminals, very much like _syntax_ non-terminals. However, the definition of a lexical is _not_ modified with interleaved layout non-terminals. And, the structure of lexicals is not traversed by the [Visit] statement and equality is checked between lexicals by checking the characters (not its structure) for equality. 

_Layout_ non-terminals are just like _syntax_ non-terminals as well. However, they are used to preprocess all _syntax_ definitons in the same module scope (see above).

_Keyword_ non-terminals are _not_ like _syntax definitions. These only allow definition of enumeration of literal symbols and single character classes. Keyword non-terminals play an important role in the semantics of [Disambiguation] where some disambiguation constructs require finite, non-empty enumeration of strings. The prime example is the definition of reserved keywords.

The _start_ modifier identifies the start of a grammar. The effect of a start modifier is that Rascal will generate an extra syntax definition before generating a parser that allows layout to before and after the start non-terminal. For example: `layout L = [\ ]*; start Program = Statement*;` will produce `syntax start[Program] = L Program $top$ L;`. Note that the start[Program] type is now available in your program, and parse trees assigned to variable of that type will allow access to the $top$ field.

Examples:

We may use syntax definitions in a very direct way, without much extra annotation:
<screen>
// Define an Identifier non-terminal using a regular expression over character classes:
lexical Identifier = [a-z]+;
// Define the whitespace that will be used by following syntax definitions:
layout MyLayout = [\ \t\n]*;
// Define an expression language that uses the above Identifier and MyLayout definitions:
syntax Expression 
  = Identifier
  > left Expression "*" Expression
  > left Expression "+" Expression
  ;
// Define somewhere to start
start syntax Calc = {Expression ";"}+;
// Now we can dynamically parse an example expression
c = parse(#start[Calc], "a + b");
// We can statically produce a parse tree of expressions
d = (Expression) `a + b`;
// Start computing with such values
c == d;
for (/(Expression) `<Identifier i> ` := c) println("id: <i>");
</screen>

Benefits:
* modular and composable
* no grammar normalization or grammar factoring necessary
* generate a parser for any context-free grammar
* generate parsers are really fast (for general parsers)
* powerful disambiguation constructs for common programming language disambiguation patterns
* data-dependent (context-sensitive) disambiguation via arbitrary functions
* embedding of concrete syntax fragments in Rascal programs

Pitfalls:
* grammars may be ambiguous
* static grammar checker is not finished

Questions:


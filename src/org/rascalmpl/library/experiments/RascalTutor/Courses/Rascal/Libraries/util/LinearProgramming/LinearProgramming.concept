Name: LinearProgramming

Synopsis: A library for doing Linear programming

Usage: `import util::LinearProgramming;`

Types:

Function:

Details:

Description: This library provides function for optimizing a function given a system of linear (in)equalities. See [Linear Programming on Wikipedia](http://en.wikipedia.org/wiki/Linear_programming)

A linear expression is of the form:

$c_1$ $x_1$ + $c_2$ $x_2$ ... $c_n$ $x_n$ + $con$

where $c_i$ is a real number, $x_i$ is a variable and $con$ is constant (real number). The $c_i$s are called the coefficients.

For example:

$10$loc + $mcCabe$20 + 15

is a linear expression.

Such a linear expression is represented as:

<listing>
alias Coefficients = map[str var,num coef];
data LinearExpression = linearExp(Coefficients coefficients, num const);
</listing>

Thus the above expression can be expressed as:

<listing>
linearExp(("loc" : 10, mcCabe:20),15);
</listing>

The constraints of a linear system are given using the Constraint data type.
<listing>
data ConstraintType = leq() | eq() | geq();
data Constraint = constraint(	Coefficients coefficients,
                                ConstraintType ctype, num const);
public Constraint constraint(LinearExpression lhs, ConstraintType ctype); // linearExpression {<=,==,>=} 0
public Constraint constraint(LinearExpression lhs,  // relation between two linear expressions
			     ConstrainType ctype, LinearExpression rhs)
</listing>

For example 13$parrots$ + 15$bunnies$ + 12$monkeys$ <= 160 +  is written as:
<listing>
constraint(("parrots" : 13 , "bunnies" : 15, "monkeys" : 12), leq(), 160);
</listing>

The objective function, i.e. the function to be minimized is also expressed as LinearExpression.
<listing>
alias ObjectiveFun = LinearExpression;
</listing>

The constraints + the objective function can then be passed to one of the following functions:
<listing>
public Maybe[Solution] 
minimize(set[Constraint] constraints, ObjectiveFunction f) ;

Maybe[Solution] 
minimizeNonNegative(set[Constraint] constraints, ObjectiveFunction f) ;

public Maybe[Solution] 
maximize(set[Constraint] constraints, ObjectiveFunction f);

public Maybe[Solution] 
maximizeNonNegative(set[Constraint] constraints, ObjectiveFunction f);
</listing>

The functions ending in NonNegative produce only solutions where all variables are assigned to a values >= 0.

These functions will return a [$Libraries/util/Maybe] solution. So they will return a solution if one has been found. The algorithm used is the Simplex algorith](http://en.wikipedia.org/wiki/Simplex_algorithm). 

<listing>
alias VariableVals = map[str var, num val];
data Solution = solution(VariableVals varVals, num funVal);
</listing>

where the assigns field contains all assignments of the variables, and funVal contains the value of the objective function at the minimimum or maximum.


Examples:

The Two Mines Company own two different mines (in Europe and Asia) that produce an ore which, after being crushed, is graded into three classes: high, medium and low-grade. The company has contracted to provide a smelting plant with 12 tons of high-grade, 8 tons of medium-grade and 24 tons of low-grade ore per week. The two mines have different operating characteristics as detailed below.

|Mine |   Cost per day ($)  | Production High |  Production Medium| Production Low          |
|-----|-------------------------|---------|---------|--------------|
|Europe  |      180000             |     6   |   3     |   4          |
|Asia    |      160000                |     1   |   1     |    6         |

How many days per week should each mine be operated to fulfil the smelting plant contract at the lowest cost?

This gives rises to the following inequalities, where $asia$ denoted the number of days to run the mine in Asia and $europe$ determines the number of days to run the mine in Europe

6 * $europe$ + 1 * $asia$ >= 12 // high grade
3 * $europe$ + 1 * $asia$ >= 8  // medium grade
1 * $europe$ + 6 * $asia$ >= 24 // low grade

Also there are no more than 7 days a week.
$europe$ <= 7
$asia$ <= 7

And we want to minimize the cost = 180000 * $europe$ + 160000 * $asia$

We write it like this:

<screen>
import util::LinearProgramming;
constraints = {
    constraint(("europe" : 6, "asia" : 1), geq() , 12),
    constraint(("europe" : 3, "asia" : 1), geq() , 8),
    constraint(("europe" : 4, "asia" : 6), geq() , 24),
    constraint(("europe" : 1), leq() , 7),
    constraint(("asia" : 1), leq() , 7)
};	
cost = linearExp(("europe" : 180000, "asia" : 160000));
minimizeNonNegative(constraints,cost);
</screen> 

Benefits:

Pitfalls:

Questions:

       

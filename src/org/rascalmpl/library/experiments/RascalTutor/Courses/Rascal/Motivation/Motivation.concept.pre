concept("Motivation",|std:///experiments/RascalTutor/Courses/Rascal/Motivation/Motivation.concept|,[],[],{"Language"},{"EASY"}," Rascal is a new language for \<i\>meta-programming\</i\>, this is the activity of writing meta-programs.\n Using Rascal you create programs that read, analyse, transform, generate and/or visualize other programs. \n","","","",{}," \<i\>Meta-programs\</i\> are programs that analyze, transform or generate other programs. Ordinary programs work on data; meta-programs work on programs. \n \<br/\>\n\<br/\>\n\n The \<i\>range of programs\</i\> to which meta-programming can be applied is large: from programs in standard languages like C and Java to domain-specific languages for describing high-level system models or applications in specialized areas like gaming or finance. In some cases, even test results or performance data are used as input for meta-programs.\n \<br/\>\n\<br/\>\n\n The \<i\>range of kinds of meta programs\</i\> that can be applied is also large. There are simple meta programs that generate boilerplate code from a list of items. There are complex meta programs that reverse engineer and statically analyse a big software system before visualizing the results. The point of Rascal is that in all these kinds of meta programs one needs similar operations and similar data-types. \n \<br/\>\n\<br/\>\n\n The \<i\>point of Rascal\</i\> is to provide a reusable set of primitives to build and manipulate program representations. The point is \<i\>not\</i\> to be or provide a unified representation of programs to let generic algorithms operate on. In meta programming the devil is often in the details. Rascal makes sure to not a priori abstract from the important details programming language syntax and semantics.\n \<br/\>\n\<br/\>\n\n \<i\>Rascal is a domain specific programming language\</i\>. We emphasize programming here because Rascal is intended as an engineering tool for programmers that need to construct meta programs. Rascal programs allow running, inspecting, debugging, tracing, profiling, etc. just as normal programs do. The skills of any good programmer are enough to easily write good Rascal programs.\n"," Typical applications of Rascal are:\n \<ul\>\<li\> Refactoring of Java source code.\</li\>\n\<li\> Searching for buffer overflows in C code.\</li\>\n\<li\> Analyzing the version history of a large software project.\</li\>\n\<li\> Implementing a \<i\>domain-specific language\</i\> (DSL) for describing business processes.\</li\>\n\</ul\> All these cases involve a form of meta-programming: software programs (in a wide sense) are the objects-of-interest that are being analyzed, transformed or generated. The Rascal language is designed for meta-programming following the \<a href=\"/show?concept=EASY\"\>EASY\</a\> paradigm. It can be applied in domains ranging from compiler construction and implementing domain-specific languages to constraint solving and software renovation.\n \<br/\>\n\<br/\>\n\n Since representation of information is central to the approach, Rascal provides a rich set of built-in data types. To support extraction and analysis, parsing and advanced pattern matching are provided. High-level control structures make analysis and synthesis of complex datastructures simple.\n"," \<ul\>\<li\> \<b\>Familiar syntax\</b\> in a \<i\>what-you-see is-what-you-get\</i\> style is used even for sophisticated concepts     and this makes the language easy to learn and easy to use.\n\</li\>\n\<li\> \<b\>Sophisticated built-in data types\</b\> provide standard solutions for many meta-programming problems.\</li\>\n\<li\> \<b\>Safety\</b\> is achieved by finding most errors before the program is executed and by making common errors    like missing initializations or invalid pointers impossible. \n\</li\>\n\<li\> \<b\>Local type inference\</b\> makes local variable declarations redundant.\</li\>\n\<li\> \<b\>Pattern matching\</b\> can be used to analyze all complex datastructures.\</li\>\n\<li\> \<b\>Syntax definitions\</b\> make it possible to define new and existing languages and to write tools for them.\</li\>\n\<li\> \<b\>Visiting\</b\> makes it easy to traverse datastructures and to extract information from them or to synthesize results.\</li\>\n\<li\> \<b\>Templates\</b\> enable easy code generation.\</li\>\n\<li\> \<b\>Functions as values\</b\> permit programming styles with high re-use.\</li\>\n\<li\> \<b\>Generic types\</b\> allow writing functions that are applicable for many different types.\</li\>\n\<li\> \<b\>Eclipse integration\</b\> makes Rascal programming a breeze. All familiar tools are at your fingertips.\</li\>\n\</ul\>"," \<ul\>\<li\> Rascal programs are not yet highly optimized so execution maybe slow for some programs.\</li\>\n\<li\> At the time of writing, this checking is done during execution, but we are working on this.\</li\>\n\</ul\>",[])
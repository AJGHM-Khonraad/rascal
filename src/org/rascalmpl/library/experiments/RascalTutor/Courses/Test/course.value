course("Test",["\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/Cat1/Cat1.html\"\>Cat1\</a\>/\<a href=\"/Courses/Test/Cat1/Cat11/Cat11.html\"\>Cat11\</a\>: Reference to unknown course or concept: Test:Cat3","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/Exam/Exam.html\"\>Exam\</a\>: No question 1 in Test/AAA","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/Cat2/Cat2.html\"\>Cat2\</a\>: Warning in Cat2","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>: No question 1 in Test/AAA","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>: Unkown or ambiguous concept in toc: XXX","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>: non-existing detail NotThere","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/AAA/AAA.html\"\>AAA\</a\>: Static Error: prompt:///:1,0: Undeclared variable, function or constructor: xxx","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/AAA/AAA.html\"\>AAA\</a\>: Reference to unknown course or concept: Test:WRONGLINK","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/AAA/AAA.html\"\>AAA\</a\>: Ambiguous reference to concept: Rascal:Comprehension; \nResolve with one of {Rascal/Expressions/Values/List/Comprehension, Rascal/Expressions/Values/Map/Comprehension, Rascal/Expressions/Values/Set/Comprehension}","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/AAA/AAA.html\"\>AAA\</a\>: Reference to unknown course or concept: Rascal:Zap","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/AAA/AAA.html\"\>AAA\</a\>: Hier is een warning in AAA","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/AAA/AAA.html\"\>AAA\</a\>: Hier is warning 2 in AAA","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/AAA/AAA.html\"\>AAA\</a\>: Hier is warning 3 in AAA","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/AAA/AAA.html\"\>AAA\</a\>: Hier is warning 4 in AAA","\<a href=\"/Courses/Test/Test.html\"\>Test\</a\>/\<a href=\"/Courses/Test/AAA/AAA.html\"\>AAA\</a\>: Ambiguous reference to concept: Test:Cat1; \nResolve with one of {Test/BBB/Cat1, Test/Cat1}"],("Test/Cat2/Cat21":concept("Test/Cat2/Cat21",[],[],{},[]),"Test/Cat1/Cat11":concept("Test/Cat1/Cat11",["Reference to unknown course or concept: Test:Cat3"],[],{},[]),"Test/AAA/AAA3":concept("Test/AAA/AAA3",[],[],{},[]),"Test/Libraries":concept("Test/Libraries",[],[],{},[]),"Test/Exam":concept("Test/Exam",["No question 1 in Test/AAA"],[],{},[textQuestion("Test/Exam","A"," Dit is een vraag. Wat is het antwoord?\n",{"antwoord"}),choiceQuestion("Test/Exam","2","  Sets can be used to represent a sequence of values when\n",[good("The values have no duplicates and no order."),bad("The values have duplicates."),bad("The values are unordered.")]),tvQuestion("Test/Exam","B",typeOfExpr(),details(" ",[],"","","\<A:int\>","",false,false,[<"A",int(-20,20)>],[],void(),"")),tvQuestion("Test/Exam","4",valueOfExpr(),details(" ",[],"","","2 * \<A:int\>","",false,false,[<"A",int(-20,20)>],[],void(),""))]),"Test/AAA/AAA2":concept("Test/AAA/AAA2",[],[],{},[]),"Test/T20111128":concept("Test/T20111128",[],[],{},[choiceQuestion("Test/T20111128","1","  A list:\n",[good("Has elements that are ordered."),good("Can contain zero or more elements."),good("Can contain duplicate elements."),bad("Has elements that are unordered."),bad("Can contain one or more elements."),bad("Can not contain duplicate elements.")]),choiceQuestion("Test/T20111128","2","  A map maps keys to values. In a map:\n",[good("All keys have to be unique."),good("All (key, value) pairs are unordered."),bad("All values have to be unique."),bad("All keys and values have to be unique."),bad("All keys are ordered."),bad("All values are ordered."),bad("All (key, value) pairs are ordered.")]),choiceQuestion("Test/T20111128","3","  A relation:\n",[good("Is a set of tuples."),good("Has unordered elements."),good("Can not contain duplicates."),bad("Is a list of tuples."),bad("Is a tuple of tuples."),bad("Has ordered elements."),bad("Can contain duplicates.")]),choiceQuestion("Test/T20111128","4","  The following statement about subtypes is correct:\n",[good("`int` is a subtype of `num`."),good("`real` is a subtype of `number`."),good("`int` is a subtype of `real`."),good("`num` is a subtype of `value`."),good("An Algebraic Data Type (defined using `data`) is a subtype of `node`."),good("A relation is a subtype of set."),bad("`bool` is a subtype of `int`."),bad("`num` is a subtype of `real`."),bad("`value` is a subtype of `void`.")]),choiceQuestion("Test/T20111128","5","  The type of a set is determined by:\n",[good("The least upperbound of the type of all elements."),good("The types of all the elements in the set."),bad("The average of the type of the elements with the smallest and the largest type."),bad("The least upperbound of the type of two arbitrary elements."),bad("The type of two arbitrary elements.")]),choiceQuestion("Test/T20111128","6","  Which statement about the domain and range function on a binary relation of type \<code\>rel[int,int]\</code\> is correct:\n",[good("Domain returns a set of the first element of each tuple in the relation and range returns a set of the second element of each tuple."),good("Domain and range are only applicable to binary relations."),bad("Domain returns a list of the first element of each tuple in the relation and range returns a list of the second element of each tuple."),bad("Domain returns a set of the second element of each tuple in the relation and range returns a set of the first element of each tuple."),bad("Domain returns a list of the second element of each tuple in the relation and range returns a list of the first element of each tuple."),bad("Domain returns a set of the elements that occur in any tuple in the relation and range returns a list of those elements.")]),tvQuestion("Test/T20111128","7",typeOfExpr(),details(" ",[],"","","\<A:list[arb[int,real,str,loc]]\>","",false,false,[<"A",list(arb(0,[int(-20,20),real(-20,20),str(),\loc()]))>],[],void(),"")),tvQuestion("Test/T20111128","8",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(num(-20,20)),"")),tvQuestion("Test/T20111128","9",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(value()),"")),tvQuestion("Test/T20111128","10",typeOfExpr(),details(" ",[],"","","(\<A\>: ",")",false,true,[<"A",str()>],[],map(str(),int(-20,20)),"a map from strings to integers")),tvQuestion("Test/T20111128","11",typeOfExpr(),details(" ",[],"","","\<A:set[arb[int,real,num,str,loc]]\>","",false,false,[<"A",set(arb(0,[int(-20,20),real(-20,20),num(-20,20),str(),\loc()]))>],[],void(),"")),tvQuestion("Test/T20111128","12",valueOfExpr(),details(" Create a list of the right size.\n",[],"import List;\nlist[int] text = ",";\n","size(text) == 3;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","13",valueOfExpr(),details(" Return the strings that contain a given substring.\n",[],"text = [\"An\", \"honest\", \"man\", \"is\", \"always\", \"a\", \"child\"]; \npublic list[str] find(list[str] text, str contains) = [ s | s \<- text, "," ];\n","find(text, \"s\") == [\"honest\", \"is\", \"always\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","14",valueOfExpr(),details(" Return the list of words with a length smaller than or equal to \<code\>n\</code\>.\n",[],"import Number;\nimport String;\ntext = [\"Quote\", \"from\", \"Mahatma\", \"Gandhi:\", \n\"Freedom\", \"is\", \"not\", \"worth\", \"having\", \"if\", \"it\", \"does\", \"not\", \n\"include\", \"the\", \"freedom\", \"to\", \"make\", \"mistakes\"];\n\npublic list[str] smallerOrEq(list[str] text, int n){\n  return\n    for(s \<- text)\n        if(",")\n           append s;\n}\n","smallerOrEq(text, 3) == [\"is\", \"not\", \"if\", \"it\", \"not\", \"the\", \"to\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","15",valueOfExpr(),details(" Complete this function that returns the set of keys with the largest associated value.\n",[],"import Map;\nimport Set;\ninventory = (\"orange\" : 20, \"apple\" : 15, \"banana\" : 25, \"lemon\" : 15);\npublic set[str] largest(map[str,int] inv){\n    m = ","; // Determine the maximal value in the map\n    return { s  | s \<- inv, inv[s] == m };\n}\n","largest(inventory) == {\"banana\"};","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","16",valueOfExpr(),details(" Complete this function that tests that a list of words consists of three identical sublists:\n",[],"import List;\npublic bool isTriple(list[str] words){\n  return [list[str] L, ","] := words;\n}\n","isTriple([\"a\", \"b\", \"a\", \"b\", \"a\", \"b\"]) == true;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111128","17",valueOfExpr(),details(" Given a data type \<code\>ColoredTree\</code\>, complete the definition of the function \<code\>flipRedChildren\</code\> that exchanges the children of all black nodes.\n",[],"data ColoredTree = leaf(int N)      \n                 | red(ColoredTree left, ColoredTree right) \n                 | black(ColoredTree left, ColoredTree right);\n\nColoredTree rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));\n\npublic ColoredTree flipBlackChildren(ColoredTree t){\n  return visit(t){\n     case black(l,r) =\> ","\n  };\n}\n","flipBlackChildren(rb) ==  red(black(red(leaf(2),leaf(3)), leaf(1)), black(leaf(4), leaf(3)));","",true,false,[],[],void(),""))]),"Test/BBB/BBB3":concept("Test/BBB/BBB3",[],[],{},[]),"Test/AAA/AAA1":concept("Test/AAA/AAA1",[],[],{},[]),"Test/Bla":concept("Test/Bla",[],[],{},[]),"Test/BBB/BBB2":concept("Test/BBB/BBB2",[],[],{},[]),"Test/Cat2":concept("Test/Cat2",["Warning in Cat2"],[],{},[]),"Test/BBB/BBB1":concept("Test/BBB/BBB1",[],[],{},[]),"Test/T20111114":concept("Test/T20111114",[],[],{},[choiceQuestion("Test/T20111114","1","  A map maps keys to values. In a map:\n",[good("All keys have to be unique."),good("All keys have the same type."),good("All keys should have the same type and all values should have the same type. The type of keys and values may be different."),bad("All keys should have the same type and all values should have the same type. The type of keys and values should be the same."),bad("All values have to be unique."),bad("All keys and values have to be unique."),bad("All keys are sorted.")]),choiceQuestion("Test/T20111114","2","  In a tuple:\n",[good("All elements may have different types."),good("The number of elements is fixed."),good("The order of the elements is relevant."),bad("All elements should have the same type."),bad("The number of elements is not fixed."),bad("The order of the elements is not relevant.")]),choiceQuestion("Test/T20111114","3","  A relation:\n",[good("Is a set of tuples."),good("Has unordered elements."),good("Can not contain duplicates."),bad("Is a list of tuples."),bad("Is a tuple of tuples."),bad("Has ordered elements."),bad("Can contain duplicates."),bad("Has a fixed length.")]),choiceQuestion("Test/T20111114","4","  The type of a set is determined by:\n",[good("The least upperbound of the type of all elements."),good("The types of all the elements in the set."),bad("The type of the element that was first added to the set."),bad("The average of the type of the elements with the smallest and the largests type."),bad("The least upperbound of the type of two arbitrary elements."),bad("The type of two arbitrary elements.")]),choiceQuestion("Test/T20111114","5","  Which statement about the domain and range function on a binary relation of type \<code\>rel[int,int]\</code\> is correct:\n",[good("Domain returns a set of the first element of each tuple in the relation and range returns a set of the second element of each tuple."),good("Domain and range are only applicable to binary relations."),bad("Domain returns a list of the first element of each tuple in the relation and range returns a list of the second element of each tuple."),bad("Domain returns a set of the second element of each tuple in the relation and range returns a set of the first element of each tuple."),bad("Domain returns a list of the second element of each tuple in the relation and range returns a list of the first element of each tuple."),bad("Domain returns a set of the elements that occur in any tuple in the relation and range returns a list of those elements.")]),tvQuestion("Test/T20111114","6",typeOfExpr(),details(" ",[],"","","\<A:list[arb[int,real,str,loc]]\>","",false,false,[<"A",list(arb(0,[int(-20,20),real(-20,20),str(),\loc()]))>],[],void(),"")),tvQuestion("Test/T20111114","7",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(num(-20,20)),"")),tvQuestion("Test/T20111114","8",typeOfExpr(),details(" ",[],"","","{\<A\>, ","}",false,true,[<"A",int(-20,20)>],[],set(value()),"")),tvQuestion("Test/T20111114","9",typeOfExpr(),details(" ",[],"","","(\<A\>: ",")",false,true,[<"A",str()>],[],map(str(),int(-20,20)),"a map from strings to integers")),tvQuestion("Test/T20111114","10",typeOfExpr(),details(" ",[],"","","\<A:set[arb[int,real,num,str,loc]]\>","",false,false,[<"A",set(arb(0,[int(-20,20),real(-20,20),num(-20,20),str(),\loc()]))>],[],void(),"")),tvQuestion("Test/T20111114","11",valueOfExpr(),details(" Create a list of the right size.\n",[],"import List;\nlist[str] text = ",";\n","size(text) == 3;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","12",valueOfExpr(),details(" Return the strings that contain a given substring.\n",[],"text = [\"An\", \"honest\", \"man\", \"is\", \"always\", \"a\", \"child\"]; \npublic list[str] find(list[str] text, str contains) = [ s | s \<- text, "," ];\n","find(text, \"n\") == [\"An\", \"honest\", \"man\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","13",valueOfExpr(),details(" Return the set of largest words.\n",[],"import Number;\nimport String;\ntext = [\"Quote\", \"from\", \"Steve\", \"Jobs\", \":\", \"And\", \"one\", \"more\", \"thing\"];\npublic list[str] largest(list[str] text){\n  mx = ( 0 | max(it, size(s)) | s \<- text );\n  return\n    for(s \<- text)\n        if(",")\n           append s;\n}\n","largest(text) == [\"Quote\", \"Steve\", \"thing\"];","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","14",valueOfExpr(),details(" Complete this function that returns the set of keys with the smallest associated value.\n",[],"import Map;\nimport Set;\ninventory = (\"orange\" : 20, \"apple\" : 15, \"banana\" : 25, \"lemon\" : 15);\npublic set[str] lowest(map[str,int] inv){\n    m = ","; // Determine the minimal value in the map\n    return { s  | s \<- inv, inv[s] == m };\n}\n","lowest(inventory) == {\"apple\", \"lemon\"};","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","15",valueOfExpr(),details(" Complete this function that tests that a list of words consists of two identical sublists:\n",[],"import List;\npublic bool isReplicated(list[str] words){\n  return [list[str] L, ","] := words;\n}\n","isReplicated([\"a\", \"b\", \"a\", \"b\"]) == true;","",true,false,[],[],void(),"")),tvQuestion("Test/T20111114","16",valueOfExpr(),details(" Given a data type \<code\>ColoredTree\</code\>, complete the definition of the function \<code\>flipRedChildren\</code\> that exchanges the children of all red nodes.\n",[],"data ColoredTree = leaf(int N)      \n                 | red(ColoredTree left, ColoredTree right) \n                 | black(ColoredTree left, ColoredTree right);\n\nColoredTree rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));\n\npublic ColoredTree flipRedChildren(ColoredTree t){\n  return visit(t){\n     case red(l,r) =\> ","\n  };\n}\n","flipRedChildren(rb) == red( black(leaf(3), leaf(4)), black(leaf(1), red(leaf(3),leaf(2))));","",true,false,[],[],void(),""))]),"Test/Cat1":concept("Test/Cat1",[],[],{},[]),"Test/Libraries/util/Eval/shell":concept("Test/Libraries/util/Eval/shell",[],[],{},[]),"Test/Libraries/util/Eval":concept("Test/Libraries/util/Eval",[],[],{},[]),"Test/Libraries/util/Eval/eval":concept("Test/Libraries/util/Eval/eval",[],[],{},[]),"Test/Libraries/util":concept("Test/Libraries/util",[],[],{},[]),"Test/Bla/Bla4":concept("Test/Bla/Bla4",[],[],{},[]),"Test":concept("Test",["No question 1 in Test/AAA","Unkown or ambiguous concept in toc: XXX","non-existing detail NotThere"],["Cat2"],{"]","map",",","[","lub","(","),"},[textQuestion("Test","A"," Dit is een vraag. Wat is het antwoord?\n",{"antwoord"}),tvQuestion("Test","B",typeOfExpr(),details(" ",[],"","","\<A:int\>","",false,false,[<"A",int(-20,20)>],[],void(),"")),tvQuestion("Test","3",valueOfExpr(),details(" ",[],"","","2 * \<A:int\>","",false,false,[<"A",int(-20,20)>],[],void(),""))]),"Test/Bla/Bla3":concept("Test/Bla/Bla3",[],[],{},[]),"Test/Bla/Bla2":concept("Test/Bla/Bla2",[],[],{},[]),"Test/Libraries/util/Eval/evalType":concept("Test/Libraries/util/Eval/evalType",[],[],{},[]),"Test/Bla/Bla1":concept("Test/Bla/Bla1",[],[],{},[]),"Test/LinkBreak":concept("Test/LinkBreak",[],[],{},[]),"Test/BBB/Cat1":concept("Test/BBB/Cat1",[],[],{},[]),"Test/BBB":concept("Test/BBB",[],["Cat1"],{},[]),"Test/AAA":concept("Test/AAA",["Static Error: prompt:///:1,0: Undeclared variable, function or constructor: xxx","Reference to unknown course or concept: Test:WRONGLINK","Ambiguous reference to concept: Rascal:Comprehension; \nResolve with one of {Rascal/Expressions/Values/List/Comprehension, Rascal/Expressions/Values/Map/Comprehension, Rascal/Expressions/Values/Set/Comprehension}","Reference to unknown course or concept: Rascal:Zap","Hier is een warning in AAA","Hier is warning 2 in AAA","Hier is warning 3 in AAA","Hier is warning 4 in AAA","Ambiguous reference to concept: Test:Cat1; \nResolve with one of {Test/BBB/Cat1, Test/Cat1}"],[],{},[tvQuestion("Test/AAA","1",typeOfExpr(),details(" ",[],"","","\<A:set[arb[int,str,real]]\>","",false,false,[<"A",set(arb(0,[int(-20,20),str(),real(-20,20)]))>],[],void(),"")),tvQuestion("Test/AAA","2",typeOfExpr(),details(" ",[],"","","{1, "," }",false,true,[],[],set(int(-20,20)),"one or more integer values separated by commas"))]),"Test/Cat1/Cat13":concept("Test/Cat1/Cat13",[],[],{},[]),"Test/Cat2/Cat22":concept("Test/Cat2/Cat22",[],[],{},[]),"Test/Cat1/Cat12":concept("Test/Cat1/Cat12",[],[],{},[])),["(","),",",","AAA","AAA1","AAA2","AAA3","BBB","BBB1","BBB2","BBB3","Bla","Bla1","Bla2","Bla3","Bla4","Cat1","Cat11","Cat12","Cat13","Cat2","Cat21","Cat22","Eval","Exam","Libraries","LinkBreak","T20111114","T20111128","Test","[","]","eval","evalType","lub","map","shell","util"])
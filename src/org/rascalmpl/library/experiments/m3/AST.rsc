module experiments::m3::AST

data AstNode
	= \astNode(Declaration d	loc src = |unknown:///|, loc binding = |unknown:///|)
	| \astNode(Expression e		loc src = |unknown:///|, loc binding = |unknown:///|)
	| \astNode(Statement s		loc src = |unknown:///|, loc binding = |unknown:///|)
	| \astNode(Type t			loc src = |unknown:///|, loc binding = |unknown:///|)
	;

data Modifier
	= \private()
	| \public()
	| \protected()
	| \friendly()
	| \static()
	| \final()
	| \synchronized()
	| \transient()
	| \abstract()
	| \native()
	| \volatile()
	| \strictfp()
	| \deprecated()
	;

data Declaration 
  = \compilationUnit(list[AstNode] imports, list[AstNode] types)
  | \compilationUnit(AstNode package, list[AstNode] imports, list[AstNode] types)
  | \enum(str name, list[AstNode] implements, list[AstNode] constants, list[AstNode] body)
  | \enumConstant(str name, list[AstNode] arguments, AstNode class)
  | \enumConstant(str name, list[AstNode] arguments)
  | \class(list[Modifier] modifiers, str name, list[AstNode] extends, list[AstNode] implements, list[AstNode] body)
  | \class(list[AstNode] body)
  | \interface(list[Modifier] modifiers, str name, list[AstNode] extends, list[AstNode] implements, list[AstNode] body)
  | \field(AstNode \type, list[AstNode] fragments)
  | \initializer(list[Modifier] modifiers, list[AstNode] annotations, AstNode initializerBody)
  | \method(list[Modifier] modifiers, AstNode \return, str name, list[AstNode] parameters, list[AstNode] exceptions, AstNode impl)
  | \method(list[Modifier] modifiers, AstNode \return, str name, list[AstNode] parameters, list[AstNode] exceptions)
  | \method(list[Modifier] modifiers, str name, list[AstNode] parameters, list[AstNode] exceptions, AstNode impl)
  | \import(str name)
  | \staticImport(str name)
  | \package(str name)
  | \vararg(str name, AstNode \type)
  | \variables(AstNode \type, list[AstNode] \variables)
  | \variable(str name, int extraDimensions)
  | \variable(str name, int extraDimensions, AstNode initializer)
  | \typeParameter(str name, list[AstNode] extendsList)
  | \typeParameters(list[AstNode] typeParameters, AstNode decl)
  | \modifiers(list[Modifier] modifiers, AstNode decl) 
  | \annotations(AstNode decl, list[AstNode] annotations)
  | \annotationType(str name, list[AstNode] body)
  | \annotationTypeMember(AstNode typeArgument, str name)
  | \annotationTypeMember(AstNode typeArgument, str name, AstNode defaultBlock)
  | \parameter(AstNode \type, str name, int extraDimensions)
  | \parameter(AstNode \type, str name, int extraDimensions, AstNode initializer)
  ;
	
data Expression 
  = \markerAnnotation(str typeName)
  | \normalAnnotation(str typeName, list[AstNode] memberValuePairs)
  | \memberValuePair(str name, AstNode \value)				
  | \singleMemberAnnotation(str typeName, AstNode \value)
  | \arrayAccess(AstNode array, AstNode index)
  | \newArray(AstNode \type, list[AstNode] dimensions, AstNode init)
  | \newArray(AstNode \type, list[AstNode] dimensions)
  | \arrayInitializer(list[AstNode] elements)
  | \assignment(AstNode lhs, AstNode rhs)
  | \cast(AstNode \type, AstNode expression)
  | \char(str charValue)
  | \newObject(AstNode \type, list[AstNode] typeArgs, list[AstNode] args, AstNode class)
  | \newObject(AstNode \type, list[AstNode] typeArgs, list[AstNode] args)
  | \qualifier(AstNode qualifier, AstNode expression)
  | \conditional(AstNode expression, AstNode thenBranch, AstNode elseBranch)
  | \fieldAccess(AstNode expression, str name)
  | \instanceof(AstNode leftSide, AstNode rightSide)
  | \call(list[AstNode] typeArguments, str name, list[AstNode] arguments)
  | \call(AstNode receiver, list[AstNode] typeArguments, str name, list[AstNode] arguments)
//| \constructor(AstNode \type, list[AstNode] typeArguments, list[AstNode] arguments)
  | \constructor(list[AstNode] typeArguments, list[AstNode] arguments)
  | \variable(str name)
  | \null()
  | \number(str numberValue)
  | \boolean(bool boolValue)
  | \string(str stringValue)
  | \type(AstNode \type)
  | \bracket(AstNode expression)
  | \this()
  | \this(AstNode thisExpression)
  | \super()
  | \declaration(AstNode decl)
  | \infix(AstNode lhs, str operator, AstNode rhs)
  | \postfix(AstNode operand, str operator)
  | \prefix(str operator, AstNode operand)
  | \simpleName(str name)
  ;						

data Statement				
  = \assert(AstNode expression)
  | \assert(AstNode expression, str message)
  | \block(list[AstNode] statements)
  | \break()
  | \break(str label)
  | \continue()
  | \continue(str label)
  | \do(AstNode body, AstNode condition)
  | \empty()
  | \foreach(AstNode parameter, AstNode collection, AstNode body)
  | \for(list[AstNode] initializers, AstNode condition, list[AstNode] updaters, AstNode body)
  | \for(list[AstNode] initializers, list[AstNode] updaters, AstNode body)
  | \if(AstNode condition, AstNode thenBranch)
  | \if(AstNode condition, AstNode thenBranch, AstNode elseBranch)
  | \label(str name, AstNode body)
  | \return(AstNode expression)
  | \return()
  | \switch(AstNode expression, list[AstNode] statements)
  | \case(AstNode expression)
  | \defaultCase()
  | \synchronized(AstNode lock, AstNode body)
  | \throw(AstNode expression)
  | \try(AstNode body, list[AstNode] catchClauses)
  | \try(AstNode body, list[AstNode] catchClauses, AstNode \finally)										
  | \catch(AstNode exception, AstNode body)
  | \declaration(AstNode declaration)
  | \while(AstNode condition, AstNode body)
  | \expression(AstNode statement)
  ;							

data Type 
  = arrayType(AstNode \type)
  | parameterizedType(AstNode \type, list[AstNode] typeParameters)
  | qualifier(AstNode qualifier, AstNode \type)
  | simpleType(str name)
  | unionType(list[AstNode] types)
  | wildcard()
  | upperbound(AstNode \type)
  | lowerbound(AstNode \type)
  | \int()
  | short()
  | long()
  | float()
  | double()
  | char()
  | string()
  | byte()
  | \void()
  | \boolean()
  ;

/*
// This is an attempt to simplify the AST definitions, by removing use of Option, and by introducing some generic wrappers 
// (such as typeParameters, and modifiers)

anno loc Declaration@src;
anno loc Declaration@binding;

data Modifier
  = \private()
  | \public()
  | \protected()
  | \friendly()
  | \static()
  | \final()
  | \synchronized()
  | \transient()
  ;

data Declaration 
  = \compilationUnit(list[Declaration] imports, list[Declaration] types)
  | \compilationUnit(Declaration package, list[Declaration] imports, list[Declaration] types)
  | \enum(str name, list[Type] implements, list[Declaration] constants, list[Declaration] body)
  | \enumConstant(str name, list[Declaration] arguments, Declaration class)
  | \enumConstant(str name, list[Declaration] arguments)
  | \class(str name, list[Type] extends, list[Type] implements, list[Declaration] body)
  | \class(list[Declaration] body)
  | \interface(str name, list[Type] extends, list[Type] implements)
  | \field(Type \type, list[Expression] fragments)
  | \initializer(list[Modifier] modifiers, Statement body)
  | \method(Type \return, str name, list[Declaration] parameters, list[Type] exceptions, Statement impl)
  | \abstractMethod(Type \return, str name, list[Declaration] parameters, list[Type] exceptions)
  | \import(str name)
  | \staticImport(str name)
  | \package(str name)
  | \vararg(str name, Type \type)
  | \variables(Type \type, list[Declaration] variables)
  | \variable(str name)
  | \variable(str name, Expression initializer)
  | \typeParameter(str name, list[Type] extendsList)
  | \typeParameters(list[Type] typeParameters, Declaration decl)
  | \modifiers(list[Modifier] modifiers, Declaration decl) 
  | \annotations(Declaration decl, list[Expression] annotations)
  | \annotationType(str name, list[Declaration] body)
  | \annotationTypeMember(Type typeArgument, str name)
  | \annotationTypeMember(Type typeArgument, str name, Statement defaultBlock)
  ;
	
anno loc Expression@src;
anno loc Expression@binding;
	
data Expression 
  = \markerAnnotation(str typeName)
  | \normalAnnotation(str typeName, list[Expression] memberValuePairs)
  | \memberValuePair(str name, Expression \value)				
  | \singleMemberAnnotation(str typeName, Expression \value)
  | \arrayAccess(Expression array, Expression index)
  | \newArray(Type \type, list[Expression] dimensions, Expression init)
  | \newArray(Type \type, list[Expression] dimensions)
  | \arrayInitializer(list[Expression] elements)
  | \assignment(Expression lhs, Expression rhs)
  | \cast(Type \type, Expression expression)
  | \char(str charValue)
  | \newObject(Type \type, list[Type] typeArgs, list[Expression] args, Declaration class)
  | \newObject(Type \type, list[Type] typeArgs, list[Expression] args)
  | \qualifier(Expression qualifier, Expression expression)
  | \conditional(Expression expression, Expression thenBranch, Expression elseBranch)
  | \fieldAccess(Expression expression, str name)
  | \instanceof(Expression leftSide, Type rightSide)
  | \call(list[Type] typeArguments, str name, list[Expression] arguments)
  | \call(Expression receiver, list[Type] typeArguments, str name, list[Expression] arguments)
  | \constructor(Type \type, list[Type] typeArguments, list[Expression] arguments)
  | \variable(str name)
  | \null()
  | \number(num numberValue)
  | \boolean(bool boolValue)
  | \string(str stringValue)
  | \type(Type \type)
  | \bracket(Expression expression)
  | \this()
  | \super()
  | \declaration(Declaration decl)
  | \infix(Expression lhs, str operator, Expression rhs)
  | \postfix(Expression operand, str operator)
  | \prefix(str operator, Expression operand)
  ;						

anno loc Statement@src;
				
data Statement				
  = \assert(Expression expression)
  | \assert(Expression expression, str message)
  | \block(list[Statement] statements)
  | \break()
  | \break(str label)
  | \continue()
  | \continue(str label)
  | \do(Statement body, Expression condition)
  | \empty()
  | \foreach(Declaration parameter, Expression collection, Statement body)
  | \for(list[Declaration] initializers, Expression condition, list[Statement] updaters, Statement body)
  | \if(Expression condition, Statement thenBranch)
  | \if(Expression condition, Statement thenBranch, Statement elseBranch)
  | \label(str name, Statement body)
  | \return(Expression expression)
  | \return()
  | \switch(Expression expression, list[Statement] statements)
  | \case(Expression expression)
  | \defaultCase()
  | \synchronized(Expression lock, Statement body)
  | \throw(Expression expression)
  | \try(Statement body, list[Statement] catchClauses)
  | \try(Statement body, list[Statement] catchClauses, Statement \finally)										
  | \catch(Type exception, Statement body)
  | \declaration(Declaration declaration)
  | \while(Expression condition, Statement body)
  ;							

anno loc Type@binding;			
data Type 
  = arrayType(Type \type)
  | parameterizedType(Type \type, list[Type] typeParameters)
  | qualifier(Type qualifier, Type \type)
  | simpleType(str name)
  | unionType(list[Type] types)
  | wildcard()
  | upperbound(Type \type, Type bound)
  | lowerbound(Type \type, Type bound)
  | int32()
  | int64()
  | long()
  | float()
  | double()
  | char()
  | string()
  | byte()
  | \void()
  ;																			
*/
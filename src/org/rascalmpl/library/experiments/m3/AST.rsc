module experiments::m3::AST

data AstNode
	= \astNode(Declaration d	loc src = |unknown:///|, loc binding = |unknown:///|)
	| \astNode(Expression e		loc src = |unknown:///|, loc binding = |unknown:///|)
	| \astNode(Statement s		loc src = |unknown:///|, loc binding = |unknown:///|)
	| \astNode(Type t			loc src = |unknown:///|, loc binding = |unknown:///|)
	;

data Modifier
	= \private()
	| \public()
	| \protected()
	| \friendly()
	| \static()
	| \final()
	| \synchronized()
	| \transient()
	| \abstract()
	| \native()
	| \volatile()
	| \strictfp()
	| \deprecated()
	;

data Declaration 
  = \compilationUnit(list[AstNode] imports, list[AstNode] types)
  | \compilationUnit(AstNode package, list[AstNode] imports, list[AstNode] types)
  | \enum(str name, list[AstNode] implements, list[AstNode] constants, list[AstNode] body)
  | \enumConstant(str name, list[AstNode] arguments, AstNode class)
  | \enumConstant(str name, list[AstNode] arguments)
  | \class(list[Modifier] modifiers, str name, list[AstNode] extends, list[AstNode] implements, list[AstNode] body)
  | \class(list[AstNode] body)
  | \interface(list[Modifier] modifiers, str name, list[AstNode] extends, list[AstNode] implements, list[AstNode] body)
  | \field(AstNode \type, list[AstNode] fragments)
  | \initializer(list[Modifier] modifiers, list[AstNode] annotations, AstNode initializerBody)
  | \method(list[Modifier] modifiers, AstNode \return, str name, list[AstNode] parameters, list[AstNode] exceptions, AstNode impl)
  | \method(list[Modifier] modifiers, AstNode \return, str name, list[AstNode] parameters, list[AstNode] exceptions)
  | \method(list[Modifier] modifiers, str name, list[AstNode] parameters, list[AstNode] exceptions, AstNode impl)
  | \import(str name)
  | \staticImport(str name)
  | \package(str name)
  | \vararg(str name, AstNode \type)
  | \variables(AstNode \type, list[AstNode] \variables)
  | \variable(str name, int extraDimensions)
  | \variable(str name, int extraDimensions, AstNode initializer)
  | \typeParameter(str name, list[AstNode] extendsList)
  | \typeParameters(list[AstNode] typeParameters, AstNode decl)
  | \modifiers(list[Modifier] modifiers, AstNode decl) 
  | \annotations(AstNode decl, list[AstNode] annotations)
  | \annotationType(str name, list[AstNode] body)
  | \annotationTypeMember(AstNode typeArgument, str name)
  | \annotationTypeMember(AstNode typeArgument, str name, AstNode defaultBlock)
  | \parameter(AstNode \type, str name, int extraDimensions)
  | \parameter(AstNode \type, str name, int extraDimensions, AstNode initializer)
  ;
	
data Expression 
  = \markerAnnotation(str typeName)
  | \normalAnnotation(str typeName, list[AstNode] memberValuePairs)
  | \memberValuePair(str name, AstNode \value)				
  | \singleMemberAnnotation(str typeName, AstNode \value)
  | \arrayAccess(AstNode array, AstNode index)
  | \newArray(AstNode \type, list[AstNode] dimensions, AstNode init)
  | \newArray(AstNode \type, list[AstNode] dimensions)
  | \arrayInitializer(list[AstNode] elements)
  | \assignment(AstNode lhs, AstNode rhs)
  | \cast(AstNode \type, AstNode expression)
  | \char(str charValue)
  | \newObject(AstNode \type, list[AstNode] typeArgs, list[AstNode] args, AstNode class)
  | \newObject(AstNode \type, list[AstNode] typeArgs, list[AstNode] args)
  | \qualifier(AstNode qualifier, AstNode expression)
  | \conditional(AstNode expression, AstNode thenBranch, AstNode elseBranch)
  | \fieldAccess(AstNode expression, str name)
  | \instanceof(AstNode leftSide, AstNode rightSide)
  | \call(list[AstNode] typeArguments, str name, list[AstNode] arguments)
  | \call(AstNode receiver, list[AstNode] typeArguments, str name, list[AstNode] arguments)
//| \constructor(AstNode \type, list[AstNode] typeArguments, list[AstNode] arguments)
  | \constructor(list[AstNode] typeArguments, list[AstNode] arguments)
  | \variable(str name)
  | \null()
  | \number(str numberValue)
  | \boolean(bool boolValue)
  | \string(str stringValue)
  | \type(AstNode \type)
  | \bracket(AstNode expression)
  | \this()
  | \this(AstNode thisExpression)
  | \super()
  | \declaration(AstNode decl)
  | \infix(AstNode lhs, str operator, AstNode rhs)
  | \postfix(AstNode operand, str operator)
  | \prefix(str operator, AstNode operand)
  | \simpleName(str name)
  ;						

data Statement				
  = \assert(AstNode expression)
  | \assert(AstNode expression, str message)
  | \block(list[AstNode] statements)
  | \break()
  | \break(str label)
  | \continue()
  | \continue(str label)
  | \do(AstNode body, AstNode condition)
  | \empty()
  | \foreach(AstNode parameter, AstNode collection, AstNode body)
  | \for(list[AstNode] initializers, AstNode condition, list[AstNode] updaters, AstNode body)
  | \for(list[AstNode] initializers, list[AstNode] updaters, AstNode body)
  | \if(AstNode condition, AstNode thenBranch)
  | \if(AstNode condition, AstNode thenBranch, AstNode elseBranch)
  | \label(str name, AstNode body)
  | \return(AstNode expression)
  | \return()
  | \switch(AstNode expression, list[AstNode] statements)
  | \case(AstNode expression)
  | \defaultCase()
  | \synchronized(AstNode lock, AstNode body)
  | \throw(AstNode expression)
  | \try(AstNode body, list[AstNode] catchClauses)
  | \try(AstNode body, list[AstNode] catchClauses, AstNode \finally)										
  | \catch(AstNode exception, AstNode body)
  | \declaration(AstNode declaration)
  | \while(AstNode condition, AstNode body)
  | \expression(AstNode statement)
  ;							

data Type 
  = arrayType(AstNode \type)
  | parameterizedType(AstNode \type, list[AstNode] typeParameters)
  | qualifier(AstNode qualifier, AstNode \type)
  | simpleType(str name)
  | unionType(list[AstNode] types)
  | wildcard()
  | upperbound(AstNode \type)
  | lowerbound(AstNode \type)
  | \int()
  | short()
  | long()
  | float()
  | double()
  | char()
  | string()
  | byte()
  | \void()
  | \boolean()
  ;

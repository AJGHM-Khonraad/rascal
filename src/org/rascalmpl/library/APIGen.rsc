@license{
  Copyright (c) 2009-2011 CWI
  All rights reserved. This program and the accompanying materials
  are made available under the terms of the Eclipse Public License v1.0
  which accompanies this distribution, and is available at
  http://www.eclipse.org/legal/epl-v10.html
}
@contributor{Atze van der Ploeg - ploeg@cwi.nl - CWI}

module APIGen

/* translates a list of reified types to a java factory class */

import List;
import String;
import IO;


public str apiGen(str apiName,list[type[value]] ts) {
	map[str,str] emp = ();
	return apiGen(apiName,ts,emp);
}

public str apiGen(str apiName,list[type[value]] ts, map[str,str] externalTypes) {
	return 	"// This code was generated by Rascal API gen
			'import org.eclipse.imp.pdb.facts.type.Type;
			'import org.eclipse.imp.pdb.facts.type.TypeFactory;
			'import org.eclipse.imp.pdb.facts.type.TypeStore;
			' 
			'class <apiName> {
			'	public static TypeStore typestore = new TypeStore(
			'		org.rascalmpl.values.errors.Factory.getStore(), 
			'		org.rascalmpl.values.locations.Factory.getStore());
			'
			' 	private static TypeFactory tf = TypeFactory.getInstance();
			'
			'	<for(t <- ts) { >
			'	<declareType(t)>
			'	<}>
			'
			'	private static final class InstanceHolder {
			'		public final static KeySymFactory factory = new KeySymFactory();
			'	}
			'	  
			'	public static KeySymFactory getInstance() {
			'		return InstanceHolder.factory;
			'	}
			'	
			'	private KeySymFactory() {
			'	}
			'	
			'	public static TypeStore getStore() {
			'		return typestore;
			'	}
			'}
			";
}

public str declareType(type[value] t){
	switch(t){
		case adt(name, cons,list[tuple[type[value],type[value]]] ps):{
			return "public static final Type <name> = tf.abstractDataType(typestore, \"<name>\"<paramTuples(ps)>);
					'<for(c <- cons) {>	<declareConstructor(c,name)>
					'<}>
					";
		}
		case "alias"(str name,type[value] ap,list[tuple[type[value],type[value]]]  ps): {
			return "public static final Type <name> = tf.aliasType(typestore, \"<name>\",<type2FactoryCall(ap)><typeList2FactoryCallArgs(ps)>)";
		}
		default: throw "Cannot declare type <t>"; 
	}
}

public str declareConstructor(value t,str typeName){
	switch(t){
		case constructor(str cname,list[tuple[type[value],str]] args) : {
			return "public static final Type <typeName>_<cname> = tf.constructor(typestore,<typeName>,\"<cname>\"<typeNameTuples2FactoryCallArgs(args)>);";
		}
	}
}

public str paramTuples(list[tuple[type[value],type[value]]] t){
	if(t == [] ) return "";
	return  typeList2FactoryCallArgs([ta,tb | <ta,tb> <- t]);
	
}

public str typeList2FactoryCallArgs(list[type[value]] tss){
	return toExtraArgs([ type2FactoryCall(t) | t <- tss]);
}

public str toExtraArgs(list[str] strs){
	if(size(strs) == 0)
		 return "";
	else 
		return ("" | "<it>,<s>" | s <- strs);
}


public str typeNameTuples2FactoryCallArgs(list[tuple[type[value],str]] args){
	return toExtraArgs([type2FactoryCall(t),"\"" + n + "\"" | <t,n> <- args]);
} 

public str resolveType(type[value] t){
	if(externalTypes[t.name] ? ){
		return "<externalTypes[t.name]>.<t.name>";
	} else {
		t.name;
	}
}



public str type2FactoryCall(value v){
	if(type[value] t := v){
		switch(t){
			case value() : return "tf.valueType()";
			case void() : return "tf.voidType()";
			case int() :  return "tf.integerType()"; 
			case num() : return "tf.numberType()";
			case real() : return "tf.realType()";
			case bool() : return "tf.boolType()";
			// external type??? 
			case str() :  return "tf.stringType()"; 
			case loc() : return "tf.sourceLocationType()";
			case datetime() : return "tf.dateTimeType()";
			case tuple(tis) : return "tf.tupleType(<typeList2FactoryCallArgs(tis)>)";	
			case set(ti) :  return "tf.setType(<type2FactoryCall(ti)>)";		
			case rel(tis) : return "tf.relType(<typeList2FactoryCallArgs(tis)>)";
			case "alias"(name,p,q) : return resolveType (t);
			case node() : return "tf.nodeType()";
			case adt(name,_,_) : return resolveType (t);
			case constructor(name,_) : return resolveType (t);
			case list(ti) :  return "tf.listType(<type2FactoryCall(ti)>)";
			case map(ti,ti2) : return "tf.mapType(<type2FactoryCall(ti)>,<type2FactoryCall(ti2)>)";
			case parameter(name,t) : return "tf.parameterType(\"<name>\",<type2FactoryCall(t)>)";
		}
	} else if(str s := v){
		return s;
	}
}

